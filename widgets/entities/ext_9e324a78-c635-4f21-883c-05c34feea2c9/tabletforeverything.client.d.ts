/**
 * # Типы объектов
 *
 * Подробное описание читайте в [статье про типы данных](../pages/quick-start/intro_types.html).
 * @packageDocumentation
 */
/**
 * # Набор полей коллекции данных
 *
 * Любая коллекция системы описывается набором полей, расширяющим базовый тип
 * `ItemData`. В этом наборе коду поля сопоставляется его тип.
 */
interface ItemData {
    [key: string]: Type | Type[];
}
/**
 * # Базовый набор полей коллекции данных
 *
 * Все системные и пользовательские коллекции содержат базовый набор полей.
 */
interface BaseItemData extends ItemData {
    /**
     * Идентификатор объекта.
     */
    readonly __id: string;
    /**
     * Название объекта.
     */
    __name: TString;
    /**
     * Дата и время создания.
     */
    readonly __createdAt: TDatetime;
    /**
     * Автор объекта.
     */
    readonly __createdBy: UserItemRef;
    /**
     * Дата и время изменения.
     */
    readonly __updatedAt: TDatetime;
    /**
     * Автор последнего изменения.
     */
    readonly __updatedBy: UserItemRef;
    /**
     * Дата и время удаления.
     */
    readonly __deletedAt?: TDatetime;
}
/**
 * @ignore
 *
 * В схеме компании, которая возвращается с бэка, структура с полями (данными)
 * коллекции «Внешние пользователи» будет наследоваться от этого интерфейса.
 */
interface UserProfileItemData extends BaseItemData {
    readonly kind: 'user_profile_item_data';
}
/**
 * @ignore
 *
 * В схеме компании, которая возвращается с бэка, структура с полями (данными)
 * коллекции «Проекты» будет наследоваться от этого интерфейса
 */
interface ProjectItemData extends BaseItemData {
    readonly kind: 'project_item_data';
}
/**
 * @ignore
 *
 * Расширение набора полей коллекции базовыми полями
 */
declare type Based<T extends ItemData> = T & BaseItemData;
/**
 * # Интерфейс базового объекта системы
 *
 * Все объекты системы расширяют базовый объект.
 */
interface BaseItem<T extends ItemData> {
    /**
     * Значения полей объекта.
     */
    readonly data: Based<Partial<T>>;
    /**
     * Описание полей объекта.
     */
    readonly fields: Readonly<{
        [K in keyof (Based<T>)]: FieldType<(Based<T>)[K]>;
    }>;
    /**
     * Удаление дублирующихся данных в массивах.
     *
     * Выполнить удаление дубликатов в полях, в которых хранятся массивы ссылок на объекты системы
     * (пользователи, файлы, элементы приложений, документы).
     *
     * Этот метод, например, можно вызвать после массового изменения данных в объекте.
     * ```typescript
     * const app1 = await Context.data.app1.fetch();
     * const app2 = await Context.data.app2.fetch();
     *
     * app1.data.executors.push(app2.data.executors);
     * app1.normalize();
     *
     * // Далее перебираем элементы нового массива
     * app1.data.executors.forEach( ... );
     * ```
     */
    normalize(): void;
}
/**
 * # Базовый объект-ссылка на объект системы
 *
 * Ссылки на любые объекты системы расширяют базовый объект-ссылку.
 */
interface ItemRef<I extends BaseItem<any>> extends RefItem {
    /**
     * Запрос полных данных объекта-ссылки.
     */
    fetch(): Promise<I>;
}
/**
 * # Базовый тип ссылки на объект системы
 *
 * Содержит базовый набор полей.
 */
interface Item<T extends ItemData> extends BaseItem<T>, ItemRef<Item<T>> {
}
/**
 * # Элемент приложения
 */
interface ApplicationItem<Data extends ItemData, Params extends ItemData> extends BaseItem<Data>, ApplicationItemRef<Data, Params> {
    /**
     * @ignore
     */
    readonly kind: 'application';
    /**
     * Метод [[ApplicationItem.save]] сохраняет элемент приложения.
     *
     * Сохранять элемент необходимо после изменения данных элемента.
     *
     * ```typescript
     * const request = await Context.data.service_request.fetch();
     * request.data.responsible = Context.data.responsible;
     * await request.save();
     * ```
     */
    save(): Promise<void>;
    /**
     * Метод [[ApplicationItem.setStatus]] позволяет изменить статус элемента приложения.
     *
     * Статус элемента приложения меняется сразу при выполнении этого метода.
     *
     * Дополнительного вызова [[ApplicationItem.save]] не требуется.
     *
     * @param status Статус.
     * @param comment Причина смены статуса.
     *
     * ```typescript
     * const request = await Context.data.request.fetch();
     * const finalStatus = request.fields.__status.variants.completed;
     * await request.setStatus(finalStatus, "Закрыт автоматически");
     * ```
     */
    setStatus(status: TStatus<any, any>, comment?: string): Promise<boolean>;
    /**
     * Метод [[ApplicationItem.subscribe]] позволяет подписать пользователя на сообщения в ленте элемента приложения.
     *
     * @param user Пользователь.
     * ```typescript
     * // Подпишем текущего пользователя на ленту элемента приложения
     * const item = await Context.data.app.fetch();
     * const user = await System.users.getCurrentUser();
     * await app.subscribe(user);
     * ```
     */
    subscribe(user: TUser): Promise<void>;
    /**
     * Метод [[ApplicationItem.unsubscribe]] позволяет отписать пользователя от сообщений в ленте элемента приложения.
     *
     * @param user Пользователь.
     * ```typescript
     * // Отпишем текущего пользователя от ленты элемента приложения
     * const item = await Context.data.app.fetch();
     * const user = await System.users.getCurrentUser();
     * await app.unsubscribe(user);
     * ```
     */
    unsubscribe(user: TUser): Promise<void>;
    /**
     * Список пользователей, подписанных на сообщения в ленте элемента приложения.
     *
     * ```typescript
     * // Запишем подписчиков элемента приложения в контекст
     * const subscribers = await item.getSubscribers();
     * Context.data.subscribers = subscribers;
     * ```
     */
    getSubscribers(): Promise<TUser[]>;
    /**
     * Метод [[ApplicationItem.getPermissions]] получает права доступа, установленные для данного элемента приложения.
     *
     * Метод следует использовать, если нужно добавить новые права доступа к существующим.
     *
     * ```typescript
     * // Добавим права на элемент инициатору процесса
     * const item = await Context.data.request.fetch();
     * const user = Context.data.__createdBy;
     * // Получаем текущие права
     * const currPermissions = await item.getPermissions();
     * currPermissions.values.push(new PermissionValue(user, [PermissionType.READ]));
     * await item.setPermissions(currPermissions);
     * ```
     */
    getPermissions(): Promise<TPermissions>;
    /**
     * Метод [[ApplicationItem.hasPermission]] проверяет наличие права доступа для пользователя, группы, элемента оргструктуры, роли.
     *
     * @param orgunit Пользователь, группа, элемент оргструктуры или роль, которым выданы права.
     * @param type Уровень прав.
     *
     * ```typescript
     * const procurement = await Context.data.procurement.fetch();
     *
     * const user = Context.data.executor;
     *
     * await procurement.hasPermission(user, PermissionType['READ']);
     * ```
     */
    hasPermission(orgunit: TPermissionOrgunit, type: PermissionType): Promise<boolean>;
    /**
     * Метод [[ApplicationItem.setPermissions]] устанавливает новые права на элемент приложения.
     *
     * Метод полностью заменяет существующие права новыми.
     *
     * Для элементов приложения не имеют смысла права на создание, поэтому недоступно значение `PermissionValue.Create`.
     *
     * @param permissions Права доступа, которые будут установлены в элемент приложения.
     *
     * ```typescript
     * const procurement = await Context.data.procurement.fetch();
     *
     * const user = Context.data.executor;
     *
     * const permissions = new Permissions(
     * [new PermissionValue(user, [PermissionType.DELETE, PermissionType.READ])]);
     *
     * await procurement.setPermissions(permissions);
     * ```
     */
    setPermissions(permissions: TPermissions): Promise<void>;
    /**
     * Метод [[ApplicationItem.getSignHistory]] получает историю подписей приложения.
     *
     * ```typescript
     * // Пример сохранения подписей в контекстные переменные типа Файл
     * const app = await Context.data.dokument!.fetch();
     * const signHistory = await app.getSignHistory();
     *
     * Context.data.sign_attributes = await signHistory[0].signs[0].createSignFile();
     *
     * const attributes = await signHistory[0].signs[0].createAttributesFile();
     * if (attributes !== undefined) {
     *   Context.data.attributes = attributes;
     * }
     * ```
     */
    getSignHistory(): Promise<EntityVersion[]>;
    /**
     * Метод [[ApplicationItem.uploadSign]] загружает подпись приложения.
     *
     * Метод используется для реализации собственного механизма подписания в приложениях.
     * С помощью данного метода можно использовать для приложения подпись, полученную у внешнего провайдера.
     *
     * Для того чтобы воспользоваться данным методом, необходимо иметь:
     *
     * * тело подписи, представленное в формате base64;
     *
     * * тип подписи;
     *
     * * код провайдера (строковая константа, которая его идентифицирует);
     *
     * * хеш данных приложения, которые подписали;
     *
     * * данные, по которым вычислена подпись.
     *
     * В примере указан сценарий, где:
     *
     * * `dokument` — это приложение типа Документ в контексте;
     *
     * * Класс `MySignProvider` — несуществующий провайдер для примера.
     *
     * В результате мы получаем флаг, который говорит о результате загрузки. Если флаг имеет значение
     * `true` — загрузка прошла успешно, `false` — подпись не загружена.
     *
     * ```typescript
     * const app = await Context.data.dokument.fetch();
     * const provider = new MySignProvider();
     * const innerSigns = await Conetxt.data.dokument.getDataSigns();
     *
     * const attributesInnerSign = innerSigns.find(sign => sign.type === SignType.Attributes);
     * const sign = provider.Sign(attributesInnerSign.body);
     *
     * const newSign: NewSign = {
     *     sign: sign,
     *     codeProvider: "MyProvider",
     *     body: attributesInnerSign.body,
     *     signType: SignType.Attributes,
     *     hash: attributesInnerSign.hash,
     * };
     *
     * const isUploaded = await app.uploadSign(newSign);
     * ```
     * @param sign Данные для загрузки подписи.
     */
    uploadSign(sign: NewSign): Promise<boolean>;
    /**
     * Метод [[ApplicationItem.getDataSigns]] получает внутреннюю подпись данных приложения.
     *
     * При вычислении внутренних подписей приложения система учитывает пользовательские настройки для
     * подписания данных. В полученных данных содержится набор подписей двух типов: подписи атрибутов и подписи файла.
     *
     * Каждая такая подпись содержит в себе:
     *
     * * `hash` подпись данных приложения;
     *
     * * `body` данные, для которых вычислен хеш;
     *
     * * `type` тип подписи.
     *
     *
     * В указанном примере контекст содержит:
     *
     * * `dokument` приложение типа Файл, включающее настройки подписи.
     *
     * В представленном примере выполняется поиск подписи и использование `hash`, `body` для
     * сохранения полученной подписи у приложения.
     *
     * ```typescript
     * const app = await Context.data.dokument.fetch();
     * const dataSigns = await app.getDataSigns();
     * const dataSign = res.find( (res: any)  => res.type === SignType.File);
     *
     * const newSign: NewSign = {
     *     sign: "aGVsbG8=",
     *     codeProvider: "External",
     *     body: btoa(app.data.__file!.hash),
     *     hash: dataSign.hash
     * }
     *
     * await app.uploadSign(newSign);
     * ```
     */
    getDataSigns(): Promise<SignData[]>;
}
/**
 * # Объект-ссылка элемента приложения
 *
 * Объекты-ссылки, как правило, используются в свойствах типа Приложение,
 * чтобы не грузить сразу все связанные данные.
 *
 * Чтобы считать полные данные элемента приложения, нужно вызвать метод [[ApplicationItemRef.fetch]]
 * и получить полный объект элемента [[ApplicationItem]].
 *
 * ```typescript
 * const my_app_full = await Context.data.my_app.fetch();
 * ```
 */
interface ApplicationItemRef<Data extends ItemData, Params extends ItemData> extends ItemRef<ApplicationItem<Data, Params>> {
    /**
     * Метод [[ApplicationItemRef.getSettings]] позволяет получить настройки приложения.
     *
     * ```typescript
     * const app = Context.data.dokument;
     * if (app === undefined) {
     *  return;
     * }
     * const settings = await app.getSettings();
     * ```
     */
    getSettings(): Promise<TSettings>;
    /**
     * Метод [[ApplicationItemRef.delete]] позволяет удалить элемент приложения.
     *
     * ```typescript
     * await Context.data.app.delete();
     * ```
     */
    delete(): Promise<void>;
    /**
     * Метод [[ApplicationItemRef.restore]] позволяет восстановить удаленный элемент приложения.
     *
     * ```typescript
     * await Context.data.app.restore();
     * ```
     */
    restore(): Promise<void>;
    /**
     * Метод [[ApplicationItemRef.sendMessage]] позволяет отправлять сообщения в ленту элемента приложения.
     *
     * @param title Тема сообщения.
     * @param message Тело сообщения.
     *
     * ```typescript
     * await Context.data.request.sendMessage("Работа по заявке завершена", `Решение: ${Context.data.result}`)
     * ```
     */
    sendMessage(title: string, message: string): Promise<void>;
    /**
     * Метод [[ApplicationItemRef.setFolder]] позволяет изменять папку элемента иерархического справочника.
     *
     * @param id ID папки.
     *
     * ```typescript
     * const item = await Context.data.n1;
     * await item.setFolder('00000-00000-00000-00000');
     * ```
     */
    setFolder(id: string): Promise<void>;
    /**
     * Метод [[ApplicationItemRef.getFolder]] позволяет получить папку элемента иерархического справочника.
     * ```typescript
     * const item = await Context.data.n1;
     * const folder = await item.getFolder();
     * ```
     */
    getFolder(): Promise<TFolder | undefined>;
    /**
     * **Метод устарел**. Получение списка регистраций элемента приложения.
     * ```typescript
     * const item = Context.data.d1!
     * await item.getRegistrations();
     * ```
     *
     * @deprecated Так как метод устарел, используйте [[docflow]]:
     * ```typescript
     * const item = Context.data.d1!
     * await item.docflow().getRegistrations();
     * ```
     */
    getRegistrations(): Promise<ApplicationItemRegistration[]>;
    /**
     * **Метод устарел**. Автоматическая регистрация элемента приложения.
     *
     * @param nomenclatureId: string Номер дела.
     *
     * Номер регистрации будет сформирован автоматически в соответствии с шаблоном, заданным в настройках дела.
     * ```typescript
     * // Пример автоматической регистрации всех доступных для приложения делах
     * const item = Context.data.d1!
     * const settings = await Application.getSettings();
     * settings.registrationSettings.nomenclatureIds.forEach(nomenclatureId => {
     *      item.register(nomenclatureId);
     * })
     * ```
     *
     * @deprecated Так как метод устарел, используйте [[docflow]]:
     * ```typescript
     * const item = Context.data.d1!
     * const settings = await Application.getSettings();
     * settings.registrationSettings.nomenclatureIds.forEach(nomenclatureId => {
     *      item.docflow().register(nomenclatureId);
     * })
     * ```
     */
    register(nomenclatureId: string): Promise<boolean>;
    /**
     * **Метод устарел**. Регистрация элемента приложения вручную (если включена регистрация вручную в настройках дела).
     *
     * @param nameReg: string Номер регистрации, с которым пройдет регистрация.
     * @param nomenclatureId: string Номер дела.
     *
     * ```typescript
     * // Пример регистрации вручную во всех доступных для приложения делах
     * const item = Context.data.d1!
     * const settings = await Application.getSettings();
     * settings.registrationSettings.nomenclatureIds.forEach(nomenclatureId => {
     *      item.manualRegister("Номер 1", nomenclatureId);
     * })
     * ```
     *
     * @deprecated Так как метод устарел, используйте [[docflow]]:
     * ```
     * const item = Context.data.d1!
     * const settings = await Application.getSettings();
     * settings.registrationSettings.nomenclatureIds.forEach(nomenclatureId => {
     *      item.docflow().manualRegister("Номер 1", nomenclatureId);
     * })
     * ```
     */
    manualRegister(nameReg: string, nomenclatureId: string): Promise<boolean>;
    /**
     * Метод получает объект для работы с документооборотом.
     *
     * ```typescript
     * const item = await Context.data.n1;
     * const approvalLists = await item.docflow().getApprovalLists();
     * ```
     */
    docflow(): DocflowApplicationItemRef;
}
/**
 * # Категория элементов приложения
 *
 * @ignore
 */
interface CategoryItem<C extends ItemData> extends BaseItem<C>, ItemRef<CategoryItem<C>> {
    /**
     * @ignore
     */
    readonly kind: 'category';
}
/**
 * # Ссылка на категорию элементов приложения
 *
 * @ignore
 */
interface CategoryItemRef<C extends ItemData> extends ItemRef<CategoryItem<C>> {
}
/**
 * # Поля объекта пользователя
 */
interface UserData extends Based<ItemData> {
    /**
     * Email пользователя.
     */
    email: TString;
    /**
     * ФИО пользователя.
     */
    fullname: TFullName;
    /**
     * Мобильный телефон пользователя.
     */
    mobilePhone: TPhone<PhoneType.Mobile>;
    /**
     * Рабочий телефон пользователя.
     */
    workPhone: TPhone<PhoneType.Work>;
    /**
     * Дата рождения.
     */
    birthDate: TDate;
    /**
     * Дата приёма на работу.
     */
    hireDate: TDate;
    /**
     * Идентификаторы элементов оргуструктуры, в которые входит пользователь.
     */
    readonly osIds: OrganisationStructureItemRef[];
    /**
     * Идентификаторы групп, в которые входит пользователь.
     */
    readonly groupIds: UserGroupItemRef[];
    /**
     * Аватар пользователя.
     */
    avatar: ImageItem;
    /**
     * Часовой пояс пользователя.
     */
    timezone?: TimezoneNames;
    /**
     * Статус пользователя.
     */
    __status: TStatus<string, ItemData>;
    /**
     * Учетные записи пользователя.
     */
    accounts: TAccount<AccountType>[];
    /**
     * Отображаемая должность.
     */
    displayedPosition: TString;
    /**
     * Login пользователя.
     */
    login: TString;
    /**
     * Дополнительные данные.
     */
    additionalData: TString;
}
/**
 * # Объект текущего пользователя
 */
interface CurrentUserItem extends UserItem {
    /**
     * Выход из системы для текущего пользователя.
     *
     * ```typescript
     * const user = await System.users.getCurrentUser();
     * await user.logout();
     * ```
     */
    logout(): Promise<void>;
}
/**
 * # Объект пользователя
 */
interface UserItem extends BaseItem<UserData>, ItemRef<UserItem>, UserItemRef {
    /**
     * @ignore
     */
    readonly kind: 'user';
    /**
     * Часовой пояс со смещением времени в часах.
     *
     * Если у пользователя не определен часовой пояс, используется часовой пояс компании.
     *
     * Пример использования:
     * ```typescript
     * const currentUser = await System.users.getCurrentUser();
     * const userTimezone = currentUser.timezone;
     * ```
     */
    readonly timezone: TTimezone;
    /**
     * Метод [[UserItem.getLocale]] позволяет получить локаль пользователя.
     *
     * Локаль состоит из двух частей, разделенных при помощи дефиса:
     * * двух- или трёхсимвольный IETF-код языка;
     * * код региона (ISO 3166-1), как правило, это двухсимвольный код страны.
     *
     * Примеры:
     * * ru-RU — локаль для русского языка в России;
     * * en-US — локаль для английского языка в США;
     * * en-UK — локаль для английского языка в Великобритании.
     *
     * ```typescript
     * const currentUser = await System.users.getCurrentUser();
     * const userLocale = await currentUser.getLocale();
     * if (userLocale.startsWith('ru-')) {
     *   Context.data.message = "Привет мир!";
     * } else if (userLocale.startsWith('es-')) {
     *   Context.data.message = "Hola mundo!";
     * } else {
     *   Context.data.message = "Hello world!";
     * }
     * ```
     * @returns Строковое значение локали.
     */
    getLocale(): Promise<string>;
    /**
     * Метод [[UserItem.positions]] позволяет получить список должностей, на которые назначен пользователь.
     *
     * ```typescript
     * const currentUser = await System.users.getCurrentUser();
     * const positions = await currentUser.positions();
     * ```
     */
    positions(): Promise<OrganisationStructureItem[]>;
    /**
     * Метод [[UserItem.setPositions]] позволяет задать список должностей, на которые назначен пользователь.
     *
     * При этом предудущие значения должностей пользователя будут потеряны.
     * После использования этого метода необходимо сохранить объект пользователя.
     *
     * @param position Массив должностей.
     *
     * ```typescript
     * const user = await Context.data.user.fetch();
     * const os = await System.organisationStructure.fetchTree();
     * const positionNames = ['Юрист', 'Директор по развитию'];
     * const positions: OrganisationStructureItem[] = [];
     * for (const positionName of positionNames) {
     *     const position = os.find(positionName);
     *     positions.push(position);
     * }
     * user.setPositions(positions);
     * await user.save();
     * ```
     */
    setPositions(positions: OrganisationStructureItem[]): void;
    /**
     * Метод [[UserItem.assignToPosition]] позволяет назначить пользователя на должность.
     *
     * После использования этого метода необходимо сохранить объект пользователя.
     *
     * @param position Должность.
     *
     * ```typescript
     * const user = await Context.data.user.fetch();
     * const os = await System.organisationStructure.fetchTree();
     * const position = os.find('Директор по рекламе');
     * user.assignToPosition(position);
     * await user.save();
     * ```
     */
    assignToPosition(position: OrganisationStructureItem): void;
    /**
     * Метод [[UserItem.removeFromPosition]] позволяет снять пользователя с должности.
     *
     * После использования этого метода необходимо сохранить объект пользователя.
     *
     * @param position Должность.
     *
     * ```typescript
     * const user = await Context.data.user.fetch();
     * const os = await System.organisationStructure.fetchTree();
     * const position = os.find('Директор по рекламе');
     * user.removeFromPosition(position);
     * await user.save();
     * ```
     */
    removeFromPosition(position: OrganisationStructureItem): void;
    /**
     * Метод [[UserItem.save]] сохраняет объект пользователя.
     *
     * Метод позволяет обновлять текущего пользователя и приглашать новых пользователей.
     * Поля, доступные для редактирования: `fullname`, `mobilePhone`, `workPhone`, `birthDate`, `hireDate`, `avatar`, `timezone`,
     * `accounts`, `displayedPosition` и `additionalData`.
     * Для приглашения нового пользователя обязательным полем является `email`.
     *
     * Обновление:
     * ```typescript
     *     const user = await Context.data.user.fetch();
     *     const timezones = System.timezones.all().filter( timezone => timezone.name === "Africa/Bujumbura" )
     *     user.data.timezone = timezones[0].name;
     *     user.data.mobilePhone!.tel = "9655555555";
     *     user.data.fullname!.firstname = "Игорь";
     *
     *     await user.save();
     *
     * ```
     *
     * Для отправки приглашения новому пользователю необходимо его инициализировать:
     * ```typescript
     *     const user = System.users.create();
     *     user.data.email = "example@example.com";
     *     user.data.fullname = {
     *         lastname: "Иванов",
     *         firstname: "Иван",
     *         middlename: "Иванович"
     *     }
     *
     *     await user.save();
     * ```
     */
    save(): Promise<void>;
}
/**
 * # Ссылка на объект пользователя
 */
interface UserItemRef extends ItemRef<UserItem> {
    /**
     * @ignore
     */
    readonly kind: 'user';
    /**
     * Метод [[UserItemRef.getChiefs]] получает всех руководителей пользователя.
     *
     * Метод рассчитывает руководителей всех элементов оргструктуры, на которые назначен пользователь.
     * Руководителем считается первая должность, по пути к корню дерева оргструктуры,
     * на которую назначен пользователь. Если пользователь не назначен на должность, то вернётся пустой список.
     * Если пользователь сопоставлен корню дерева оргуструтуры, то вернётся он сам.
     *
     * ```typescript
     * const chiefs = await Context.data.__createdBy.getChiefs();
     * Context.data.approver = chiefs[0];
     * ```
     */
    getChiefs(): Promise<UserItemRef[]>;
    /**
     * Метод [[UserItemRef.block]] блокирует учетную запись пользователя.
     *
     * ```typescript
     * await Context.data.user.block();
     * ```
     */
    block(): Promise<void>;
    /**
     * Метод [[UserItemRef.unblock]] позволяет разблокировать учетную запись пользователя.
     *
     * ```typescript
     * await Context.data.user.unblock();
     * ```
     */
    unblock(): Promise<void>;
}
/**
 * # Поля объекта группы пользователей
 */
interface UserGroupData extends Based<ItemData> {
    /**
     * Код группы.
     */
    code: TString;
    /**
     * Раздел, в котором находится группа.
     */
    namespace: TString;
    /**
     * Является ли группа ролью.
     *
     * Роль — это вид группы, к которому может принадлежать только один пользователь.
     */
    isRole: TBoolean;
    /**
     * Является ли группа группой по умолчанию.
     *
     * Все новые пользователи системы будут автоматически добавляться в такие группы.
     */
    isDefault: TBoolean;
    /**
     * Описание группы.
     */
    description: TString;
    /**
     * Вложенные объекты.
     *
     * В группы могуть быть включены другие группы, элементы оргструктуры
     * или непосредственно пользователи.
     */
    subOrgunitIds?: TString[];
}
/**
 * # Группа пользователей
 */
interface UserGroupItem extends BaseItem<UserGroupData>, ItemRef<UserGroupItem>, UserGroupItemRef {
    /**
     * Метод [[UserGroupItem.save]] позволяет сохранить группу пользователей.
     *
     * ```typescript
     * const serviceEmployeesGroup = await System.userGroups.search().where(f => f.__name.eq("Сотрудники сервиса")).first();
     * await serviceEmployeesGroup.addItem(Context.data.new_employee);
     * await serviceEmployeesGroup.save();
     * ```
     */
    save(): Promise<void>;
    /**
     * Метод [[UserGroupItem.delete]] позволяет удалить группу пользователей.
     *
     * ```typescript
     * const group = await System.userGroups.search().where(f => f.__name.eq("Сотрудники сервиса (Устаревшая)")).first();
     * const parentGroups = await group.parentGroups();
     * if (parentGroups && parentGroups.length === 0) {
     *      await group.delete();
     * }
     * ```
     */
    delete(): Promise<void>;
    /**
     * Метод [[UserGroupItem.parentGroups]] позволяет получить список групп, в которые входит выбранная группа.
     *
     * ```typescript
     * const parentGroups = await group.parentGroups();
     * ```
     */
    parentGroups(): Promise<UserGroupItem[]>;
    /**
     * Метод [[UserGroupItem.addItem]] позволяет добавить пользователей, элементы оргструктуры, группы в пользовательскую группу.
     *
     * @param children Список пользователей, элементов оргструктуры, групп.
     *
     * ```typescript
     * const targetGroup = await System.userGroups.search().where(f => f.__name.eq("Участники совещания")).first();
     * const group = await System.userGroups.search().where(f => f.__name.eq("Руководители")).first();
     * const os = await System.organisationStructure.fetchTree();
     * const position = os.find('Директор по рекламе');
     *
     * await targetGroup.addItem(group, position, Context.data.user);
     * ```
     */
    addItem(...children: (UserItemRef | UserGroupItemRef | OrganisationStructureItemRef)[]): Promise<void>;
    /**
     * Метод [[UserGroupItem.users]] возвращает пользователей, состоящих в группе.
     *
     * @param from С какой позиции (в массиве) возвращать пользователей. По умолчанию 0.
     * @param size Сколько пользователей вернуть. По умолчанию 10.
     *
     * ```typescript
     * const group = await System.userGroups.search().where(f => f.__name.eq("Руководители")).first();
     * const groupMembers = await group.users(0, 20);
     * ```
     */
    users(from?: number, size?: number): Promise<UserItem[]>;
    /**
     * Метод [[UserGroupItem.subGroups]] возвращает все подгруппы.
     *
     * ```typescript
     * const group = await System.userGroups.search().where(f => f.__name.eq("Участники совещания")).first();
     * const subGroups = await group.subGroups();
     * ```
     */
    subGroups(): Promise<UserGroupItem[]>;
    /**
     * Метод [[UserGroupItem.positions]] позволяет получить список должностей, включённых в группу.
     *
     * ```typescript
     * const groupName = 'Администраторы раздела';
     * const group = await System.userGroups.search().where(g => g.__name.eq(groupName)).first();
     * const positions = await group.positions();
     * ```
     */
    positions(): Promise<OrganisationStructureItem[]>;
}
/**
 * # Ссылка на объект группы пользователей
 */
interface UserGroupItemRef extends ItemRef<UserGroupItem> {
    /**
     * @ignore
     */
    readonly kind: 'group';
}
/**
 * # Поля объекта элемента организационной структуры
 */
interface OrganisationStructureData extends Based<ItemData> {
    /**
     * Тип элемента. Допустимые значения: POSITION, DEPARTMENT, GROUP (см. [[OrganisationStructureItemType]]).
     */
    type: TString;
    /**
     * Название элемента.
     */
    name: TString;
    /**
     * Расположение элемента на одном уровне дерева/поддерева структуры.
     *
     * Влияет только на визуальное представление дерева организационной структуры.
     */
    readonly sort: TFloat;
    /**
     * Идентификатор родительского элемента.
     */
    readonly parent: TString;
}
/**
 * # Элемент организационной структуры
 *
 * Представляет собой один из элементов иерархии организационной структуры: должность, отдел или группу.
 *
 * Тип не имеет конструктора. Создать новый элемент можно с помощью метода [[OrganisationStructure.createItem]]:
 * ```typescript
 * const item = System.organisationStructure.createItem('Директор по развитию', OrganisationStructureItemType.Position);
 * ```
 * Добавить вновь созданный элемент в существующую организационную структуру (к заданному родителю) можно с помощью метода
 * [[OrganisationStructureItem.addChild]].
 *
 * После внесения изменений в организационную структуру ее необходимо сохранять с помощью метода [[OrganisationStructure.save]].
 *
 * ```typescript
 * const tree = await System.organisationStructure.fetchTree();
 * tree.getRoot().addChild(item);
 * const errs = await System.organisationStructure.save(tree);
 * if (errs.length === 0) {
 *     Context.data.debug = "Успешно сохранено";
 * }
 * ```
 */
interface OrganisationStructureItem extends BaseItem<OrganisationStructureData>, ItemRef<OrganisationStructureItem>, OrganisationStructureItemRef {
    /**
     * @ignore
     */
    readonly kind: 'orgstruct';
    /**
     * Метод [[OrganisationStructureItem.getParent]] позволяет получить родительский элемент для текущего элемента.
     *
     * ```typescript
     * const parent = someItem.getParent();
     * ```
     * В случае если элемент не имеет родителя, метод вернет значение undefined.
     */
    getParent(): OrganisationStructureItem | undefined;
    /**
     * Метод [[OrganisationStructureItem.getChildren]] позволяет получить дочерние элементы для текущего элемента.
     * ```typescript
     * const children = someItem.getChildren();
     * ```
     * В случае если элемент не имеет дочерних элементов, метод вернет пустой массив.
     */
    getChildren(): OrganisationStructureItem[];
    /**
     * Метод [[OrganisationStructureItem.addChild]] позволяет добавить дочерний элемент для текущего элемента.
     *
     * @param item Добавляемый элемент оргструктуры.
     * ```typescript
     * someItem.addChild(item);
     * ```
     */
    addChild(item: OrganisationStructureItem): void;
    /**
     * Метод [[OrganisationStructureItem.removeChild]] позволяет удалить один или несколько дочерних элементов текущего элемента.
     *
     * @param item Удаляемые элементы оргструктуры.
     * ```typescript
     * someItem.removeChild(item);
     * ```
     */
    removeChild(item: OrganisationStructureItem | OrganisationStructureItem[]): void;
    /**
     * Метод [[OrganisationStructureItem.moveToParent]] позволяет сделать текущий элемент дочерним для заданного элемента.
     *
     * @param parent Новый родитель элемента.
     * ```typescript
     * someItem.moveToParent(newParent);
     * ```
     */
    moveToParent(parent: OrganisationStructureItem): void;
    /**
     * Метод [[OrganisationStructureItem.moveBefore]] позволяет переместить элемент на одну позицию влево на дереве оргструктуры.
     *
     * Перемещение происходит среди дочерних элементов родителя данного элемента, т.е. на одном уровне организационной структуры.
     * Метод влияет только на визуальное представление организационной структуры на странице ее редактирования.
     * ```typescript
     * someItem.moveBefore();
     * ```
     */
    moveBefore(): void;
    /**
     * Метод [[OrganisationStructureItem.moveAfter]] позволяет переместить элемент на одну позицию вправо на дереве оргструктуры.
     *
     * Перемещение происходит среди дочерних элементов родителя данного элемента, т. е. на одном уровне организационной структуры.
     * Метод влияет только на визуальное представление организационной структуры на странице ее редактирования.
     * ```typescript
     * someItem.moveAfter();
     * ```
     */
    moveAfter(): void;
    /**
     * Метод [[OrganisationStructureItem.find]] позволяет организовать поиск на поддереве элементов, где корень — текущий элемент.
     *
     * Будет возвращен первый удовлетворяющий предикату элемент или `undefined`, если таких элементов нет.
     * @param predicate Предикат для поиска на поддереве элементов.
     * ```typescript
     * const item = tree.getRoot().find(i => i.data.name === 'Менеджеры' && i.data.type === OrganisationStructureItemType.Group);
     * if (item === undefined) {
     *     // Элемент не найден
     * }
     * ```
     */
    find(predicate: (item: OrganisationStructureItem) => boolean): OrganisationStructureItem | undefined;
    /**
     * Метод [[OrganisationStructureItem.isPosition]] возвращает `true`, если элемент является должностью, иначе — `false`.
     * ```typescript
     * const item = tree.getRoot().find(i => i.data.name === 'Менеджеры');
     * if (item && item.isPosition()) {
     *     // item является должностью
     * }
     * ```
     */
    isPosition(): boolean;
    /**
     * Метод [[OrganisationStructureItem.isGroup]] возвращает `true`, если элемент является группой, иначе — `false`.
     * ```typescript
     * const item = tree.getRoot().find(i => i.data.name === 'Менеджеры');
     * if (item && item.isGroup()) {
     *     // item является группой
     * }
     * ```
     */
    isGroup(): boolean;
    /**
     * Метод [[OrganisationStructureItem.isDepartment]] возвращает `true`, если элемент является отделом, иначе — `false`.
     * ```typescript
     * const item = tree.getRoot().find(i => i.data.name === 'Менеджеры');
     * if (item && item.isDepartment()) {
     *     // item является отделом
     * }
     * ```
     */
    isDepartment(): boolean;
}
/**
 * # Ссылка на объект элемента организационной структуры
 */
interface OrganisationStructureItemRef extends ItemRef<OrganisationStructureItem> {
    /**
     * @ignore
     */
    readonly kind: 'orgstruct';
}
/**
 * # Тип вложения в ответе сервера
 *
 * Заголовок ответа может быть либо `inline` (значение, указывающее, что файл может отображаться внутри
 * веб-страницы или как веб-страница), либо `attachment` (значение, указывающее, что его следует загрузить).
 */
declare enum DispositionType {
    /**
     * # Файл следует загрузить
     */
    Attachment = "attachment",
    /**
    * # Файл может отображаться внутри веб-страницы или как веб-страница
    */
    Inline = "inline"
}
/**
 * # Файл
 *
 * Объект предназначен для работы с файлами, позволяет выполнять операции над
 * файлами, хранимыми на диске: получать ссылки для загрузки, сохранять и получать права доступа,
 * подписываться на изменения и др.
 */
interface FileItem extends BaseItem<FileData>, ItemRef<FileItem> {
    /**
     * @ignore
     */
    readonly kind: 'file';
    /**
     * Метод [[FileItem.getDownloadUrl]] получает ссылку на загрузку содержимого файла.
     *
     * Полученная ссылка возвращает содержимое файла. По такой ссылке загрузку могут выполнить все пользователи,
     * в том числе и анонимные. Ссылка на загрузку доступна в течение одного часа.
     * Тип вложения может быть `attachment` или `inline`. Если не передаем параметр `dispositionType`, по умолчанию
     * устанавливается значение `attachment`.
     *
     * ```typescript
     * const url = await file.getDownloadUrl();
     * ```
     */
    getDownloadUrl(dispositionType?: DispositionType): Promise<string>;
    /**
     * Метод [[FileItem.setPermissions]] устанавливает список прав на файл.
     *
     * Метод требуется использовать, когда необходимо изменить права на доступ к файлу,
     * добавив или удалив права доступа для пользователя, группы, элемента оргструктуры.
     * Для добавления новых прав доступа необходимо использовать объект [[TPermissionValue]],
     * а для выдачи прав на конкретные операции — [[PermissionType]].
     * После создания нового объекта [[TPermissions]] для сохранения новых прав доступа
     * используется метод [[FileItem.setPermissions]].
     *
     *```typescript
     *
     * const user = Context.data.__createdBy;
     *
     * const permissions = new Permissions([
     *  new PermissionValue(user, [PermissionType.DELETE, PermissionType.READ]),
     * ]);
     *
     * await file.setPermissions(perms);
     *```
     *
     * @param perms Новые правила доступа к файлу.
     */
    setPermissions(perms: TPermissions): Promise<void>;
    /**
     * Метод [[FileItem.getPermissions]] получает права доступа к файлу.
     *
     * После удачного выполнения запроса прав в ответе будет получен объект [[TPermissions]]. Полученный объект
     * можно модифицировать или анализировать для различных проверок доступа.
     *
     *```typescript
     * const perm = await file.getPermissions();
     *```
     */
    getPermissions(): Promise<TPermissions>;
    /**
     * Метод [[FileItem.hasPermission]] проверяет наличие права доступа [[PermissionType]].
     *
     * Метод позволяет легко проверить наличие возможности на выполнение операции [[PermissionType]] с файлом.
     * После использования метод вернет флаг о результате. Если значение флага `true`, то пользователь может выполнять
     * запрошенную операцию с файлом. Также можно проверять доступ для элементов оргструктуры.
     *
     * ```typescript
     * const user = Context.data.__createdBy;
     *
     * const canUpdate = await file.hasPermission(user, PermissionType.UPDATE);
     * ```
     *
     * @param group Группа или пользователь для проверки.
     * @param type Тип операции.
     */
    hasPermission(group: TPermissionOrgunit, type: PermissionType): Promise<boolean>;
    /**
     * Метод [[FileItem.subscribe]] подписывает пользователей на файл.
     *
     * Создание подписки на файл позволит пользователям получать оповещения об
     * изменении данных файла созданиях его версий и других событиях.
     *
     * @param users Пользователи.
     * ```typescript
     * await file.subscribe(user1, user2, ...users);
     * ```
     *
     * @param users Пользователи для подписки.
     */
    subscribe(...users: TUser[]): Promise<void>;
    /**
     * Метод [[FileItem.unsubscribe]] отписывает пользователей от файла.
     *
     * Удаление подписки на файл позволяет прекратить получение оповещений об изменении файла.
     *
     * @param users Пользователи.
     * ```typescript
     * await file.unsubscribe(user1, user2, ...users);
     * ```
     *
     * @param users Пользователи для отписки.
     */
    unsubscribe(...users: TUser[]): Promise<void>;
    /**
     * Метод [[FileItem.addVersion]] создает новую версию файла.
     *
     * Метод позволяет обновить содержимое файла на диске, не создавая новый файл.
     * Созданная версия попадает в историю файла. Метод необходимо использовать, когда
     * тело файла может быть получено из разных источников или сгенерировано при
     * выполнении скрипта. Поле коментарий служит описанием добавляемой версии.
     *
     * В примере показано, как можно добавить версию файла после загрузки с внешнего ресурса. В
     * качестве коментария можно указать, что файл загружен с внешнего ресурса.
     * Контекст содержит:
     *
     * * `downloadUrl` строка, хранящая url для загрузки файла;
     *
     * * `newName` новое название файла;
     *
     * * `file` файл, хранящийся на диске.
     *
     * ```typescript
     * const fileResponse = await fetch(Context.data.downloadUrl);
     * const fileContent = await fileResponse.arrayBuffer();
     *
     * const newName = Context.data.fileName;
     * await Context.data.file.addVersion(newName, fileContent, 'загрузка файла с внешнего ресурса');
     * ```
     *
     * @param name Новое имя файла.
     * @param body Тело файла.
     * @param comment Комментарий для новой версии.
     */
    addVersion(name: string, body: ArrayBuffer, comment?: string): Promise<void>;
    /**
     * Метод [[FileItem.addVersionFromLink]] создает версию, загружая файл по ссылке.
     *
     * Сокращенная версия метода [[FileItem.addVersion]] использует ссылку загрузки для создания новой
     * версии файла. С помощью ссылки загружается содержимое файла. Оно используется для создания новой версии.
     * При использовании метода, возможно указать комментарий к добавляемой версии файла.
     *
     * В примере показано, как можно добавить версию файла с использованием ссылки для загрузки.
     * Контекст содержит:
     *
     * * `downloadUrl` строка, хранящая url для загрузки файла;
     *
     * * `newName` новое название файла;
     *
     * * `file` файл, хранящийся на диске.
     *
     * ```typescript
     * const newName = Context.data.fileName;
     * await Context.data.file.addVersionFromLink(newName, Context.data.downloadUrl);
     * ```
     *
     * @param name Новое имя файла.
     * @param url Публичная ссылка на файл.
     * @param comment Комментарий для новой версии.
     */
    addVersionFromLink(name: string, url: string, comment?: string): Promise<void>;
    /**
     * Метод [[FileItem.getFileMD5Hash]] получает md5-хеш файла.
     *
     * В примере контекст содержит `file` — файл из системы.
     *
     *```typescript
     * const hash = await file.getFileMD5Hash();
     *```
     */
    getFileMD5Hash(): Promise<string>;
    /**
     * Метод [[FileItem.getVersions]] получает список версий файла.
     *
     * В примере показан поиск первой версии файла. Идентификатор файла необходимо получить из контекста.
     * Для получения всех версий используется параметр `offset`.
     * Версии выбираются в порядке убывания порядкового номера, то есть от самой свежей к более старым.
     * Первая версия имеет порядковый номер 1.
     *
     * ```typescript
     * // Получаем ID файла
     * const fileUUID = Context.data.fileID;
     * if(!fileUUID) {
     *  return;
     * }
     *
     * // Ищем файл
     * const file = await System.files.search().where(x => x.__id.eq(fileUUID)).first();
     * if(!file) {
     *  return;
     * }
     *
     * // Получаем все версии файлов. Если версий нет, то возвращаем ошибку
     * let allFileVersions: FileVersionItem[] = [];
     * let verCount = 0;
     * let offset = 0;
     * const limit = 20;
     * do {
     *  const versions = await file.getVersions(offset, limit);
     *  verCount = versions.length;
     *  offset = offset + verCount;
     *  allFileVersions.push(...versions);
     * } while (verCount === limit)
     * if(allFileVersions.length === 0) {
     *  throw new Error("У файла нет версий");
     * }
     * const firstVersion = allFileVersions.find(ver => ver.version === 1);
     *
     * // Получаем тело файла
     * const url = await firstVersion.getDownloadUrl();
     * const content = fetch(url);
     * ```
     *
     * @param offset Сдвиг относительно начального поиска. По умолчанию равен 0.
     * @param limit Максимальное количество полученных записей. По умолчанию равно 10. Максимальное значение 10000.
     */
    getVersions(offset?: number, limit?: number): Promise<FileVersionItem[]>;
}
/**
 * # Версия файла
 *
 * Объект предназначен для работы с версиями файла. Он позволяет скачивать архивные версии файла,
 * получать ссылки на скачивание для архивных версий. Получить версии можно с помощью метода [[FileItem.getVersions]].
 */
interface FileVersionItem extends BaseItem<FileVersionData>, ItemRef<FileVersionItem> {
    /**
     * Метод [[FileVersionItem.setAsCurrent]] сохраняет версию, как текущую.
     *
     * Устанавливается актуальная версия файла на текущий объект версии. Возможно изменение версии файла
     * с копированием версии из текущего объекта, для этого необходимо установить флаг copy = true. Вызов метода
     * [[FileVersionItem.setAsCurrent]] возможен без аргументов, тогда будет изменен порядок версий и
     * выбранная версия будет актуальной версией файла. При создании версии без копирования,
     * версия на которую указывает объект, будет установлена последней и актуальной для файла.
     *
     * В примере файл хранимый в рамках контекста, восстанавливается до исходной версии,
     * что позволяет отменить все внесенные изменения.
     *
     * ```typescript
     * // Извлечение файла из контекста, для работы с его версиями
     * const file = Context.data.file;
     * const firstVersions = await file.getVersions(0, 2);
     * if (firstVersions.length < 2) {
     *   throw new Error("У файла нет версий для восстановления");
     * }
     *
     * // устанавливаем первую версию актуальной, восстанавливая оригинальное содержимое
     * const updatedFile = await firstVersions[1].setAsCurrent(true);
     * ```
     *
     * @param copy Флаг включения копирования версии.
     * @param comment Комментарий для установки версии.
     */
    setAsCurrent(copy?: boolean, comment?: string): Promise<FileItem>;
    /**
     * Метод [[FileVersionItem.getDownloadUrl]] получает ссылку на загрузку содержимого версии файла.
     *
     * Полученная ссылка возвращает содержимое файла. По такой ссылке загрузку могут выполнить все пользователи,
     * в том числе и анонимные. Ссылка на загрузку доступна в течение одного часа.
     * Тип вложения может быть `attachment` или `inline`. Если параметр `dispositionType` не передан,
     * по умолчанию устанавливается значение `attachment`.
     *
     * ```typescript
     * const url = await version.getDownloadUrl();
     * ```
     *
     * @param dispositionType Тип вложения.
     */
    getDownloadUrl(dispositionType?: DispositionType): Promise<string>;
    /**
     * Метод [[FileVersionItem.delete]] удаляет версию файла
     *
     * В результате удаления, версия файла уменьшается на единицу. Все номера последующих версий за удаленной
     * уменьшаются на единицу, для сохранения порядка версий.
     *
     * ```typescript
     * // Извлечение файла из контекста, для работы с его версиями
     * const file = Context.data.file;
     * const fileVersions = file.getVersions(0, 1);
     * if (fileVersions.length === 0) {
     *   throw new Error("У файла нет версий");
     * }
     * // удаляем последнюю версию файла
     * await fileVersions[0].delete();
     * ```
     */
    delete(): Promise<void>;
}
/**
 * # Ссылка на файл
 *
 * Содержит не полный набор данных файла, но позволяет использовать некоторый набор методов файла.
 */
interface FileItemRef extends ItemRef<FileItem> {
    /**
     * Метод [[FileItem.getDownloadUrl]] получает ссылку на загрузку содержимого файла.
     *
     * Полученная ссылка возвращает содержимое файла. По такой ссылке загрузку могут выполнить все пользователи,
     * в том числе и анонимные. Ссылка на загрузку доступна 1 час.
     * Тип вложения может быть `attachment` или `inline`. Параметр `dispositionType`, по умолчанию
     * имеет значение `attachment`.
     *
     * ```typescript
     * const url = await file.getDownloadUrl();
     * ```
     *
     * @param dispositionType указывает на тип вложения, необязательный параметр
     */
    getDownloadUrl(dispositionType?: DispositionType): Promise<string>;
    /**
     * Метод [[FileItem.setPermissions]] устанавливает список прав на файл.
     *
     * Метод требуется использовать, когда необходимо изменить права на доступ к файлу,
     * добавив или удалив права доступа для пользователя, группы, элемента оргструктуры.
     * Для добавления новых прав доступа необходимо использовать объект [[TPermissionValue]],
     * а для выдачи прав на конкретные операции — [[PermissionType]].
     * После создания нового объекта [[TPermissions]] используется метод [[FileItem.setPermissions]]
     * для сохранения новых прав доступа.
     *
     *```typescript
     *
     * const user = Context.data.__createdBy;
     *
     * const permissions = new Permissions([
     *  new PermissionValue(user, [PermissionType.DELETE, PermissionType.READ]),
     * ]);
     *
     * await file.setPermissions(perms);
     *```
     *
     * @param perms Новые правила доступа к файлу.
     */
    setPermissions(perms: TPermissions): Promise<void>;
    /**
     * Метод [[FileItem.getPermissions]] получает права доступа к файлу.
     *
     * После удачного выполнения запроса прав в ответе будет получен объект [[TPermissions]]. Полученный объект
     * можно модифицировать или анализировать для различных проверок доступа.
     *
     *```typescript
     * const perm = await file.getPermissions();
     *```
     */
    getPermissions(): Promise<TPermissions>;
    /**
     * Метод [[FileItem.hasPermission]] проверяет наличие права доступа [[PermissionType]].
     *
     * Метод позволяет легко проверить наличие возможности на выполнение операции [[PermissionType]] с файлом.
     * После использования метод вернет флаг о результате. Если значение флага `true`, то пользователь может выполнять
     * запрошенную операцию с файлом. Также можно проверять доступ для элементов оргструктуры.
     *
     * ```typescript
     * const user = Context.data.__createdBy;
     *
     * const canUpdate = await file.hasPermission(user, PermissionType.UPDATE);
     * ```
     *
     * @param group Группа или пользователь для проверки.
     * @param type Тип операции.
     */
    hasPermission(group: TPermissionOrgunit, type: PermissionType): Promise<boolean>;
    /**
     * Метод [[FileItem.getFileMD5Hash]] получает md5-хеш файла.
     *
     * В примере контекст содержит `file` — файл из системы.
     *
     *```typescript
     * const hash = await file.getFileMD5Hash();
     *```
     */
    getFileMD5Hash(): Promise<string>;
}
/**
 * # Изображение
 */
interface ImageItem extends BaseItem<ImageData>, ItemRef<ImageItem> {
    /**
     * @ignore
     */
    readonly kind: 'image';
    /**
     * Метод [[FileItem.getDownloadUrl]] получает ссылку на загрузку содержимого файла.
     *
     * Полученная ссылка возвращает содержимое файла. По такой ссылке загрузку могут выполнить все пользователи,
     * в том числе и анонимные. Ссылка на загрузку доступна 1 час.
     * Тип вложения может быть `attachment` или `inline`. Параметр `dispositionType`, по умолчанию
     * получает значение `attachment`.
     *
     * ```typescript
     * const url = await file.getDownloadUrl();
     * ```
     */
    getDownloadUrl(dispositionType?: DispositionType): Promise<string>;
    /**
     * Метод [[FileItem.setPermissions]] устанавливает список прав на файл.
     *
     * Метод требуется использовать, когда необходимо изменить права на доступ к файлу,
     * добавив или удалив права доступа для пользователя, группы, элемента оргструктуры.
     * Для добавления новых прав доступа необходимо использовать объект [[TPermissionValue]],
     * а для выдачи прав на конкретные операции — [[PermissionType]].
     * После создания нового объекта [[TPermissions]] для сохранения новых прав доступа
     * используется метод [[FileItem.setPermissions]].
     *
     *```typescript
     *
     * const user = Context.data.__createdBy;
     *
     * const permissions = new Permissions([
     *  new PermissionValue(user, [PermissionType.DELETE, PermissionType.READ]),
     * ]);
     *
     * await file.setPermissions(perms);
     *```
     *
     * @param perms Новые правила доступа к файлу.
     */
    setPermissions(perms: TPermissions): Promise<void>;
    /**
     * Метод [[FileItem.getPermissions]] получает права доступа к файлу.
     *
     * После удачного выполнения запроса прав в ответе будет получен объект [[TPermissions]]. Полученный объект
     * можно модифицировать или анализировать для различных проверок доступа.
     *
     *```typescript
     * const perm = await file.getPermissions();
     *```
     */
    getPermissions(): Promise<TPermissions>;
    /**
     * Метод [[FileItem.hasPermission]] проверяет наличие права доступа [[PermissionType]].
     *
     * Метод позволяет легко проверить наличие возможности на выполнение операции [[PermissionType]] с файлом.
     * После использования метод вернет флаг о результате. Если значение флага `true`, пользователь может выполнять
     * запрошенную операцию с файлом. Также можно проверять доступ для элементов оргструктуры.
     *
     * ```typescript
     * const user = Context.data.__createdBy;
     *
     * const canUpdate = await file.hasPermission(user, PermissionType.UPDATE);
     * ```
     *
     * @param group Группа или пользователь для проверки.
     * @param type Тип операции.
     */
    hasPermission(group: TPermissionOrgunit, type: PermissionType): Promise<boolean>;
}
/**
 * # Ссылка на изображение
 */
interface ImageItemRef extends ItemRef<ImageItem> {
    /**
     * Метод [[FileItem.getDownloadUrl]] получает ссылку на загрузку содержимого файла.
     *
     * Полученная ссылка возвращает содержимое файла. По такой ссылке загрузку могут выполнить все пользователи,
     * в том числе и анонимные. Ссылка на загрузку доступна 1 час.
     * Тип вложения может быть `attachment` или `inline`. Параметр `dispositionType`, по умолчанию
     * получает значение `attachment`.
     *
     * ```typescript
     * const url = await file.getDownloadUrl();
     * ```
     */
    getDownloadUrl(dispositionType?: DispositionType): Promise<string>;
    /**
     * Метод [[FileItem.setPermissions]] устанавливает список прав на файл.
     *
     * Метод требуется использовать, когда необходимо изменить права на доступ к файлу,
     * добавив или удалив права доступа для пользователя, группы, элемента оргструктуры.
     * Для добавления новых прав доступа необходимо использовать объект [[TPermissionValue]],
     * а для выдачи прав на конкретные операции — [[PermissionType]].
     * После создания нового объекта [[TPermissions]] для сохранения новых прав доступа
     * используется метод [[FileItem.setPermissions]].
     *
     *```typescript
     *
     * const user = Context.data.__createdBy;
     *
     * const permissions = new Permissions([
     *  new PermissionValue(user, [PermissionType.DELETE, PermissionType.READ]),
     * ]);
     *
     * await file.setPermissions(perms);
     *```
     *
     * @param perms: TPermissions Новые правила доступа к файлу.
     */
    setPermissions(perms: TPermissions): Promise<void>;
    /**
     * Метод [[FileItem.getPermissions]] получает права доступа к файлу.
     *
     * После удачного выполнения запроса прав в ответе будет получен объект [[TPermissions]]. Полученный объект
     * можно модифицировать или анализировать для различных проверок доступа.
     *
     *```typescript
     * const perm = await file.getPermissions();
     *```
     */
    getPermissions(): Promise<TPermissions>;
    /**
     * Метод [[FileItem.hasPermission]] проверяет наличие права доступа [[PermissionType]].
     *
     * Метод позволяет легко проверить наличие возможности на выполнение операции [[PermissionType]] с файлом.
     * После использования метод вернет флаг о результате. Если значение флага `true`, то пользователь может выполнять
     * запрошенную операцию с файлом. Также можно проверять доступ для элементов оргструктуры.
     *
     * ```typescript
     * const user = Context.data.__createdBy;
     *
     * const canUpdate = await file.hasPermission(user, PermissionType.UPDATE);
     * ```
     *
     * @param group Группа или пользователь для проверки.
     * @param type Тип операции.
     */
    hasPermission(group: TPermissionOrgunit, type: PermissionType): Promise<boolean>;
}
/**
 * # Директория с файлами
 *
 * Объект предназначен для работы с файловыми директориями. Он позволяет выполнять операции над
 * директориями, хранимыми на диске: получить директории внутри директории, родительские и все дочерние директории,
 * создать новую директорию, удалить существующую, а также получить файлы, находящиеся в директории.
 */
interface DirectoryItem extends BaseItem<DirectoryData>, ItemRef<DirectoryItem> {
    /**
     * @ignore
     */
    readonly kind: 'directory';
    /**
     * Метод получает родителей директории отсортированых по порядку вложенности.
     *
     * ```typescript
     *    // Пример формирования пути до директории на основе полученных данных о родительских директориях
     *    const parents = await someDirectory.getParents();
     *
     *    let pathDir string = "/";
     *
     *    parents.forEach(dir => {
     *      pathDir = pathDir + dir.data.__name + "/"
     *    });
     * ```
     * @returns Массив объектов родительских директорий.
     */
    getParents(): Promise<DirectoryItem[]>;
    /**
     * Метод получает все дочерние директории.
     *
     * ```typescript
     *    //Пример получения всех файлов дочерних директорий
     *    const children = await someDirectory.getChildrens();
     *
     *    let allFilesInAllDirs :FileItem[];
     *
     *    parents.forEach(dir => {
     *      let files = dir.getFiles();
     *          files.forEach(file =>{
     *              allFilesInAllDirs.push(file);
     *          })
     *    });
     * ```
     * @returns Массив объектов дочерних директорий.
     * @deprecated Метод устаревший, избегайте его использования.
     */
    getChildrens(): Promise<DirectoryItem[]>;
    /**
     * Метод получает все дочерние директории.
     *
     * ```typescript
     *    //Пример получения всех файлов дочерних директорий
     *    const children = await someDirectory.getChildren();
     *
     *    let allFilesInAllDirs :FileItem[];
     *
     *    parents.forEach(dir => {
     *      let files = dir.getFiles();
     *          files.forEach(file =>{
     *              allFilesInAllDirs.push(file);
     *          })
     *    });
     * ```
     * @returns Массив объектов дочерних директорий.
     */
    getChildren(): Promise<DirectoryItem[]>;
    /**
     * Метод получает файлы из директории.
     *
     * ```typescript
     *    // Пример получения ссылкок на файлы в директории
     *    const filesInDir = await someDirectory.getFiles();
     *    filesInDir.forEach(file => file.getDownloadUrl());
     * ```
     * @returns Массив объектов файлов из директории.
     */
    getFiles(): Promise<FileItem[]>;
    /**
     * Метод создает новую директорию в текущей директории.
     *
     * ```typescript
     *    //Пример создания новой директории в папке пользователя. Получаем пользователя, получаем его директорию
     *    //и в ней создаем новую директорию
     *     let name = "Имя новой директории";
     *
     *     const user = await System.users.getCurrentUser()
     *
     *     const searchDir = await System.directories.search().
     *         where(di =>di.__id.eq(user.data.__id)).
     *         first();
     *     const newDir = await searchDir.createChildren(name);
     * ```
     * @param name Имя новой директории.
     * @returns Объект Директория.
     */
    createChildren(name: string): Promise<DirectoryItem>;
    /**
     * Метод удаляет текущую директорию.
     *
     *
     * ```typescript
     *     //Пример удаления всех директорий, созданных пользователем (some user_id)
     *     const searchDirs = await System.directories.search().
     *          where(di => di.__createdBy.eq('<some id>')).
     *          all();
     *
     *    for (let i = 0; i < searchDirs.length; i += 1) {
     *      await searchDirs[i].delete();
     *    }
     * ```
     *  @returns Статус ответа.
     */
    delete(): Promise<number>;
    /**
     * Метод получает папки в директории первого уровня вложенности.
     *
     *
     * ```typescript
     *    // Пример получения всех файлов в дочерних директориях
     *    const dirsInDir = await someDirectory.getDirs();
     *    let allFilesInAllDirs :FileItem[];
     *
     *    dirsInDir.forEach(dir => {
     *      let files = dir.getFiles();
     *          files.forEach(file =>{
     *              allFilesInAllDirs.push(file);
     *          })
     *    });
     * ```
     * @returns Массив объектов директорий.
     */
    getDirs(): Promise<DirectoryItem[]>;
}
/**
 * # Объект Замещение
 *
 * Для создания замещения используется метод `System.replacements.create`.
 * После заполнения информации о замещении необходимо сохранить информацию, вызвав метод [[ReplacementItem.save]].
 *
 * ```typescript
 * // Создадим замещение для сотрудника в отпуске
 * const rpl = System.replacements.create();
 *
 * rpl.data.type = rpl.fields.type.variants.reassign;
 * rpl.data.absent = Context.data.__createdBy;
 * rpl.data.replacement = Context.data.substitution;
 * rpl.data.begin = Context.data.vacation_start;
 * rpl.data.end = Context.data.vacation_end;
 *
 * await rpl.save();
 *```
 */
interface ReplacementItem extends BaseItem<ReplacementData>, ItemRef<ReplacementItem> {
    /**
     * Сохранение замещения.
     */
    save(): Promise<void>;
    /**
     * Метод [[ReplacementItem.interrupt]] позволяет прервать замещение пользователя.
     *
     * ```typescript
     * const rpl = await System.replacements.search().where(f => f.absent.eq(Context.data.user!)).first();
     * if(rpl != undefined) {
     *  await rpl.interrupt();
     * }
     * ```
     */
    interrupt(): Promise<void>;
}
/**
 * # Данные замещения
 */
interface ReplacementData extends ItemData {
    /**
     * Тип замещения.
     *
     * Для присвоения используются значения из объекта `fields.type.variants`.
     * Возможные значения:
     * * `information` — информирование;
     * * `reassign` — переназначение задач;
     * * `full` — полная передача прав.
     *
     * ```typescript
     * const rep = System.replacements.create();
     * rep.data.type = rep.fields.type.variants.information;
     * ```
     */
    type: TEnum<ReplacementTypeEnumBase>;
    /**
     * Замещающий пользователь.
     */
    replacement: TUser;
    /**
     * Замещаемый пользователь.
     */
    absent: TUser;
    /**
     * Время начала замещения.
     */
    begin: TDatetime;
    /**
     * Время окончания замещения.
     */
    end: TDatetime;
    /**
     * Переназначить активные задачи.
     */
    reassignTasksOnStart: TBoolean;
    /**
     * Переназначить задачи по завершении замещения.
     */
    reassignTasksOnEnd: TBoolean;
    /**
     * Флаг прерванного замещения.
     *
     * В случае прерывания свойство имеет значение `true`.
     */
    readonly isInterrupted: TBoolean;
}
/**
 * # Директория, хранимая на диске
 *
 * Содержит в себе данные о себе и родительской директории.
 */
interface DirectoryData extends Based<ItemData> {
    /**
     * Родительская директория.
     */
    directory: TCategory<DirectoryData>;
    /**
     * Идентификатор родительской директории.
     */
    parentId: TString;
}
/**
 * # Поля файла
 *
 * Содержит в себе информацию о файле, а также о папке, в которой находится файл.
 */
interface FileData extends Based<ItemData> {
    /**
     * Родительская папка.
     */
    directory: TCategory<DirectoryData>;
    /**
     * Размер файла в байтах.
     */
    size: number;
    /**
     * Идентификатор родительской директории.
     */
    parentId: TString;
}
/**
 * # Поля версий файла
 *
 * Содержит в себе информацию о версии файла.
 */
interface FileVersionData extends Based<ItemData> {
    /**
     * Версия файла.
     */
    readonly version: number;
    /**
     * Комментарий к версии файла.
     */
    readonly comment: TString;
    /**
     * Имя версии файла.
     */
    readonly filename: TString;
    /**
     * ID файла.
     */
    readonly fileId: TString;
}
/**
 * # Поля изображения
 *
 * Отдельный тип для изображений, хранимых на диске компании.
 */
interface ImageData extends FileData {
}
/**
 * # Объект хранения дополнительных параметров
 */
interface ParamsItem<T extends ItemData> {
    /**
     * Значения параметров.
     */
    readonly data: Readonly<T>;
    /**
     * Описание параметров.
     */
    readonly fields: Readonly<{
        [K in keyof T]: FieldType<T[K]>;
    }>;
}
/**
 * @ignore
 */
interface ProcessContext extends ItemData {
}
/**
 * # Выход из блока процесса
 *
 * Указывается наименование следующего блока и идентификатор перехода.
 *
 * Выполнение задачи:
 * ```typescript
 * try {
 *  // Получаем выходы по задаче
 *  const exits = await task.getExits();
 *
 *   // Завершаем задачу
 *   // Передаем идентификатор выхода и данные формы
 *   await task.submitTask(exits[0].id, {comment: 'Task completed'});
 * } catch (e) {
 *  // Процесс уже завершен, можно обработать исключение
 * }
 *
 * ```
 */
interface TaskItemExit {
    /**
     * Имя выхода.
     */
    name: string;
    /**
     * Идентификатор выхода.
     */
    id: string;
}
/**
 * # Поля шаблона процесса
 */
interface ProcessTemplate<Context extends ProcessContext = ProcessContext> extends ItemData {
    /**
     * Раздел шаблона процесса.
     */
    namespace: TString;
    /**
     * Код шаблона процесса.
     */
    code: TString;
    /**
     * Название процесса.
     */
    __name: TString;
    /**
     * Описание контекста процесса.
     */
    readonly context: Context;
}
/**
 * # Статусы (состояния) экземпляра процесса
 */
declare enum ProcessInstanceState {
    /**
     * # Процесс исполняется
     */
    exec = "exec",
    /**
     * # Процесс ожидает некоторое событие, которое должно произойти вне процесса
     */
    wait = "wait",
    /**
     * # Процесс завершён
     */
    done = "done",
    /**
     * # Во время исполнения процесса произошла ошибка
     */
    error = "error",
    /**
     * # Процесс прерван
     */
    cancel = "cancel"
}
/**
 * # Поля объекта экземпляра процесса
 */
interface ProcessInstanceData extends Based<ItemData> {
    /**
     * Идентификатор шаблона процесса.
     */
    __templateId: TString;
    /**
     * Статус экземпляра процесса.
     */
    __state: ProcessInstanceState;
    /**
     * Идентификатор родительского экземпляра процесса.
     */
    __parentId?: TString;
}
/**
 * # Экземпляр действующего таймера процесса
 */
interface ProcessTimer {
    /**
     * Идентификатор таймера.
     */
    readonly id: TString;
    /**
     * Идентификатор блока, к которому принадлежит таймер.
     */
    readonly ownerId: TString;
    /**
     * Метод прерывает действующий таймер процесса.
     *
     * Действующий таймер можно досрочно прервать.
     * В этом случае исполнение процесса перейдёт к следующему блоку на диаграмме после таймера.
     * Однако если к моменту вызова метода таймер уже оказался завершен, то выполнение сценария прерывается исключением.
     *
     * В примере отображено прерывание таймера, принадлежащего элементу диаграммы с идентификатором `diagram-item-uuid`.
     * Идентификатор блока можно скопировать, открыв настройки блока Таймер.
     * Это обычный UUID, записанный в виде строки.
     *
     * ```typescript
     *     // `instance` — переменная, содержащая данные запущенного экземпляра процесса
     *     const timer = await instance.getTimer('diagram-item-uuid');
     *     if (timer) {
     *         try {
     *             await timer.interrupt();
     *         } catch (e) {
     *             // Таймер уже завершен, можно обработать исключение
     *         }
     *     }
     * ```
     */
    interrupt(): Promise<void>;
}
/**
 * # Объект экземпляра процесса
 */
interface ProcessInstanceItem<Context extends ProcessContext = ProcessContext> extends BaseItem<ProcessInstanceData>, ItemRef<ProcessInstanceItem<Context>>, ProcessInstanceItemRef<Context> {
    /**
     * @ignore
     */
    readonly kind: 'process_instance';
    /**
     * Метод получает шаблон процесса.
     *
     * Метод позволяет получить шаблон, на основе которого создан экземпляр процесса.
     * Шаблон содержит поля контекста. Данные поля и их типы необходимо учитывать при запуске процесса
     * и при работе с полями текущего экземпляра.
     *
     * Например, поля, ссылающиеся на приложение, могут содержать в себе `Namespace` и `code` приложения, на которое ссылаются.
     *
     * В примере указан процесс, который содержит в поле `application` ссылку на приложение `dogovor` в разделе `documents`.
     * Зная данную информацию, возможно получить доступ к приложениям через `Namespace`.
     *
     *
     * ```typescript
     *      // `instance` — переменная, содержащая данные запущенного экземпляра процесса
     *     const template = await instance.getTemplate();
     *
     *     // Извлекаем из шаблона поле, привязанное к приложению
     *     const applicationField = template.context['application'];
     *     if (!applicationField) {
     *         throw new Error('Поле приложения не найдено');
     *     }
     *
     *     // После извлечения приложения возможно выполнять поиск, создание и другие операции
     *     const app = Namespace.app[applicationField.data.code];
     * ```
     *
     * @returns Шаблон процесса.
     */
    getTemplate(): Promise<ProcessTemplate<Context>>;
    /**
     * Метод получает родительский экземпляр процесса.
     *
     * В компании в рамках процесса могут быть запущены подпроцессы. При работе с подпроцессом можно получить
     * родительский процесс, в рамках которого был запущен данный процесс.
     *
     * ```typescript
     *  const parentProcess = await instance.getParent();
     * ```
     *
     * @returns Родительский процесс, если он существует.
     */
    getParent(): Promise<ProcessInstanceItem<Context> | undefined>;
    /**
     * Метод получает действующий таймер процесса.
     *
     * Метод вернёт экземпляр действующего таймера по идентификатору блока, к которому принадлежит таймер.
     * Идентификатор блока можно скопировать на форме настроек блока Таймер.
     * Это обычный UUID, записанный в виде строки.
     * Если процесс на диаграмме ещё не дошёл до таймера или уже прошёл его, то метод вернёт `undefined`.
     *
     * ```typescript
     *    // `instance` — переменная, содержащая данные запущенного экземпляра процесса
     *    const timer = await instance.getTimer('идентификатор блока');
     *    if (timer) {
     *        // Активный таймер найден — можно действовать
     *    }
     * ```
     *
     * @param timerOwnerId Идентификатор блока, к которому принадлежит таймер.
     * @returns Действующий таймер, если он запущен.
     */
    getTimer(timerOwnerId: string): Promise<ProcessTimer | undefined>;
    /**
     * Метод получает все действующие таймеры процесса.
     *
     * Метод возвращает массив экземпляров действующих таймеров.
     * Если при вызове метода в экземпляре процесса не окажется действующих таймеров, то вернётся пустой массив.
     *
     * ```typescript
     *    // `instance` — переменная, содержащая данные запущенного экземпляра процесса
     *    const timers = await instance.getTimers();
     * ```
     *
     * @returns Действующие таймеры.
     */
    getTimers(): Promise<ProcessTimer[]>;
    /**
     * Метод позволяет изменить ответственного за экземпляр процесса.
     *
     * В примере выполняется изменение ответственного с использованием данных из контекста:
     *
     * * `user` — поле типа Пользователь;
     *
     * * `comment` — строка, записанная в контекст.
     *
     * ```typescript
     * const user = Context.data.newResponsible;
     * const comment = Context.data.comment;
     *
     * await processInstance.setResponsible(user, comment);
     * ```
     *
     * @param responsible Ссылка на пользователя.
     * @param comment Причина изменения ответственного.
     */
    setResponsible(responsible: UserItemRef, comment?: string): Promise<void>;
    /**
     * Метод позволяет прервать экземпляр процесса.
     *
     * Если экземпляр процесса завершен или в текущий момент исполняет активный блок, то метод прерывается исключением.
     *
     * В примере отображено прерывание процесса в том случае, если в поле `someError` в контексте содержится ошибка.
     *
     * ```typescript
     *  if (Context.data.someError !== '') {
     *      try {
     *          await process.interrupt(Context.data.someError)
 *          } catch (e) {
     *          // Процесс уже завершен, можно обработать исключение
 *          }
     *  }
     * ```
     * @param comment Причина прерывания экземпляра процесса.
     */
    interrupt(comment: string): Promise<void>;
    /**
     * Изменяет контекст экземпляра процесса.
     *
     * Если экземпляр процесса завершен или в текущий момент исполняет активный блок, то метод прерывается исключением.
     * В случае успешного выполнения изменяется контекст процесса и метод отрабатывает без исключений.
     *
     * В примере контекст содержит номер договора, полученный из внешнего источника, например, с помощью запроса.
     * Метод позволяет установить полученный номер в контекст стороннего процесса.
     *
     * ```typescript
     * async function updateContext(): Promise<void> {
     *     try {
     *      // Получаем номер контракта из контекста
     *      const contractNumber = Context.data.contructid
     *
     *      // Запись процесса `newprocess` в переменную `processTemplate`
     *      const processTemplate = Global.processes.incomecontract;
     *      // Идентификатор экземпляра процесса берем из контекста процесса
     *      const instanceUUID = Context.data.instanceUUID;
     *
     *      // Ищем экземпляр процесса
     *      const proccess = await processTemplate._searchInstances().where(x => x.__id.eq(instanceUUID)).first();
     *
     *      // Комментарий для обновления получаем из контекста процесса
     *      const comment = Context.data.comment;
     *
     *      // Новое значение номера договора
     *      const context = {contract: contractNumber};
     *
     *      // Обновление контекста
     *      await process.updateContext(context, comment);
     *     } catch (e) {
     *      // Процесс уже завершен, можно обработать исключение
     *     }
     * }
     * ```
     *
     * @param context Новый контекст экземпляра процесса.
     * @param comment Причина изменения контекста экземпляра процесса.
     * Обязательный параметр. Не допускается передавать пустую строку.
     */
    updateContext(context: Context, comment: string): Promise<void>;
}
/**
 * # Ссылка на объект экземпляра процесса
 */
interface ProcessInstanceItemRef<Context extends ProcessContext = ProcessContext> extends ItemRef<ProcessInstanceItem<Context>> {
}
/**
 * # Статусы задачи процесса
 */
declare enum ProcessTaskState {
    /**
     * # Задача имеет несколько исполнителей и находится на распределении, мехнизм «Кто первый»
     */
    assignment = "assignment",
    /**
     * # Задача находится в работе
     */
    inProgress = "in_progress",
    /**
     * # Задача закрыта
     */
    closed = "closed",
    /**
     * # Задача отменена
     */
    cancel = "cancel"
}
/**
 * # Поля объекта задачи
 */
interface ProcessTaskData extends Based<ItemData> {
    /**
     * Дата, до которой необходимо выполнить задачу.
     */
    dueDate?: TDatetime;
    /**
     * Планируемая дата начала в календаре.
     */
    planStart?: TDatetime;
    /**
     * Планируемая дата окончания в календаре.
     */
    planEnd?: TDatetime;
    /**
     * Статус задачи.
     */
    state: ProcessTaskState;
    /**
     * Namespace и code шаблона процесса.
     */
    templateNsAndCode: string;
    /**
     * Ссылка на экзмемпляр процесса.
     */
    readonly instance: InstanceAddr;
    /**
     * Исполнители.
     */
    readonly performers: UserItemRef[];
}
/**
 * # Ссылка на экзмемпляр процесса
 */
interface InstanceAddr {
    /**
     * Идентификатор экземпляра.
     */
    __id: TString;
    /**
     * Раздел экземпляра.
     */
    namespace: TString;
    /**
     * Код экземпляра.
     */
    code: TString;
}
/**
 * # Ссылка на объект задачи процесса
 */
interface ProcessTaskItemRef<Context extends ProcessContext = ProcessContext> extends ItemRef<ProcessTaskItem<Context>> {
}
/**
 * # Объект задачи процесса
 */
interface ProcessTaskItem<Context extends ProcessContext = ProcessContext> extends BaseItem<ProcessTaskData>, ItemRef<ProcessTaskItem<Context>>, ProcessTaskItemRef<Context> {
    /**
     * @ignore
     */
    readonly kind: 'process_task';
    /**
     * Метод получает объект процесса.
     *
     * ```typescript
     * const instance = await task.getProcessInstance();
     * ```
     *
     * @returns Процесс, в рамках которого запущена задача.
     */
    getProcessInstance(): Promise<ProcessInstanceItem<Context>>;
    /**
     * Метод получает список исполнителей задачи.
     *
     * ```typescript
     * const instance = await task.getPerformers();
     * ```
     *
     * @returns Пользователи, выполняющие задачу.
     */
    getPerformers(): Promise<UserItem[]>;
    /**
     * Переназначение задачи на одного или нескольких новых исполнителей.
     *
     * Причина переназначения записывается в ленту задачи.
     * Задачи ознакомления/cогласования и системные будут переназначены на первого пользователя, указанного в наборе новых исполнителей.
     * Если экземпляр процесса завершен, или задача уже закрыта, то исполнение прерывается исключением.
     *
     * В первом примере происходит переназначение задачи по ID из контекста на нового исполнителя в единственном числе.
     *
     * ```typescript
     * async function reassign(): Promise<void> {
     *     // Идентификатор задачи для переназначения берем из контекста процесса
     *     const taskID = Context.data.TaskForReassignUUID;
     *
     *     // Ищем задачу
     *     const task = await Application.processes._searchTasks().where(x => x.__id.eq(taskID)).first();
     *     // Пользователя получаем из контекста
     *     const user = Context.data.NewPerformer;
     *
     *     const comment = "Замена исполнителя";
     *     await task.reassign(user, comment);
     * }
     * ```
     * Рассмотрим ещё один пример.
     *
     * В этом примере происходит переназначение задачи по ID из контекста на пользователей из группы.
     *
     * ```typescript
     * async function reassignMany(): Promise<void> {
     *     // Идентификатор задачи для переназначения берем из контекста процесса
     *     const taskID = Context.data.TaskForReassignUUID;
     *
     *     // Ищем задачу
     *     const task = await Application.processes._searchTasks().where(x => x.__id.eq(taskID)).first();
     *     // Идентификатор группы пользователя получаем из контекста
     *     const userGroupID = Context.data.groupUUID;
     *     // Ищем группу пользователей
     *     const userGroup = await System.userGroups.search().where(x => x.__id.eq(userGroupID)).first();
     *     const newPerformers = <UserItemRef[]>await userGroup.users();
     *
     *     const comment = "Задаем на нескольких исполнителей";
     *     await task.reassign(newPerformers, comment);
     * }
     * ```
     * @param user Ссылка на одного пользователя или набор ссылок на пользователей.
     * @param comment Причина переназначения задачи. Может быть указана пустая строка.
     */
    reassign(user: UserItemRef | UserItemRef[], comment: string): Promise<void>;
    /**
     * Изменение времени выполнения задачи.
     *
     * Установка новой даты выполнения задачи:
     * ```typescript
     * try {
     *   // Получаем комментарий из контекста процесса
     *   const comment = Context.data.comment;
     *
     *   // Получаем ID задачи из контекста процесса
     *   const taskUUID = Context.data.taskid;
     *
     *   let task = await System.processes._searchTasks().where(x => x.__id.eq(taskUUID)).first();
     *   // если задача не найдена, то выводим ошибку
     *   if (!task) {
     *     throw new Error('Задача не найдена');
     *   }
     *   // Получаем текущую дату
     *   let newDueDate = new Datetime();
     *
     *   // Прибавляем один день
     *   newDueDate = newDueDate.addDate(0, 0, 1);
     *
     *   await task.changeDueDate(newDueDate, comment);
     * } catch (error) {
     *   // Процесс уже завершен, можно обработать исключение
     * }
     * ```
     *
     * @param dueDate Новая дата завершения задачи.
     * @param comment Комментарий.
     */
    changeDueDate(dueDate: TDatetime, comment?: string): Promise<void>;
    /**
     * Получение вариантов выхода по задаче.
     *
     * Поиск и завершение задачи:
     * ```typescript
     * try {
     *   // Получаем объект задачи
     *   let task = await System.processes._searchTasks().where(x => x.__id.eq(taskUUID)).first();
     *   // Если объект задачи не найден, то заканчиваем выполнение сценария
     *   if (!task) {
     *   return;
     *   }
     *   // Получаем выходы для задачи
     *   const exits = await task.getExits();
     *
     *   // Завершаем задачу
     *   // Передаем идентификатор выхода и данные формы
     *   await task.submitTask(exits[0].id, {comment: 'Task completed'});
     * } catch (e) {
     *   // Процесс уже завершен, можно обработать исключение
     * }
     *
     * ```
     */
    getExits(): Promise<TaskItemExit[]>;
    /**
     * Выполнение задачи.
     *
     * Поиск и завершение задачи:
     * ```typescript
     * try {
     *   // Получаем объект задачи
     *   let task = await System.processes._searchTasks().where(x => x.__id.eq(taskUUID)).first();
     *
     *   // Получаем выходы для задачи
     *   const exits = await task.getExits();
     *
     *   // Передаем идентификатор выхода и данные формы
     *   await task.submitTask(exits[0].id, {comment: 'Task completed'});
     * } catch (e) {
     *   // Процесс уже завершен, можно обработать исключение
     * }
     *
     * ```
     */
    submitTask(exitID: string, data?: Context): Promise<void>;
}
/**
 * # Настройки рабочего календаря
 *
 * Рабочий календарь определяет продолжительность рабочего дня и выходные дни.
 * Получить настройки рабочего календаря можно с помощью метода
 * [[ProductionSchedule.getGeneralSettings]].
 */
interface ProductionScheduleGeneralSettings {
    /**
     * Расписание рабочего дня.
     */
    daySchedule: {
        /**
         * Интервал рабочего времени.
         */
        workingTime: TimeFromAndTo;
        /**
         * Интервал обеда.
         */
        lunchTime: TimeFromAndTo;
    };
    /**
     * Выходные дни.
     *
     * Каждому дню недели сопоставляется признак выходного дня.
     */
    weekends: {
        monday: boolean;
        tuesday: boolean;
        wednesday: boolean;
        thursday: boolean;
        friday: boolean;
        saturday: boolean;
        sunday: boolean;
    };
}
/**
 * # Интервал в течении рабочего дня
 *
 * Этот интервал используется для описания сущностей рабочего календаря, например, интервала рабочего времени.
 */
interface TimeFromAndTo {
    /**
     * Время начала.
     *
     * Количество секунд от полуночи.
     */
    from: number;
    /**
     * Время окончания.
     *
     * Количество секунд от полуночи.
     */
    to: number;
}
/**
 * # Исключение в рабочем календаре
 *
 * Исключение может быть дополнительным выходным или сокращенным
 * рабочим днем. Список исключений определяется на уровне компании в разделе
 * Администрирование / Рабочий календарь.
 *
 * Для получения списка исключений можно воспользоваться методом
 * [[ProductionSchedule.getSpecialDays]].
 */
interface ProductionScheduleSpecialDay extends TimeFromAndTo {
    /**
     * Дата исключения.
     */
    date: TDate;
    /**
     * Является ли исключение выходным днем.
     */
    holiday: boolean;
}
/**
 * # Объект регистрации элемента приложения
 */
interface ApplicationItemRegistration {
    /**
     * Идентификатор объекта.
     */
    readonly id: string;
    /**
     * Полное название с учетом всех директорий, в которых лежит дело, в котором была совершена регистрация.
     */
    readonly nomenclatureId: string;
    /**
     * Название, под которым зарегистрировали данный элемент.
     */
    readonly __name: string;
    /**
     * Дата и время создания.
     */
    readonly __createdAt: TDatetime;
    /**
     * Автор объекта.
     */
    readonly __createdBy: UserItemRef;
    /**
     * Дата и время изменения.
     */
    readonly __updatedAt: TDatetime;
    /**
     * Автор последнего изменения.
     */
    readonly __updatedBy: UserItemRef;
    /**
     * Дата и время удаления.
     */
    readonly __deletedAt?: TDatetime;
}
/**
 * # Поля истории изменений статусов элементов приложения
 */
interface StatusHistoryData<T extends ItemData, P extends ItemData> extends Based<ItemData> {
    /**
     * Ссылка на элемент приложения, статус которого был изменен.
     */
    readonly item: TApplication<T, P, Processes>;
    /**
     * Идентификатор исходного статуса.
     */
    readonly source: TFloat;
    /**
     * Идентификатор целевого статуса.
     */
    readonly target: TFloat;
}
/**
 * # Объект истории изменения статусов элементов приложения
 *
 * Содержит полные данные одной записи в истории смены статусов.
 */
interface StatusHistoryItem<T extends ItemData, P extends ItemData> extends BaseItem<StatusHistoryData<T, P>>, StatusHistoryItemRef<T, P> {
}
/**
 * # Объект-ссылка на запись истории изменения статусов
 */
interface StatusHistoryItemRef<T extends ItemData, P extends ItemData> extends ItemRef<StatusHistoryItem<T, P>> {
    /**
     * @ignore
     */
    readonly kind: 'statushistory';
}
/**
 * # Типы данных
 *
 * Подробное описание читайте в [статье про типы данных](../pages/quick-start/intro_types.html).
 * @packageDocumentation
 */
/**
 * # Строка
 *
 * Подробнее читайте
 * [на MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String).
 */
declare type TString = string;
/**
 * @ignore
 */
interface StringField {
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * # Число
 *
 * Подробнее читайте
 * [на MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number).
 */
declare type TFloat = number;
/**
 * @ignore
 */
interface FloatField {
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * # Булево значение
 *
 * Подробнее читайте
 * [на MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Boolean).
 */
declare type TBoolean = boolean;
/**
 * @ignore
 */
interface BooleanField {
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * # Длительность (время)
 *
 * Имеет конструктор:
 * ```typescript
 * const duration = new Duration(100, 'milliseconds');
 * ```
 *
 * Второй параметр конструктора — единица измерения. Он может иметь следующие значения:
 * * `milliseconds` — миллисекунды;
 * * `seconds` — секунды;
 * * `minutes` — минуты;
 * * `hours` — часы;
 * * `days` — дни.
 *
 * Можно не указывать единицу измерения.
 * По умолчанию длительность будет считаться в миллисекундах.
 * ```typescript
 * const duration = new Duration(100); // 100 миллисекунд
 * ```
 *
 * Значения этого типа неизменяемые, так что методы мутации возвращают
 * обновлённое значение, не меняя исходного.
 * ```typescript
 * const hour = new Duration(1, 'hour');
 * const day = hour.add(new Duration(23, 'hour'));
 * ```
 *
 * @module Types
 */
interface TDuration {
    /**
     * Миллисекунды.
     */
    readonly milliseconds: number;
    /**
     * Секунды.
     */
    readonly seconds: number;
    /**
     * Минуты.
     */
    readonly minutes: number;
    /**
     * Часы.
     */
    readonly hours: number;
    /**
     * Дни.
     */
    readonly days: number;
    /**
     * Сложить длительности.
     */
    add(duration: TDuration): TDuration;
}
/**
 * @ignore
 */
interface DurationConstructor {
    new (x: number, unit?: 'milliseconds' | 'seconds' | 'minutes' | 'hours' | 'days'): TDuration;
}
/**
 * @ignore
 */
declare const Duration: DurationConstructor;
/**
 * # Ответ сервера
 *
 * Позволяет формировать HTTP-ответ на запросы с сервера.
 *
 * Конструктор опционально принимает код в виде числа или значение [[HttpStatusCode]].
 * ```typescript
 * const resp1 = new HttpResponse(404);
 * const resp2 = new HttpResponse(HttpStatusCode.UNAUTHORIZED);
 * ```
 *
 * Методы можно выстраивать в цепочки.
 * Все методы меняют сам объект ответа и возвращают его же.
 * ```typescript
 * const resp = new HttpResponse();
 * resp
 *     .status(201)
 *     .content('awesome')
 *     .json({content: 'created'})
 *     .cookie('sessionId', 'uniqueSessId')
 *     .location('https://example.com/path')
 *     .redirect('/same_url', 301)
 *     .set('Content-Type', 'text/html');
 * return resp;
 * ```
 */
interface HttpResponse {
    /**
     * Установить код ответа.
     *
     * @param statusCode Код HTTP-ответа (см. также [[HttpStatusCode]]).
     */
    status(statusCode: HttpStatusCode | number): this;
    /**
     * Установить содержимое тела ответа строкой.
     *
     * @param data Строка с данными тела ответа.
     */
    content(data: string): this;
    /**
     * Установить тело ответа из объекта JSON.
     *
     * Обратите внимание, что при передаче ответа используется функция `JSON.stringify`,
     * и при наличии циклических ссылок формирование ответа будет падать с ошибкой.
     *
     * Также данный метод устанавливает заголовок ответа `Content-Type: application/json`.
     * Если необходимо, вы можете установить для него другое значение.
     * ```typescript
     * return new HttpResponse(HttpStatusCode.CREATED)
     *     .json({content: 'created'})
     *     .set('Content-Type', 'text/javascript'); //Old IE now happy
     * ```
     *
     * Вы можете передать в качестве `data` экземпляр объекта,
     * в котором реализована функция `json()`,
     * возвращающая объект состояния данного экземпляра.
     *
     * ```typescript
     * function MyClass() {};
     * MyClass.prototype.json = function() {
     *   return { id: 1, value: 'string' }
     * };
     *
     * const myData = new MyClass();
     * const resp = new HttpResponse().json(myData);
     * ```
     *
     * @param data Данные в формате JSON объекта, массива или экземпляра функции.
     */
    json(data: any): this;
    /**
     * Установить в тело ответа файл.
     *
     * Тело файла в методе скачивать не требуется.
     * Оно будет передано в тело HTTP-ответа самой платформой.
     *
     * ```typescript
     * async function downloadFile(req: FetchRequest): Promise<HttpResponse | void> {
     *     const file = await System.files.search()
     *         .where(f => f.__id.eq("b57ef952-2861-45e1-9dd0-fa5e042ab4ef")).first();
     *
     *     const resp = new HttpResponse();
     *     resp.setFile(file!);
     *
     *     return resp;
     * }
     * ```
     *
     * @param file Ссылка на элемент файла [[FileItem]].
     * @param name Имя файла, которое будет использовано для скачивания пользователем.
     */
    setFile(file: FileItem, name?: string): this;
    /**
     * Установить значение HTTP-заголовока.
     *
     * @param name Имя заголовка.
     * @param value Значение заголовка.
     */
    set(name: string, value: string): this;
    /**
     * Установить значение cookie.
     *
     * @param name Имя cookie.
     * @param value Значение cookie.
     * @param options Опции для передачи и хранения cookie.
     */
    cookie(name: string, value: string, options?: CookieOptions): this;
    /**
     * Установить заголовок `Location`.
     *
     * @param url Значение ссылки, установленное в `Location`.
     */
    location(url: string): this;
    /**
     * Сформировать перенаправление запроса. По умолчанию передается код 302.
     */
    redirect(url: string, status?: HttpStatusCode | number): this;
}
/**
 * @ignore
 */
interface HttpResponseConstructor {
    new (statusCode?: HttpStatusCode | number): HttpResponse;
}
/**
 * @ignore
 */
declare const HttpResponse: HttpResponseConstructor;
/**
 * @ignore
 */
declare type HttpResponseHeaders = Record<string, string>;
/**
 * # Опции установки cookie
 *
 * Используются в методе [[HttpResponse.cookie]].
 */
interface CookieOptions {
    /**
     * Максимальный возраст cookie.
     * */
    maxAge?: number;
    /**
     * Дата истечения cookie (срок хранения браузером значения cookie). Задается отдельно от `maxAge`.
     * */
    expires?: Date;
    /**
     * Cookie, отмеченные как `HttpOnly`, недоступны в клиентском JavaScript.
     * */
    httpOnly?: boolean;
    /**
     * Относительный путь, для которого установлена cookie.
     * */
    path?: string;
    /**
     * Домен, для которого установлена cookie.
     * */
    domain?: string;
    /**
     * Должна ли cookie устанавливаться только по защищенному соединению.
     * */
    secure?: boolean;
    /**
     * # Политика передачи cookie сторонним сайтам
     *
     * * `lax` — значение по умолчанию; означает, что в большинстве случаев cookie не будут передаваться сторонним
     * сайтам.
     * * `strict` — cookie никогда не отправятся, если пользователь пришёл не с этого же сайта.
     * * `none` — cookie будут передаваться во все возможные запросы.
    */
    sameSite?: boolean | 'lax' | 'strict' | 'none';
}
/**
 * # Результат валидации
 *
 * Позволяет формировать результат пользовательской валидации формы.
 *
 * Имеет конструктор. При вызове без параметров возвращает пустой объект результата валидации:
 * ```typescript
 * const result = new ValidationResult();
 * ```
 * В конструктор можно сразу передать массив сообщений об ошибках `messages` и списки ошибок полей контекста
 * `contextErrors`, `viewContextErrors`.
 *
 * ```typescript
 * const result = new ValidationResult(
 *     [`Должны быть проставлены все флажки на форме`],
 *     {
 *         stroka: ['Значение должно быть длиной не менее 10 символов'],
 *         stroka_2: ['Значение должно быть длиной не более 50 символов'],
 *     },
*      {
 *         number_1: ['Значение должно быть меньше или равно 50'],
 *     },
 * );
 * ```
 *
 * По каждому полю контекста и View-контекста может быть несколько ошибок валидации.
 * Если для поля контекста с данным кодом уже добавлена ошибка с таким текстом, то повторное добавление игнорируется.
 *
 * Пример использования в функции валидации:
 * ```typescript
 * const result = new ValidationResult();
 *
 * if (!Context.data.stroka || Context.data.stroka.length < 10) {
 *     result.addContextError('stroka', 'Значение должно быть длиной не менее 10 символов');
 * }
 *
 * if (!ViewContext.data.number_1 || ViewContext.data.number_1 > 50) {
 *     result.addViewContextError('number_1', 'Значение должно быть меньше или равно 50');
 * }
 *
 * return result;
 * ```
 *
 */
interface ValidationResult {
    /**
     * Массив сообщений об ошибках валидации.
     */
    messages: string[];
    /**
     * Объект, содержащий список ошибок валидации полей контекста.
     *
     * Ключом является код поля контекста, а значением — массив строк описаний ошибок.
     */
    contextErrors: {
        [key: string]: string[];
    };
    /**
     * Объект, содержащий список ошибок валидации полей View-контекста.
     *
     * Ключом является код поля View-контекста, а значением — массив строк описаний ошибок.
     */
    viewContextErrors: {
        [key: string]: string[];
    };
    /**
     * Заголовок блока с ошибками валидации, который можно установить, если необходимо переопределить стандартный.
     *
     * Например:
     *
     * ```typescript
     * result.title = 'Вам необходимо заполнить все поля формы для регистрации документа';
     * ```
     */
    title?: string;
    /**
     * Имеет значение `true`, если есть ошибки валидации.
     */
    readonly isValid: boolean;
    /**
     * Имеет значение `true`, если есть ошибки валидации полей контекста.
     */
    readonly hasContextErrors: boolean;
    /**
     * Имеет значение `true`, если есть ошибки валидации полей View-контекста.
     */
    readonly hasViewContextErrors: boolean;
    /**
     * Добавить сообщение об ошибке валидации без привязки к полям контекста.
     *
     * Например:
     *
     * ```typescript
     * result.addMessage('Должны быть проставлены все флажки на форме');
     * ```
     *
     * @param errorMessage Сообщение об ошибке.
     */
    addMessage(errorMessage: string): void;
    /**
     * Добавить ошибку валидации поля контекста.
     *
     * Например:
     *
     * ```typescript
     * result.addContextError('stroka', 'Значение должно быть длиной не менее 10 символов');
     * ```
     *
     * @param code Код поля контекста.
     * @param message Сообщение об ошибке валидации.
     */
    addContextError(code: string, message: string): void;
    /**
     * Добавить ошибку валидации поля View-контекста.
     *
     * Например:
     *
     * ```typescript
     * result.addViewContextError('stroka', 'Значение должно быть длиной не менее 10 символов');
     * ```
     *
     * @param code Код поля контекста.
     * @param message Сообщение об ошибке валидации.
     */
    addViewContextError(code: string, message: string): void;
    /**
     * Объеденить ошибки валидации текущего результата с ошибками из другого результата валидации.
     *
     * @param callResult
     */
    assign(callResult?: ValidationResult): void;
}
/**
 * @ignore
 */
interface ValidationResultConstructor {
    new (messages?: string[], contextErrors?: {
        [key: string]: string[];
    }, viewContextErrors?: {
        [key: string]: string[];
    }): ValidationResult;
}
/**
 * @ignore
 */
declare const ValidationResult: ValidationResultConstructor;
/**
 * # Дата и время
 *
 * Имеет конструкторы:
 * ```typescript
 * new Datetime(input?: Date): TDatetime;
 * new Datetime(value: string, format?: string): TDatetime;
 * ```
 *
 * Примеры создания объектов даты-времени:
 * ```typescript
 * const now = new Datetime();
 * const time1 = new Datetime('2022-02-24');
 * const time2 = new Datetime('24.02.2022', 'DD.MM.YYYY');
 * const time3 = new Datetime(Date.UTC(2022, 2, 24));
 * ```
 *
 * Если в конструкторе записывать дату как строку и не указывать формат,
 * то по умолчанию значение проверяется на соответствие формату `YYYY-MM-DDTHH:mm:ss.SSSZ`.
 * Поэтому задавать значение можно как:
 * * 2021-01
 * * 2021-01-23
 * * 2021-01-21T08:30
 * и т. д.
 *
 * Значения этого типа неизменяемые, так что методы мутации возвращают
 * обновлённое значение, не меняя исходного.
 * ```typescript
 * const now = new Datetime();
 * const yesterday = now.addDate(0, 0, -1);
 *
 * now.after(yesterday) // true
 * ```
 *
 * Чтобы все расчеты в сценарии проходили в часовом поясе пользователя, нужно это явно указать,
 * задав текущую временную зону:
 * ```typescript
 * // Получаем нужного пользователя для расчетов
 * const user = ...;
 * // Устанавливаем временную зону для всех дальнейших вычислений в сценарии
 * System.timezones.current = user.timezone;
 * const today_22_00 = Context.data.datavremya.getDate().asDatetime(new TTime(22, 0, 0, 0));
 * ```
 */
interface TDatetime {
    /**
     * Год.
     */
    readonly year: number;
    /**
     * Месяц (0-11).
     */
    readonly month: number;
    /**
     * День месяца (0-30).
     */
    readonly day: number;
    /**
     * Часы (0-23).
     */
    readonly hours: number;
    /**
     * Минуты (0-59).
     */
    readonly minutes: number;
    /**
     * Секунды (0-59).
     */
    readonly seconds: number;
    /**
     * Миллисекунды (0-999).
     */
    readonly milliseconds: number;
    /**
     * Добавить длительность.
     */
    add(duration: TDuration): TDatetime;
    /**
     * Добавить дни, месяцы, годы.
     */
    addDate(years: number, month: number, days: number): TDatetime;
    /**
     * Получить дату.
     *
     * Возвращает дату в указанном часовом поясе; если не указан — в текущем (по умолчанию часовой пояс компании).
     */
    getDate(tz?: TTimezone): TDate;
    /**
     * Получить время.
     *
     * Возвращает время с начала суток в указанном часовом поясе; если не указан — в текущем (по умолчанию часовой пояс компании).
     */
    getTime(tz?: TTimezone): TTime;
    /**
     * Округлить до начала дня.
     *
     * Сбрасывает время до 00:00 и возвращает дату по UTC.
     */
    truncateTime(): TDatetime;
    /**
     * Вычитание дат; возвращает длительность.
     */
    sub(date: TDatetime): TDuration;
    /**
     * Проверка, что текущая дата идет после `date`.
     */
    after(date: TDatetime): boolean;
    /**
     * Проверка, что текущая дата идет перед `date`.
     */
    before(date: TDatetime): boolean;
    /**
     * Проверка на совпадение.
     */
    equal(date: TDatetime): boolean;
    /**
     * Приведение к строке в определённом формате.
     *
     * Используется [синтаксис moment.format()](https://momentjs.com/docs/#/displaying/format/), например:
     * ```typescript
     * const datetime = new Datetime();
     * datetime.format();                                // "2022-02-24T09:00:00+04:00" (стандарт ISO 8601)
     * datetime.format("dddd, MMMM Do YYYY, h:mm:ss a"); // "четверг, февраль 24-го 2022, 9:00:00 утра"
     * datetime.format("ddd, h A");                      // "чт, 9 утра"
     * datetime.format("[Сегодня] dddd");               // "Сегодня четверг"
     * ```
     */
    format(format?: string): string;
    /**
     * Количество секунд от 00:00:00 01.01.1970 UTC.
     */
    unix(): number;
    /**
     * Приведение к стандартному типу `Date`.
     */
    asDate(): Date;
    /**
     * Возвращает дату и время по UTC.
     */
    utc(): TDatetime;
}
/**
 * @ignore
 */
interface DatetimeConstructor {
    new (input?: Date): TDatetime;
    new (value: string, format?: string): TDatetime;
}
/**
 * @ignore
 */
declare const Datetime: DatetimeConstructor;
/**
 * @ignore
 */
interface DatetimeField<T extends TDatetime | TDate | TTime = TDatetime> {
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
    readonly data: {
        /**
         * Метод позволяет установить фильтрацию.
         *
         * ```typescript
         *  const now = new Datetime();
         *  Context.fields.data_vremya.data.setFilter((self, globalFilters) => globalFilters.and(
         *      self.gte(now)
         *  ));
         * ```
         */
        setFilter: (fc: DatetimeFilterClosure<T>) => void;
        /**
         * Метод позволяет очистить фильтрацию пользователя.
         *
         * ```typescript
         *  Context.fields.data_vremya.data.clearFilter();
         * ```
         */
        clearFilter: () => void;
    };
}
/**
 * # Дата
 *
 * Имеет конструкторы:
 * ```typescript
 * new TDate(): TDate;
 * new TDate(year: number, month: number, day: number): TDate;
 * ```
 *
 * Значения этого типа неизменяемые, так что методы мутации возвращают
 * обновлённое значение, не меняя исходного.
 * ```typescript
 * const date = new TDate(2022, 2, 24);
 * const newDate = date.addDate(0, 1, 5);
 * ```
 *
 * Обратите внимание, тип [[TDate]] отличается от встроенного в JavaScript типа `Date`.
 * Данный тип содержит только информацию о дате, без времени суток.
 */
interface TDate {
    /**
     * Год.
     *
     * Пример использования:
     * ```typescript
     * const date = new TDate(2021, 1, 20);
     * const year = date.year;
     * ```
     */
    readonly year: number;
    /**
     * Месяц.
     *
     * Пример использования:
     * ```typescript
     * const date = new TDate(2021, 1, 20);
     * const month = date.month;
     * ```
     */
    readonly month: number;
    /**
     * День.
     *
     * Пример использования:
     * ```typescript
     * const date = new TDate(2021, 1, 20);
     * const day = date.day;
     * ```
     */
    readonly day: number;
    /**
     * Перевод в дату и время.
     *
     * Возвращает дату и время в указанном часовом поясе; если не указан — в текущем (по умолчанию часовой пояс компании).
     *
     * Пример использования:
     * ```typescript
     * const date = new TDate(2021, 1, 20);
     * const time = new TTime(3, 15, 0, 0);
     * const datetime = date.asDatetime(time);
     * ```
     */
    asDatetime(time: TTime, tz?: TTimezone): TDatetime;
    /**
     * Добавление даты.
     *
     * Пример использования:
     * ```typescript
     * const date = new TDate(2021, 1, 20);
     * const newDate = date.addDate(0, 1, 5);
     * ```
     */
    addDate(years: number, month: number, days: number): TDate;
    /**
     * Стоит ли дата позже заданной.
     *
     * Пример использования:
     * ```typescript
     * const startDate = new TDate(2021, 1, 20);
     * const endDate = new TDate(2021, 1, 21);
     * const after = startDate.after(endDate); // false
     * ```
     */
    after(date: TDatetime | TDate): boolean;
    /**
     * Стоит ли дата раньше заданной.
     *
     * Пример использования:
     * ```typescript
     * const startDate = new TDate(2021, 1, 20);
     * const endDate = new TDate(2021, 1, 21);
     * const before = startDate.before(endDate); // true
     * ```
     */
    before(date: TDatetime | TDate): boolean;
    /**
     * Проверка на совпадение даты с заданной.
     *
     * Пример использования:
     * ```typescript
     * const startDate = new TDate(2021, 1, 20);
     * const endDate = new TDate(2021, 1, 21);
     * const equal = startDate.equal(endDate); // false
     * ```
     */
    equal(date: TDatetime | TDate): boolean;
    /**
     * Приводит дату к нужному формату.
     *
     * По умолчанию используется формат `YYYY-MM-DD`:
     *
     * `YYYY`, `y` — год;
     * `MM` — месяц с ведущим нулем;
     * `M` — месяц без ведущим нулем;
     * `DD` — день с ведущим нулем;
     * `D` — день без ведущим нулем;
     * `d` — день недели по счету.
     *
     * Пример использования:
     * ```typescript
     * const date = new TDate(2021, 1, 20);
     * const formatDate = date.format();
     * ```
     */
    format(format?: string): string;
}
/**
 * @ignore
 */
interface TDateConstructor {
    new (): TDate;
    new (year: number, month: number, day: number): TDate;
}
/**
 * @ignore
 */
declare const TDate: TDateConstructor;
/**
 * # Время
 *
 * Хранит в себе время, не превышающее 24 часа.
 *
 * Имеет конструкторы:
 * ```typescript
 * new TTime(): TTime;
 * new TTime(duration: TDuration): TTime;
 * new TTime(hours: number, minutes: number, seconds: number, milliseconds: number): TTime;
 * ```
 *
 * Значения этого типа неизменяемые, так что методы мутации возвращают
 * обновлённое значение, не меняя исходного.
 * ```typescript
 * const time = new TTime(3, 15, 0, 0);
 * const newTime = time.add(2, 15, 0, 0);
 * newTime.after(time); // true
 * ```
 */
interface TTime {
    /**
     * Количество часов.
     *
     * Пример использования:
     * ```typescript
     * const time = new TTime(3, 15, 0, 0);
     * const hours = time.hours;
     * ```
     */
    readonly hours: number;
    /**
     * Количество минут.
     *
     * Пример использования:
     * ```typescript
     * const time = new TTime(3, 15, 0, 0);
     * const minutes = time.minutes;
     * ```
     */
    readonly minutes: number;
    /**
     * Количество секунд.
     *
     * Пример использования:
     * ```typescript
     * const time = new TTime(3, 15, 0, 0);
     * const seconds = time.seconds;
     * ```
     */
    readonly seconds: number;
    /**
     * Количество миллисекунд.
     *
     * Пример использования:
     * ```typescript
     * const time = new TTime(3, 15, 0, 0);
     * const milliseconds = time.milliseconds;
     * ```
     */
    readonly milliseconds: number;
    /**
     * Перевод в дату и время.
     *
     * Возвращает дату и время в указанном часовом поясе; если не указан — в текущем (по умолчанию часовой пояс компании).
     *
     * Пример использования:
     * ```typescript
     * const time = new TTime(3, 15, 0, 0);
     * const date = new TDate(2021, 1, 20);
     * const datetime = time.asDatetime(date);
     * ```
     */
    asDatetime(date: TDate, tz?: TTimezone): TDatetime;
    /**
     * Добавление времени.
     *
     * Пример использования:
     * ```typescript
     * const time = new TTime(3, 15, 0, 0);
     * const duration = new Duration(100, 'millisecond');
     * const newTime = time.add(duration);
     * ```
     * Если добавить больше 24 часов, то время будет отсчитываться заново с 00:00.
     */
    add(duration: TDuration): TTime;
    /**
     * Стоит ли время позже заданного.
     *
     * Пример использования:
     * ```typescript
     * const startTime = new TTime(3, 15, 0, 0);
     * const endTime = new TTime(5, 30, 0, 0);
     * const after = startTime.after(endTime); // false
     * ```
     */
    after(time: TDatetime | TTime): boolean;
    /**
     * Стоит ли время раньше заданного.
     *
     * Пример использования:
     * ```typescript
     * const startTime = new TTime(3, 15, 0, 0);
     * const endTime = new TTime(5, 30, 0, 0);
     * const before = startTime.before(endTime); // true
     * ```
     */
    before(time: TDatetime | TTime): boolean;
    /**
     * Проверка на совпадение времени с заданным.
     *
     * Пример использования:
     * ```typescript
     * const startTime = new TTime(3, 15, 0, 0);
     * const endTime = new TTime(5, 30, 0, 0);
     * const equal = startTime.equal(endTime); // false
     * ```
     */
    equal(time: TDatetime | TTime): boolean;
    /**
     * Приводит время к нужному формату.
     *
     * По умолчанию используется формат `HH:mm:ss`:
     *
     * * `HH` — часы в 24-часовой системе;
     * * `hh` — часы в 12-часовой системе;
     * * `mm` — минуты;
     * * `ss` — секунды;
     * * `SSS` — миллисекунды.
     *
     * Пример использования:
     * ```typescript
     * const time = new TTime(13, 15, 0, 0);
     * const formatTime = time.format('hh mm'); //1pm 15
     * ```
     */
    format(format?: string): string;
}
/**
 * @ignore
 */
interface TTimeConstructor {
    new (): TTime;
    new (duration: TDuration): TTime;
    new (hours: number, minutes: number, seconds: number, milliseconds: number): TTime;
}
/**
 * @ignore
 */
declare const TTime: TTimeConstructor;
/**
 * # Временная зона
 *
 * Подробнее о том, как использовать временные зоны, читайте в [[TTimezones]].
 */
interface TTimezone {
    /**
     * Имя временной зоны в [TZ Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
     */
    name: TimezoneNames;
    /**
     * Смещение данной временной зоны относительно зоны UTC в часах.
     */
    readonly offset: number;
}
/**
 * # Объект временных зон
 *
 * Используется для получения информации по временной зоне:
 * ```typescript
 * const timezoneDefault = await System.timezones.default;
 * ```
 */
interface TTimezones {
    /**
     * Текущая временная зона.
     *
     * Временная зона, с которой работает сценарий.
     * По умолчанию совпадает с временной зоной компании.
     *
     * Пример использования:
     * ```typescript
     * const timezoneСurrent = await System.timezones.current;
     * ```
     *
     * Вы можете изменить текущую временную зону для выполнения сценария.
     * Тогда все дальнейшие операции с датами будут учитывать именно эту зону.
     * ```typescript
     * System.timezones.current = timezoneSamara;
     * ```
     */
    current: TTimezone;
    /**
     * Временная зона компании.
     *
     * Пример использования:
     * ```typescript
     * const timezoneDefault = await System.timezones.default;
     * ```
     */
    readonly default: TTimezone;
    /**
     * Временная зона относительно UTC.
     *
     * Пример использования:
     * ```typescript
     * const timezoneUTC = await System.timezones.UTC;
     * ```
     */
    readonly UTC: TTimezone;
    /**
     * Список временных зон.
     *
     * Пример использования:
     * ```typescript
     * const allTimezones = await System.timezones.all();
     * const timezones = allTimezones.filter(tz => tz.name === 'Europe/Samara');
     * const timezoneSamara = timezones[0];
     * ```
     *
     * Если не задавать `isWinterTime`, то берется смещение времени от сегодняшнего дня.
     * Значение `true` соответствует зимнему времени, `false` — летнему.
     *
     * Имя временной зоны можно посмотреть в глобальной базе
     * [tz database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
     */
    all(isWinterTime?: boolean): TTimezone[];
}
/**
 * # Категория (папка)
 *
 * Ссылка на категорию элементов приложения.
 * В структуре файлов и в иерархическом справочнике категория — это папка.
 */
declare type TCategory<C extends ItemData> = CategoryItemRef<C>;
/**
 * # Описание поля типа [[TCategory]]
 *
 * @ignore
 */
interface StaticCategoryField<C extends ItemData> {
}
/**
 * # Описание поля типа «Категория»
 *
 * @ignore
 */
interface CategoryField<C extends ItemData> extends StaticCategoryField<C> {
    /**
     * Запросить все ассоциированные объекты.
     *
     * В случае, когда в поле лежит множество ссылок на элементы приложения, можно запросить их одной командой:
     * ```typescript
     * const items = await Context.fields.app.fetchAll();
     * ```
     */
    fetchAll(): Promise<CategoryItem<C>[]>;
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * # Деньги
 *
 * Имеет конструкторы:
 * ```typescript
 * new Money(float: number): TMoney<'XXX'>;
 * new Money<C extends CurrencyCode>(float: number, currency: C): TMoney<C>;
 * ```
 *
 * При работе в сценариях предпочтительно использовать
 * конструктор с указанием конкретной валюты:
 * ```typescript
 * const price = new Money(100.5, 'RUB');
 * ```
 *
 * Коды валют соответствуют стандарту [ISO 4217](https://ru.wikipedia.org/wiki/ISO_4217).
 *
 * Значения этого типа неизменяемые, так что методы мутации возвращают
 * обновлённое значение, не меняя исходного.
 * ```typescript
 * const price = new Money(100.5, 'RUB');
 * const total = price.multiply(count);
 * ```
 */
interface TMoney<C extends CurrencyCode> {
    /**
     * Количество центов / копеек.
     */
    readonly cents: number;
    /**
     * Валюта (буквенный код по стандарту ISO 4217).
     */
    readonly currency: C;
    /**
     * Умножить на число с округлением центов в нижнюю сторону.
     */
    multiply(k: number): TMoney<C>;
    /**
     * Сложение.
     */
    add(money: TMoney<C | 'XXX'>): TMoney<C>;
    /**
     * Приведение к десятичной дроби с точностью, соответствующей валюте.
     *
     * ```typescript
     * const salary = new Money(101, 'RUB');
     * const salary2 = salary.multiply(0,001);
     * salary2.asFloat(); // 0.1
     * ```
     */
    asFloat(): number;
}
/**
 * @ignore
 */
interface MoneyConstructor {
    new (float: number): TMoney<'XXX'>;
    new <C extends CurrencyCode>(float: number, currency: C): TMoney<C>;
}
/**
 * @ignore
 */
declare const Money: MoneyConstructor;
/**
 * # Описание поля типа [[TMoney]]
 *
 * @ignore
 */
interface MoneyField<C extends CurrencyCode> {
    /**
     * Создать значение типа [[TMoney<C>]].
     */
    create(float: number): TMoney<C>;
    readonly name: string;
    readonly type: string;
}
/**
 * # Ссылка на файл
 */
declare type TFile = FileItemRef;
/**
 * # Ссылка на роль
 */
declare type TRole = Role;
/**
 * # Ссылка на OAuth2
 */
declare type TOAuth2 = OAuth2Record;
/**
 * @ignore
 */
interface StaticFileField {
    /**
     * Метод [[FileField.create]] позволяет создать файл в контексте процесса.
     * @param name Имя файла.
     * @param body Тело файла.
     *
     * ```typescript
     * const fileRq = await fetch(`https://jpeg.org/images/jpegsystems-home.jpg`)
     * const buf = await fileRq.arrayBuffer()
     * const file = await Context.fields.file.create("home.jpg", buf)
     * ```
     */
    create(name: string, body: ArrayBuffer): Promise<FileItem>;
    /**
     * Метод [[FileField.createFromLink]] позволяет загрузить файл из стороннего источника в контекст процесса.
     * @param name Имя файла.
     * @param url Ссылка на файл.
     *
     * ```typescript
     * const file = await Context.fields.file.createFromLink("home.jpg", `https://jpeg.org/images/jpegsystems-home.jpg`)
     * ```
     */
    createFromLink(name: string, url: string): Promise<FileItem>;
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * # Описание поля типа [[TFile]]
 */
interface FileField {
    /**
     * Метод [[FileField.create]] позволяет создать файл в контексте процесса.
     *
     * @param name Имя файла.
     * @param body Тело файла.
     *
     * ```typescript
     * const fileRq = await fetch(`https://jpeg.org/images/jpegsystems-home.jpg`)
     * const buf = await fileRq.arrayBuffer()
     * const file = await Context.fields.file.create("home.jpg", buf)
     * ```
     */
    create(name: string, body: ArrayBuffer): Promise<FileItem>;
    /**
     * Метод [[FileField.createFromLink]] позволяет загрузить файл из стороннего источника в контекст процесса.
     *
     * @param name Имя файла.
     * @param url Ссылка на файл.
     *
     * ```typescript
     * const file = await Context.fields.file.createFromLink("home.jpg", `https://jpeg.org/images/jpegsystems-home.jpg`)
     * ```
     */
    createFromLink(name: string, url: string): Promise<FileItem>;
    /**
     * Запросить все ассоциированные файлы.
     *
     * В случае, когда в поле лежит множество ссылок на файлы, можно запросить их одной командой:
     * ```typescript
     * const files = await Context.fields.files.fetchAll();
     * ```
     */
    fetchAll(): Promise<FileItem[]>;
}
/**
 * # Типы объектов в поле типа Роль
 * * пользователь;
 * * группа;
 * * элемент оргструктуры.
 */
declare type RoleType = 'user' | 'group' | 'orgstruct';
/**
 * # Поле типа Роль
 */
interface Role {
    /**
     * Тип объекта: пользователь, группа или элемент оргструктуры.
     */
    type: RoleType;
    /**
     * Уникальный код объекта.
     */
    code: string;
    /**
     * Метод [[Role.getUsers]] позволяет получить пользователей, хранящихся в переменной типа Роль.
     *
     * Например, если в контексте есть переменная типа Роль (role) и переменная типа Пользователи,
     * несколько (users), записать пользователей из role в users можно следующим образом:
     * ```typescript
     * for (let i of Context.data.role) {
     *   let users = await i.getUsers()
     *   Context.data.users = Context.data.users.concat(users)
     * }
     * ```
     * Метод `getUsers()` всегда возвращает до 10000 элементов. Для работы с пользователями с учетом пагинации
     * можно использовать объект поиска пользователей, `System.users.search`.
     */
    getUsers(): Promise<UserItem[]>;
}
/**
 * @ignore
 */
interface StaticRoleField {
    __salt: '49edd96a-9603-4638-bd8d-c35ea8e77ba3';
    readonly name: string;
    readonly type: string;
}
/**
 * # Описание поля типа [[TRole]]
 */
interface RoleField extends StaticRoleField {
}
/**
 * # Типы телефонов
 */
declare enum PhoneType {
    /**
     * # Домашний
     */
    Home = "home",
    /**
     * # Рабочий
     */
    Work = "work",
    /**
     * # Мобильный
     */
    Mobile = "mobile",
    /**
     * # Основной
     */
    Main = "main",
    /**
     * # Домашний факс
     */
    HomeFax = "home-fax",
    /**
     * # Рабочий факс
     */
    WorkFax = "work-fax",
    /**
     * # Пейджер
     */
    Pager = "pager"
}
/**
 * # Телефон
 *
 * Тип данных для представления номера телефона.
 *
 * Значение поля можно задать несколькими способами:
 * ```
 * Context.data.client_phone = Context.data.client_phone.create('+7987654321');
 * Context.data.client_phone = Context.data.client_phone.create('8-999-123456', PhoneType.Work, '101');
 * Context.data.client_phone = {
 *   type: PhoneType.Work,
 *   tel: '8-999-123456',
 *   ext: '101'
 * };
 * ```
 *
 * Обратите внимание, что при работе в сценариях
 * не производится валидация корректности формата телефона.
 */
interface TPhone<T extends PhoneType> {
    /**
     * Тип телефона [[PhoneType]].
     */
    type: T;
    /**
     * Телефон.
     */
    tel: string;
    /**
     * Добавочный номер.
     */
    ext?: string;
}
/**
 * # Описание поля типа Телефон
 *
 * @ignore
 */
interface PhoneFieldTyped<T extends PhoneType> {
    /**
     * Конструктор значения поля.
     */
    create(tel: string): TPhone<T>;
    readonly name: string;
    readonly type: string;
}
/**
 * # Описание поля типа Телефон
 *
 * @ignore
 */
interface PhoneFieldVoid {
    /**
     * Конструктор значения поля.
     */
    create<T extends PhoneType>(tel: string, type: T, ext: string): TPhone<T>;
    readonly name: string;
    readonly type: string;
}
/** @ignore */
declare type PhoneField = PhoneFieldTyped<PhoneType> | PhoneFieldVoid;
/**
 * # Типы учетных записей
 */
declare enum AccountType {
    Telegram = "telegram",
    Whatsapp = "whatsapp",
    Instagram = "instagram",
    Viber = "viber",
    Facebook = "facebook",
    Vkontakte = "vkontakte",
    Skype = "skype",
    GoogleTalk = "google-talk",
    GoogleHangouts = "google-hangouts",
    WeChat = "we-chat",
    Snapchat = "snapchat",
    Line = "line",
    Other = "other"
}
/**
 * # Учетная запись
 */
interface TAccount<T extends AccountType> {
    /**
     * Тип учётной записи.
     */
    type: T;
    /**
     * Логин.
     */
    login: string;
}
/**
 * # Описание поля типа [[TAccount]]
 */
interface AccountFieldTyped<T extends AccountType> {
    /**
     * Конструктор значения поля.
     */
    create(login: string): TAccount<T>;
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * # Описание поля типа [[TAccount]]
 */
interface AccountFieldVoid {
    /**
     * Конструктор значения поля.
     */
    create<T extends AccountType>(login: string, type: T): TAccount<T>;
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * @ignore
 */
declare type AccountField = AccountFieldTyped<AccountType> | AccountFieldVoid;
/**
 * # Типы адресов электронной почты
 */
declare enum EmailType {
    /**
     * # Домашний
     */
    Home = "home",
    /**
     * # Рабочий
     */
    Work = "work",
    /**
     * # Мобильный
     */
    Mobile = "mobile",
    /**
     * # Основной
     */
    Main = "main"
}
/**
 * # Электронная почта
 *
 * Значение поля можно задать несколькими способами:
 * ```
 * Context.data.client_email = Context.data.client_email.create('user@company.com');
 * Context.data.client_email = Context.data.client_email.create('user@company.com', EmailType.Work);
 * Context.data.client_email = {
 *   type: EmailType.Work,
 *   email: 'user@company.com'
 * };
 * ```
 *
 * Обратите внимание, что при работе в сценариях
 * не производится валидация корректности формата email-адреса.
 */
interface TEmail<T extends EmailType> {
    /**
     * Тип адреса [[EmailType]].
     */
    type: T;
    /**
     * Email-адрес.
     */
    email: string;
}
/**
 * # Описание поля типа Почта
 *
 * @ignore
 */
interface EmailFieldTyped<T extends EmailType> {
    /**
     * Конструктор значения поля.
     */
    create(email: string): TEmail<T>;
    readonly name: string;
    readonly type: string;
}
/**
 * # Описание поля типа Почта
 *
 * @ignore
 */
interface EmailFieldVoid {
    /**
     * Конструктор значения поля.
     */
    create<T extends EmailType>(email: string, type: T): TEmail<T>;
    readonly name: string;
    readonly type: string;
}
/** @ignore */
declare type EmailField = EmailFieldTyped<EmailType> | EmailFieldVoid;
/**
 * # Перечисление типов замещений
 *
 * Используется в типе [[ReplacementTypeEnumBase]].
 */
declare enum ReplacementType {
    Information = "information",
    Reassign = "reassign",
    Full = "full"
}
/**
 * # Типы замещений
 *
 * * Information — информирование;
 *
 * * Reassign — переназначение задач;
 *
 * * Full — полная передача прав.
 */
declare type ReplacementTypeEnumBase = ReplacementType.Information | ReplacementType.Reassign | ReplacementType.Full;
/**
 * # Изображение
 */
declare type TImage = ImageItemRef;
/**
 * @ignore
 */
interface StaticImageField {
    /**
     * Метод [[ImageField.create]] позволяет создать изображение в контексте процесса.
     * @param name Имя изображения.
     * @param body Тело файла.
     *
     * ```typescript
     * const fileRq = await fetch(`https://jpeg.org/images/jpegsystems-home.jpg`)
     * const buf = await fileRq.arrayBuffer()
     * const file = await Context.fields.image.create("home.jpg", buf)
     * ```
     */
    create(name: string, body: ArrayBuffer): Promise<ImageItem>;
    /**
     * Метод [[ImageField.createFromLink]] позволяет загрузить изображение из стороннего источника в контекст процесса.
     * @param name Имя изображения.
     * @param url Ссылка на изображение.
     *
     * ```typescript
     * const file = await Context.fields.image.createFromLink("home.jpg", `https://jpeg.org/images/jpegsystems-home.jpg`)
     * ```
     */
    createFromLink(name: string, url: string): Promise<ImageItem>;
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * # Описание поля типа [[TImage]]
 */
interface ImageField {
    /**
     * Метод [[ImageField.create]] позволяет создать изображение в контексте процесса.
     *
     * @param name Имя изображения.
     * @param body Тело файла.
     *
     * ```typescript
     * const fileRq = await fetch(`https://jpeg.org/images/jpegsystems-home.jpg`)
     * const buf = await fileRq.arrayBuffer()
     * const file = await Context.fields.image.create("home.jpg", buf)
     * ```
     */
    create(name: string, body: ArrayBuffer): Promise<ImageItem>;
    /**
     * Метод [[ImageField.createFromLink]] позволяет загрузить изображение из стороннего источника в контекст процесса.
     *
     * @param name Имя изображения.
     * @param url Ссылка на изображение.
     *
     * ```typescript
     * const file = await Context.fields.image.createFromLink("home.jpg", `https://jpeg.org/images/jpegsystems-home.jpg`)
     * ```
     */
    createFromLink(name: string, url: string): Promise<ImageItem>;
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * Запросить все ассоциированные изображения.
     *
     * В случае, когда в поле лежит множество ссылок на изображения, можно запросить их одной командой:
     * ```typescript
     * const images = await Context.fields.images.fetchAll();
     * ```
     */
    fetchAll(): Promise<ImageItem[]>;
}
/**
 * # Статус
 *
 * Значения полей данного типа в элементе приложения ([[ApplicationItem]]) можно изменить
 * только через вызов метода [[ApplicationItem.setStatus]].
 */
interface TStatus<T extends string, C extends ItemData> {
    /**
     * Код статуса.
     */
    readonly code: T;
    /**
     * Название статуса.
     */
    readonly name: string;
    /**
     * Номер статуса в списке статусов (порядковый номер).
     */
    readonly index: number;
    /**
     * Финальный ли статус.
     */
    readonly final: boolean;
    /**
     * Идентификатор статуса.
     */
    readonly id: number;
    /**
     * Удалён ли статус.
     */
    readonly deleted: boolean;
    /**
     * Идентификатор группы, к которой относится статус.
     */
    readonly groupId: string;
}
/**
 * # Описание поля типа [[TStatus]]
 *
 * Хранит настройки статусов приложения.
 */
interface StatusField<T extends string, C extends ItemData> {
    /**
     * Массив всех доступных статусов приложения.
     *
     * ```typescript
     * const statuses = Application.fields.__status.all;
     *
     * // Получить первый статус в массиве
     * const firstStatus = statuses[0];
     *
     * // Получить названия всех статусов
     * const statusNames = statuses.map(status => status.name);
     *
     * // Найти статус по коду "new"
     * const newStatus = statuses.find(status => status.code === 'new');
     * ```
     *
     * Обратите внимание, что в данном поле хранятся статусы из всех групп статусов. Для получения статусов из
     * определенной группы, проверьте значение поля [[TStatus.groupId]] у статуса:
     *
     * ```typescript
     * const statuses = Application.fields.__status.all;
     * const groups = Application.fields.__status.groups;
     *
     * // Получить названия всех статусов из группы статусов с кодом "sales"
     * const statusNames = statuses.map(status => status.name && status.groupId === groups.sales.id);
     *
     * // Найти статус по коду "new" из группы статусов по умолчанию
     * const newStatus = statuses.find(status => status.code === 'new' && status.groupId === groups.__default.id);
     * ```
     *
     * Если вас интересуют статусы только из группы статусов по умолчанию, вы также можете воспользоваться данными из
     * поля [[variants]]
     */
    readonly all: TStatus<string, ItemData>[];
    /**
     * Список групп статусов, настроенных для приложения.
     *
     * У каждого приложения есть группа статусов по умолчанию — она хранится в поле `__default`.
     *
     * Группы статусов используются только в разделе CRM в системных приложениях «Лиды» и «Сделки» для представления
     * [воронок продаж](https://elma365.com/ru/help/360012693559.html). Создание групп статусов в других приложениях
     * невозможно.
     *
     * ```typescript
     * const groups = Application.fields.__status.groups;
     *
     * // Получить название группы статусов по умолчанию
     * const defaultStatusGroupName = groups.__default.name;
     *
     * // Получить названия статусов из группы статусов с кодом "sales"
     * const allSalesStatusNames = groups.sales.all.map(status => status.name);
     * ```
     */
    readonly groups: {
        [I in keyof C]: GroupStatusField<C[I]>;
    };
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
    /**
     * Список статусов приложения из группы статусов по умолчанию.
     *
     * ```typescript
     * const variants = Application.fields.__status.variants;
     *
     * // Получить название статуса с кодом "new"
     * const newStatusName = variants.new.name;
     * ```
     */
    readonly variants: {
        [K in T]: TStatus<K, ItemData>;
    };
}
/**
 *  # Описание групп статусов
 */
interface GroupStatusField<T extends string> {
    /**
     * Идентификатор группы статусов.
     */
    readonly id: string;
    /**
     * Название группы статусов.
     */
    readonly name: string;
    /**
     * Массив всех статусов приложения из конкретной группы.
     */
    readonly all: TStatus<string, ItemData>[];
    /**
     * Список всех статусов приложения из конкретной группы.
     */
    readonly variants: {
        [K in T]: TStatus<K, ItemData>;
    };
    /**
     * Массив всех причин отказа.
     */
    readonly rejectReasons: string[];
}
/**
 * # Доступные статусы пользователя
 *
 * * Invited (0) — приглашен;
 * * Rejected (1) — приглашение отклонено;
 * * Active (2) — активный;
 * * Blocked (3) — заблокирован;
 * * Canceled (4) — приглашение отменено.
 *
 * ```typescript
 * // Поиск всех активных пользователей
 * const userSearch = await System.users.search().where(f => f.__status.eq(UserStatus.Active)).size(10000).all()
 * ```
 *
 */
declare enum UserStatus {
    Invited = 0,
    Rejected = 1,
    Active = 2,
    Blocked = 3,
    Canceled = 4
}
/**
 * # Пользователь
 */
declare type TUser = UserItemRef;
/**
 * # Управление данными поля типа Пользователь
 */
interface UserFieldData extends StaticApplicationFieldData<UserData> {
    /**
     * Метод позволяет установить фильтрацию пользователя.
     *
     * ```typescript
     *  Context.fields.polzovateli.data.setFilter((appFields, context, globalFilters) => globalFilters.and(
     *      appFields.enabled.eq(true),
     *      appFields.__createdAt.gte(context.year)
     *  ));
     * ```
     */
    setFilter: (fc: CollFilterClosure<UserData>) => void;
    /**
     * Метод позволяет очистить фильтрацию пользователя.
     *
     * ```typescript
     *  Context.fields.polzovateli.data.clearFilter();
     * ```
     */
    clearFilter: () => void;
}
/**
 * @ignore
 */
interface StaticUserField {
    /**
     * Добавлена "примесь" для того чтобы работала типизация (пустой интерфейс реализует любой класс)
     * @ignore
     */
    __salt: '0d446836-beeb-591a-ba28-44617a6315d5';
    readonly data: UserFieldData;
}
/**
 * # Описание поля пользователя [[TUser]]
 */
interface UserField extends StaticUserField {
    /**
     * Метод [[UserField.fetchAll]] позволяет запросить всех ассоциированных пользователей.
     *
     * В случае, когда поле хранит множество ссылок на пользователей,
     * можно запросить полные данные пользователей одной командой:
     * ```typescript
     * const users = await Context.fields.performers.fetchAll();
     * ```
     */
    fetchAll(): Promise<UserItem[]>;
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * # Ссылка на элемент приложения
 */
declare type TApplication<Data extends ItemData, Params extends ItemData, P extends Processes> = ApplicationItemRef<Data, Params>;
/**
 * # Управление данными в поле
 */
interface StaticApplicationFieldData<T extends ItemData> {
    /**
     * Метод [[StaticApplicationFieldData.setFilter]] позволяет установить фильтр на поле типа Приложение.
     *
     * Важно отметить, что метод устанавливает фильтр на уровне поля, а не для текущей формы или бизнес-процесса.
     * Это значит, что если фильтрация больше не требуется, необходимо использовать [[clearFilter]].
     *
     * Аргументом метода является функция, принимающая `CollFilterClosure`.
     * В `CollFilterClosure` доступны поля приложения, текущий контекст и глобальные функции фильтров.
     * В примере ниже `appFields` — поля приложения, `context` — текущий контекст (например, бизнес-процесса),
     * `globalFilters` — глобальные функции фильтров.
     *
     * ```typescript
     *  Context.fields.cars.data.setFilter((appFields, context, globalFilters) => globalFilters.and(
     *      appFields.enabled.eq(true),
     *      appFields.year_of_issue.gte(context.year)
     *  ));
     * ```
     */
    setFilter: (fc: CollFilterClosure<T>) => void;
    /**
     * Метод [[StaticApplicationFieldData.clearFilter]] позволяет очистить фильтр поля типа Приложение.
     *
     * ```typescript
     *  Context.fields.cars.data.clearFilter();
     * ```
     */
    clearFilter: () => void;
}
/**
 * @ignore
 */
interface StaticApplicationField<T extends ItemData, P extends ItemData, S extends Processes> {
    /**
     * Описание коллекции типа поля.
     */
    readonly app: T extends UserProfileItemData ? Application<T, P, S> & ApplicationUserProfile<T, P> : T extends ProjectItemData ? Application<T, P, S> & ApplicationProject<T, P> : Application<T, P, S>;
    /**
     * Управление данными в поле.
     */
    readonly data: StaticApplicationFieldData<T>;
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * # Описание поля типа Приложение
 *
 * Поле, в котором лежит ссылка на элемент [[TApplication]].
 */
interface ApplicationField<T extends ItemData, P extends ItemData, S extends Processes> extends StaticApplicationField<T, P, S> {
    /**
     * Метод [[fetchAll]] позволяет запросить все ассоциированные объекты.
     *
     * В случае, когда поле хранит множество ссылок на элементы приложения,
     * можно запросить их полные данные одной командой:
     * ```typescript
     * const items = await Context.fields.app.fetchAll();
     * ```
     */
    fetchAll(): Promise<ApplicationItem<T, P>[]>;
}
/**
 * # Тип ФИО
 *
 * Хранит фамилию, имя и отчество.
 * ```typescript
 * Context.data.fio = {
 *   lastname: 'Иванов',
 *   firstname: 'Василий',
 *   middlename: 'Пертович'
 * };
 * ```
 */
interface TFullName {
    /**
     * Фамилия.
     */
    lastname: string;
    /**
     * Имя.
     */
    firstname: string;
    /**
     * Отчество.
     */
    middlename: string;
}
/**
 * @ignore
 */
interface FullNameField {
    readonly name: string;
    readonly type: string;
}
/**
 * # Ссылка (URL)
 *
 * Используется как обычная строка. Не проходит валидацию.
 * ```typescript
 * Context.data.site_url = 'https://elma365.com';
 * ```
 */
declare type TLink = string;
/**
 * @ignore
 */
interface LinkField {
    readonly name: string;
    readonly type: string;
}
/**
 * # Категория (перечисление)
 *
 * ```typescript
 * Context.data.lead_type = Context.fields.lead_type.social;
 * ```
 *
 * Для некоторых кодов категорий доступ возможен только через квадратные скобки.
 *
 * ```typescript
 * Context.fields.category['n-'];
 * Context.fields.category['1n'];
 * ```
 */
interface TEnum<T extends string> {
    /**
     * Код варианта.
     */
    code: T;
    /**
     * Название варианта.
     */
    name: string;
}
/**
 * # Описание поля типа Категория
 */
interface EnumField<T extends string> {
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
    /**
     * Словарь допустимых значений.
     *
     * Для некоторых кодов категорий доступ возможен только через квадратные скобки.
     *
     * ```typescript
     * Context.fields.category['n-'];
     * Context.fields.category['1n'];
     * ```
     */
    variants: {
        [K in T]: TEnum<K>;
    };
    /**
     * @ignore
     */
    readonly data: {
        variants: TEnum<string>[];
    };
}
/**
 * # Произвольный тип (JSON)
 *
 * Тип предназначен для передачи или хранения произвольных данных в контексте:
 * ```typescript
 * Context.data.json = {
 *     'my-string': 'string data',
 *     'my-num': 1234,
 *     'my-bool': true,
 *     'my-array': [ 'string', 999, false ],
 *     'my-object': {
 *         // Вложенный объект также возможен
 *     }
 * };
 * ```
 *
 * Обратите внимание, что при использовании этого типа в сохраняемом контексте
 * (контексте приложения, контексте процесса, серверном контексте виджета) в этом значении могут храниться только
 * примитивные типы данных JSON.
 *
 * Однако вполне возможно, в частности, использовать этот тип для передачи произвольных
 * значений между виджетами на клиенте с использованием привязки входящих переменных.
 * ```typescript
 * // Виджет 1 - внешний
 * async function onInit() {
 *     Context.data.json = {
 *         onSaveCallback: async () => await saveFunction() // Записываем ссылку на функцию
 *     };
 * }
 *
 * async function saveFunction() {
 *     // Логика обработки события
 * }
 *
 * // Виджет 2 - внутренний
 * async function onSaveClick() {
 *     await Context.data.in_json?.onSaveCallback?.();
 * }
 * ```
 */
declare type TJSON = any;
/**
 * @ignore
 */
interface JSONField {
    readonly name: string;
    readonly type: string;
}
/**
 * # Таблица
 *
 * Таблица — это тип переменной, представляющий собой массив данных — строк таблицы.
 * Каждая строка является отдельным элементом массива и представляет собой объект,
 * свойства которого определены столбцами таблицы.
 *
 * Подробнее про работу с таблицами можете почитать в {@page Начало работы с типом данных Таблица | этой статье}.
 */
interface TTable<T extends ItemData, R extends ItemData> {
    /**
     * Iterator of values in the array
     *
     * @ignore
     */
    [Symbol.iterator](): IterableIterator<T>;
    /**
     * @ignore
     */
    readonly [n: number]: T;
    /**
     * Свойство [[TTable.length]] возвращает число элементов таблицы.
     *
     * Значение данного свойства — 32-битное беззнаковое целое число, которое всегда больше, чем наибольший индекс в массиве.
     */
    readonly length: number;
    /**
     * Строка вычисляемого результата в таблице.
     *
     * В этой строке могут быть настроены вычисления суммы, среднего, количества.
     */
    readonly result: R;
    /**
     * Метод [[TTable.insert]] добавляет новую строку в таблицу и возвращает ссылку на неё.
     *
     * @param index Индекс новой строки.
     *
     * ```typescript
     * // Получаем заказ
     * const order = await Context.data.orders!.fetch();
     * // Вставляем строку, `row` присваивается ссылка на новую строку
     * const row = order.data.content!.insert();
     * // Заполняем строку
     * row.item = Context.data.product!;
     * row.amount = Context.data.amount!;
     * // Сохраняем заказ
     * await order.save();
     * ```
     * @returns Новая строка таблицы.
     */
    insert(index?: number): T;
    /**
     * Метод [[TTable.delete]] удаляет конкретную строку из заданной таблицы.
     *
     * @param index Целое число, представляющее строку, которую следует удалить.
     *
     * ```typescript
     * // Получаем заказ
     * const order = await Context.data.orders!.fetch();
     * // Проходим циклом по каждой строке
     * for (let i = order.data.content!.length - 1; i >= 0; i--) {
     *   const row = order.data.content![i];
     *   // Проверяем, заполнено ли поле «Количество»
     *   if(!row.amount) {
     *       // Удаляем строку, если не заполнено
     *       order.data.content!.delete(i);
     *   }
     * }
     * // Сохраняем заказ
     * await order.save();
     * ```
     */
    delete(index: number): void;
    /**
     * Метод [[TTable.toString]] возвращает строковое представление элементов таблицы.
     *
     * Для таблицы метод `toString` соединяет массив и возвращает одну строку,
     * содержащую все элементы массива, разделённые запятыми.
     */
    toString(): string;
    /**
     * Метод [[TTable.toLocaleString]] возвращает строковое представление элементов таблицы.
     *
     * Элементы преобразуются в строки с использованием своих собственных методов `toLocaleString`,
     * и эти строки разделяются локалезависимой строкой, например, запятой (,).
     */
    toLocaleString(): string;
    /**
     * Метод [[TTable.concat]] возвращает новый массив, состоящий из массива элементов таблицы, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.
     *
     * **Внимание:** возвращаемое значение — это обычный массив, который не является Таблицей.
     *
     * @param items Массивы и/или значения, соединяемые в новый массив.
     * @returns Новый массив, содержащий все элементы.
     */
    concat(...items: (T | ConcatArray<T>)[]): T[];
    /**
     * Метод [[TTable.join]] объединяет все элементы таблицы в строку.
     *
     * @param separator Определяет строку, разделяющую элементы массива. В случае необходимости тип разделителя приводится к типу Строка.
     * Если он не задан, элементы массива разделяются запятой (,).
     * Если разделитель — пустая строка, элементы массива ничем не разделяются в возвращаемой строке.
     */
    join(separator?: string): string;
    /**
     * Метод [[TTable.slice]] возвращает новый массив, содержащий копию части исходной таблицы.
     *
     * **Внимание:** возвращаемое значение — это обычный массив, который не является Таблицей.
     *
     * @param start Индекс, по которому необходимо начинать извлечение (счёт начинается с нуля).
     * Если индекс отрицательный, `start` указывает смещение от конца последовательности.
     * Вызов `slice(-2)` извлечёт два последних элемента таблицы.
     * Если `start` не определён, `slice()` начинает работать с индекса `0`.
     * Если `start` больше длины последовательности, вернётся пустой массив.
     * @param end Индекс, по которому необходимо заканчивать извлечение (счёт начинается с нуля).
     * Метод `slice()` извлекает элементы с индексом меньше `end`.
     * Вызов `slice(1, 4)` извлечёт элементы со второго по четвёртый (элементы по индексам 1, 2 и 3).
     * Если индекс отрицательный, `end` указывает смещение от конца последовательности.
     * Вызов `slice(2, -1)` извлечёт из последовательности элементы начиная с третьего элемента с начала и заканчивая вторым с конца.
     * Если `end` опущен, `slice()` извлекает все элементы до конца последовательности (`table.length`).
     * @returns Новый массив, содержащий выборку элементов таблицы.
     */
    slice(start?: number, end?: number): T[];
    /**
     * Метод [[TTable.indexOf]] возвращает первый индекс, по которому данный элемент может быть найден в таблице, или -1, если такого индекса нет.
     *
     * @param searchElement Искомый элемент в массиве.
     * @param fromIndex Индекс, с которого начинать поиск.
     * Если индекс больше или равен длине таблицы, возвращается -1, что означает, что таблица даже не просматривается.
     * Если индекс является отрицательным числом, он трактуется как смещение с конца таблицы.
     * Обратите внимание: если индекс отрицателен, таблица всё равно просматривается от начала к концу.
     * Если рассчитанный индекс оказывается меньше 0, поиск ведётся по всей таблице.
     * Значение по умолчанию равно 0, что означает, что просматривается вся таблица.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Метод [[TTable.lastIndexOf]] возвращает последний индекс, по которому данный элемент может быть найден в таблице, или -1, если такого индекса нет. Таблица просматривается от конца к началу, начиная с индекса `fromIndex`.
     *
     * @param searchElement Искомый элемент в таблице.
     * @param fromIndex Необязательный параметр. Индекс, с которого начинать поиск в обратном направлении.
     * Если индекс больше или равен длине таблицы, просматривается вся таблица.
     * Если индекс является отрицательным числом, он трактуется как смещение с конца таблицы.
     * Обратите внимание: если индекс отрицателен, таблица всё равно просматривается от конца к началу.
     * Если рассчитанный индекс оказывается меньше 0, таблица даже не просматривается.
     * Значение по умолчанию равно длине таблицы, что означает, что просматривается вся таблица.
     */
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Метод [[TTable.every]] проверяет, удовлетворяют ли все элементы таблицы условию, заданному в передаваемой функции.
     *
     * **Внимание:** метод возвращает `true` при любом условии для пустой таблицы.
     *
     * @param predicate Функция проверки каждого элемента. Принимает три аргумента:
     * @param predicate.value Текущий обрабатываемый элемент таблицы.
     * @param predicate.index Индекс текущего обрабатываемого элемента таблицы.
     * @param predicate.array Таблица, по которой осуществляется проход.
     * @param thisArg Необязательный параметр. Значение, используемое в качестве `this` при выполнении функции `predicate`.
     * @returns Возвращает `true`, если функция проверки возвращает истинное значение для каждого элемента таблицы. Иначе `false`.
     */
    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Метод [[TTable.some]] проверяет, удовлетворяет ли какой-либо элемент таблицы условию, заданному в передаваемой функции.
     *
     * **Внимание:** метод возвращает `false` при любом условии для пустой таблицы.
     *
     * @param predicate Функция проверки каждого элемента. Принимает три аргумента:
     * @param predicate.value Текущий обрабатываемый элемент таблицы.
     * @param predicate.index Индекс текущего обрабатываемого элемента таблицы.
     * @param predicate.array Таблица, по которой осуществляется проход.
     * @param thisArg Необязательный параметр. Значение, используемое в качестве `this` при выполнении функции `predicate`.
     * @returns Возвращает `true`, если функция проверки возвращает истинное значение хотя бы для одного элемента таблицы. Иначе `false`.
     */
    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;
    /**
     * Метод [[TTable.forEach]] выполняет указанную функцию один раз для каждого элемента в таблице.
     *
     * @param callback Функция, которая будет вызвана для каждого элемента массива. Она принимает от одного до трёх аргументов:
     * @param callback.value Текущий обрабатываемый элемент таблицы.
     * @param callback.index Индекс текущего обрабатываемого элемента таблицы.
     * @param callback.array Таблица, по которой осуществляется проход.
     * @param thisArg Необязательный параметр. Значение, используемое в качестве `this` при выполнении функции `callback`.
     */
    forEach(callback: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;
    /**
     * Метод [[TTable.map]] создаёт новый массив с результатом вызова указанной функции для каждого элемента таблицы.
     *
     * **Внимание:** возвращаемое значение — это обычный массив, который не является Таблицей.
     *
     * @param callback Функция, вызываемая для каждого элемента таблицы.
     * Каждый раз, когда `callback` выполняется, возвращаемое значение добавляется в новый массив.
     * @param callback.value Текущий обрабатываемый элемент таблицы.
     * @param callback.index Индекс текущего обрабатываемого элемента таблицы.
     * @param callback.array Таблица, по которой осуществляется проход.
     * @param thisArg Необязательный параметр. Значение, используемое в качестве `this` при выполнении функции `callback`.
     * @returns Новый массив, где каждый элемент является результатом `callback` функции.
     * @typeParam U Тип элемента возвращаемого массива.
     */
    map<U>(callback: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];
    /**
     * Метод [[TTable.filter]] создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
     *
     * **Внимание:** возвращаемое значение — это обычный массив, который не является Таблицей.
     *
     * @param predicate Функция-предикат, которая будет вызвана для проверки каждого элемента массива.
     * Если функция возвращает `true`, то элемент остаётся в массиве, если `false`, то удаляется.
     * @param predicate.value Текущий обрабатываемый элемент таблицы.
     * @param predicate.index Индекс текущего обрабатываемого элемента таблицы.
     * @param predicate.array Таблица, по которой осуществляется проход.
     * @param thisArg Необязательный параметр. Значение, используемое в качестве `this` при выполнении функции `predicate`.
     * @returns Новый массив с элементами, которые прошли проверку.
     * Если ни один элемент не прошёл проверку, то будет возвращён пустой массив.
     */
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
    /**
     * Метод [[TTable.reduce]] применяет функцию **reducer** к каждому элементу таблицы (слева направо), возвращая одно результирующее значение.
     *
     * @param callback Функция, выполняющаяся для каждого элемента массива.
     * @param callback.previousValue Аккумулятор значения, которое возвращает функция `callback` после посещения очередного элемента, либо значение `initialValue`, если оно предоставлено.
     * @param callback.currentValue Текущий обрабатываемый элемент таблицы.
     * @param callback.index Индекс текущего обрабатываемого элемента таблицы.
     * @param callback.array Таблица, по которой осуществляется проход.
     * @param initialValue Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции `callback`.
     */
    reduce(callback: (previousValue: T, currentValue: T, index: number, array: readonly T[]) => T, initialValue?: T): T;
    /**
     * Метод [[TTable.reduce]] применяет функцию **reducer** к каждому элементу таблицы (слева направо), возвращая одно результирующее значение.
     *
     * @param callback Функция, выполняющаяся для каждого элемента массива, принимает четыре аргумента:
     * @param callback.previousValue Аккумулятор значения, которое возвращает функция `callback` после посещения очередного элемента, либо значение `initialValue`, если оно предоставлено.
     * @param callback.currentValue Текущий обрабатываемый элемент таблицы.
     * @param callback.index Индекс текущего обрабатываемого элемента таблицы.
     * @param callback.array Таблица, по которой осуществляется проход.
     * @param initialValue Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции `callback`.
     * @typeParam U Тип возвращаемого значения.
     */
    reduce<U>(callback: (previousValue: U, currentValue: T, index: number, array: readonly T[]) => U, initialValue?: U): U;
    /**
     * Метод [[TTable.reduceRight]] применяет функцию к аккумулятору и каждому значению таблицы (справа налево), сводя его к одному значению.
     *
     * @param callback Функция, выполняющаяся для каждого элемента таблицы.
     * @param callback.previousValue Аккумулятор значения, которое возвращает функция `callback` после посещения очередного элемента, либо значение `initialValue`, если оно предоставлено.
     * @param callback.currentValue Текущий обрабатываемый элемент таблицы.
     * @param callback.index Индекс текущего обрабатываемого элемента таблицы.
     * @param callback.array Таблица, по которой осуществляется проход.
     * @param initialValue Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции `callback`.
     */
    reduceRight(callback: (previousValue: T, currentValue: T, index: number, array: readonly T[]) => T, initialValue?: T): T;
    /**
     * Метод [[TTable.reduceRight]] применяет функцию к аккумулятору и каждому значению таблицы (справа налево), сводя его к одному значению.
     *
     * @param callback Функция, выполняющаяся для каждого элемента таблицы.
     * @param callback.previousValue Аккумулятор значения, которое возвращает функция `callback` после посещения очередного элемента, либо значение `initialValue`, если оно предоставлено.
     * @param callback.currentValue Текущий обрабатываемый элемент таблицы.
     * @param callback.index Индекс текущего обрабатываемого элемента таблицы.
     * @param callback.array Таблица, по которой осуществляется проход.
     * @param initialValue Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции `callback`.
     * @typeParam U Тип возвращаемого значения.
     */
    reduceRight<U>(callback: (previousValue: U, currentValue: T, index: number, array: readonly T[]) => U, initialValue?: U): U;
    /**
     * Метод [[TTable.find]] возвращает значение первого найденного в таблице элемента, которое удовлетворяет условию, переданному в функции `predicate`. В противном случае возвращается `undefined`.
     *
     * @param predicate Функция, вызывающаяся для каждого значения в таблице.
     * @param predicate.value Текущий обрабатываемый элемент таблицы.
     * @param predicate.index Индекс текущего обрабатываемого элемента таблицы.
     * @param predicate.array Таблица, по которой осуществляется проход.
     * @param thisArg Необязательный параметр. Значение, используемое в качестве `this` при выполнении функции `predicate`.
     */
    find(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T | undefined;
    /**
     * Метод [[TTable.findIndex]] возвращает индекс в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае возвращается -1.
     *
     * @param predicate Функция, вызывающаяся для каждого значения в таблице.
     * @param predicate.value Текущий обрабатываемый элемент таблицы.
     * @param predicate.index Индекс текущего обрабатываемого элемента таблицы.
     * @param predicate.array Таблица, по которой осуществляется проход.
     * @param thisArg Необязательный параметр. Значение, используемое в качестве `this` при выполнении функции `predicate`.
     */
    findIndex(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): number;
    /**
     * Returns an iterable of key, value pairs for every entry in the array
     *
     * @ignore
     */
    entries(): IterableIterator<[number, T]>;
    /**
     * Returns an iterable of keys in the array
     *
     * @ignore
     */
    keys(): IterableIterator<number>;
    /**
     * Returns an iterable of values in the array
     *
     * @ignore
     */
    values(): IterableIterator<T>;
}
/**
 * # Описание поля типа [[TTable]]
 */
interface TableField<Row extends ItemData, Result extends ItemData> {
    /**
     * Метод [[TableField.create]] позволяет создавать новый экземпляр таблицы.
     *
     * ```typescript
     * const table = Context.fields.table.create();
     * ```
     */
    create(): TTable<Row, Result>;
    /**
     * Описание полей таблицы.
     */
    readonly fields: Readonly<{
        [K in keyof Row]: StaticFieldType<Row[K]>;
    }>;
    /**
     * @ignore
     */
    readonly name: string;
    /**
     * @ignore
     */
    readonly type: string;
}
/**
 * # Объект-ссылка на элемент произвольного Приложения
 *
 * Объекты-ссылки, как правило, используются в свойствах типа Приложение,
 * чтобы не загружать сразу весь элемент и все его данные.
 *
 * При помощи метода [[RefItem.fetch]] можно получить элемент Приложения, на который указывает объект-ссылка.
 * Если элемент Приложения не будет найден, то вызов метода вернет ошибку, которую следует корректно обработать.
 * Пример кода:
 * ```typescript
 * let appItem: any;
 * try {
 *     appItem = await Context.data.any_app.fetch();
 * } catch (err) {
 *     // Тут должна быть обработка ошибки получения элемента приложения
 *     // Ошибка может возникнуть, например, если элемент, на который ссылатся объект типа `RefItem`, не найден
 * }
 * ```
 *
 * Объект-ссылку можно создать, используя конструктор:
 * ```typescript
 * const refItem = new RefItem(namespace, code, id);
 * ```
 * Где:
 *
 * — `namespace` — код Раздела;
 *
 * — `code` — код Приложения;
 *
 * — `id` — уникальный идентификатор элемента.
 *
 * Если точно известно Приложение, на элемент которого указывает объект-ссылка, то в конструкторе можно явно указать тип целевого элемента:
 * ```typescript
 * // Объект-ссылка, которая указывает на элемент типа Пользователь
 * const refUserItem = new RefItem<UserItem>('system', 'users', userId);
 * ```
 */
interface RefItem<I extends Item<ItemData> = any> {
    /**
     * Пространство имен цели ссылки (код раздела приложения).
     */
    readonly namespace: string;
    /**
     * Код приложения цели ссылки (код приложения).
     */
    readonly code: string;
    /**
     * Идентификатор цели ссылки.
     */
    readonly id: string;
    /**
     * Запрос полных данных элемента произвольного приложения.
     *
     * ```typescript
     * const any_app_full = await Context.data.any_app.fetch();
     * ```
     */
    fetch(): Promise<I>;
}
/**
 * # Ссылка на элемент произвольного приложения
 *
 * @ignore
 */
declare type TRefItem = RefItem;
/**
 * @ignore
 */
interface RefItemConstructor {
    new <I extends Item<ItemData> = any>(namespace: string, code: string, id: string): RefItem<I>;
}
/**
 * @ignore
 */
declare const RefItem: RefItemConstructor;
/**
 * @ignore
 */
interface StaticRefItemField {
}
/**
 * @ignore
 */
interface RefItemField extends StaticRefItemField {
    readonly name: string;
    readonly type: string;
}
/**
 * # Аргументы объекта ошибки [[ErrorObject]]
 */
interface ErrorArgs {
    /**
     * Машиночитаемый код ошибки.
     */
    readonly code: string;
}
/**
 * # Объект ошибки
 *
 * Используется как результат в некоторых методах работы с сервером.
 */
interface ErrorObject {
    /**
     * Путь к источнику ошибки.
     */
    readonly path: string;
    /**
     * Текстовое описание ошибки.
     */
    readonly desc: string;
    /**
     * Уровень ошибки.
     */
    readonly level: string;
    /**
     * Дополнительные аргументы.
     */
    readonly args: ErrorArgs;
}
/**
 * # Типы элементов организационной структуры
 *
 * Используются при создании и поиске элементов организационной структуры.
 * ```typescript
 * // Создание
 * const item = System.organisationStructure.createItem('Директор по маркетингу', OrganisationStructureItemType.Position);
 * // Поиск
 * const searchResult = tree.getRoot().find(i => i.data.name === 'Менеджеры' && i.data.type === OrganisationStructureItemType.Group);
 * ```
 */
declare enum OrganisationStructureItemType {
    /**
     * # Должность
     */
    Position = "POSITION",
    /**
     * # Отдел
     */
    Department = "DEPARTMENT",
    /**
     * # Группа
     */
    Group = "GROUP"
}
/**
 * @ignore
 */
declare type Type = TString | TFloat | TBoolean | TDatetime | TCategory<ItemData> | TMoney<CurrencyCode> | TFile | TPhone<PhoneType> | TAccount<AccountType> | TEmail<EmailType> | TImage | TStatus<string, ItemData> | TUser | TApplication<ItemData, ItemData, Processes> | TFullName | TLink | TEnum<string> | TJSON | TTable<ItemData, ItemData> | TRefItem | TRole | TOAuth2;
/**
 * @ignore
 */
declare type FieldType<T extends Type | Type[]> = T extends TString | TString[] ? StringField : T extends TFloat | TFloat[] ? FloatField : T extends TBoolean | TBoolean[] ? BooleanField : T extends TDatetime | TDatetime[] ? DatetimeField : T extends TDate | TDate[] ? DatetimeField<TDate> : T extends TTime | TTime[] ? DatetimeField<TTime> : T extends TCategory<infer C> | TCategory<infer C>[] ? CategoryField<C> : T extends TMoney<infer CC> | TMoney<infer CC>[] ? MoneyField<CC> : T extends TFile | TFile[] ? FileField : T extends TPhone<infer P> ? PhoneFieldTyped<P> : T extends TPhone<PhoneType>[] ? PhoneFieldVoid : T extends TAccount<infer A> ? AccountFieldTyped<A> : T extends TAccount<AccountType>[] ? AccountFieldVoid : T extends TEmail<infer E> ? EmailFieldTyped<E> : T extends TEmail<EmailType>[] ? EmailFieldVoid : T extends TImage | TImage[] ? ImageField : T extends TStatus<infer S, infer SS> | TStatus<infer S, infer SS>[] ? StatusField<S, SS> : T extends TUser | TUser[] ? UserField : T extends TApplication<infer D, infer DD, infer DDD> | TApplication<infer D, infer DD, infer DDD>[] ? ApplicationField<D, DD, DDD> : T extends TFullName | TFullName[] ? FullNameField : T extends TLink | TLink[] ? LinkField : T extends TEnum<infer K> | TEnum<infer K>[] ? EnumField<K> : T extends TTable<infer L, infer LL> ? TableField<L, LL> : T extends TRefItem | TRefItem[] ? RefItemField : T extends TRole | TRole[] ? RoleField : T extends TJSON | TJSON[] ? JSONField : never;
/**
 * @ignore
 */
declare type StaticFieldType<T extends Type | Type[]> = T extends TString | TString[] ? StringField : T extends TFloat | TFloat[] ? FloatField : T extends TBoolean | TBoolean[] ? BooleanField : T extends TDatetime | TDatetime[] ? DatetimeField : T extends TDate | TDate[] ? DatetimeField<TDate> : T extends TTime | TTime[] ? DatetimeField<TTime> : T extends TCategory<infer C> | TCategory<infer C>[] ? StaticCategoryField<C> : T extends TMoney<infer CC> | TMoney<infer CC>[] ? MoneyField<CC> : T extends TFile | TFile[] ? StaticFileField : T extends TPhone<infer P> ? PhoneFieldTyped<P> : T extends TPhone<PhoneType>[] ? PhoneFieldVoid : T extends TAccount<infer A> ? AccountFieldTyped<A> : T extends TAccount<AccountType>[] ? AccountFieldVoid : T extends TEmail<infer E> ? EmailFieldTyped<E> : T extends TEmail<EmailType>[] ? EmailFieldVoid : T extends TImage | TImage[] ? StaticImageField : T extends TStatus<infer S, infer SS> | TStatus<infer S, infer SS>[] ? StatusField<S, SS> : T extends TUser | TUser[] ? StaticUserField : T extends TApplication<infer D, infer DD, infer DDD> | TApplication<infer D, infer DD, infer DDD>[] ? StaticApplicationField<D, DD, DDD> : T extends TFullName | TFullName[] ? FullNameField : T extends TLink | TLink[] ? LinkField : T extends TEnum<infer K> | TEnum<infer K>[] ? EnumField<K> : T extends TTable<infer L, infer LL> ? TableField<L, LL> : T extends TRefItem | TRefItem[] ? StaticRefItemField : T extends TRole | TRole[] ? StaticRoleField : T extends TJSON | TJSON[] ? JSONField : never;
/**
 * # Тип данных для поля динамической привязки
 *
 * Подробнее читайте в [[DynamicBindingField]].
 */
declare enum DynamicFieldType {
    /**
     * # Строка
     */
    String = "STRING",
    /**
     * # Дробное число
     */
    Float = "FLOAT",
    /**
     * # Булево (Да/Нет)
     */
    Boolean = "BOOLEAN",
    /**
     * # Дата/время
     */
    Datetime = "DATETIME",
    /**
     * # Категория элементов приложения (папка)
     */
    Category = "CATEGORY",
    /**
     * # Деньги
     */
    Money = "MONEY",
    /**
     * # Файл
     */
    File = "FILE",
    /**
     * # Телефон
     */
    Phone = "PHONE",
    /**
     * # Учетная запись
     */
    Account = "ACCOUNT",
    /**
     * # Почта
     */
    Email = "EMAIL",
    /**
     * # Изображение
     */
    Image = "IMAGE",
    /**
     * # Поле типа Статус
     */
    Status = "STATUS",
    /**
     * # Пользователь
     */
    User = "SYS_USER",
    /**
     * # Приложение
     */
    Application = "SYS_COLLECTION",
    /**
     * # Тип ФИО
     */
    FullName = "FULL_NAME",
    /**
     * # Ссылка
     */
    Link = "LINK",
    /**
     * # Перечисление (выпадающий список)
     */
    Enum = "ENUM",
    /**
     * # Произвольный тип (JSON)
     */
    JSON = "JSON",
    /**
     * # Таблица
     */
    Table = "TABLE",
    /**
     * # Произвольное приложение
     */
    RefItem = "REF_ITEM"
}
/**
* # Описание поля динамической привязки
*/
interface DynamicBindingField {
    /**
     * Имя поля.
     */
    name: string;
    /**
     * Тип поля.
     */
    type: DynamicFieldType;
    /**
     * Дополнительные параметры поля.
     *
     * Значение зависит от типа поля.
     */
    settings?: any;
    /**
     * Поле может принимать данные при биндинге (входящее).
     */
    input?: boolean;
    /**
     * Поле может быть источником данных при биндинге (исходящее).
     */
    output?: boolean;
}
/**
 * # Поля динамического биндинга
 */
interface DynamicBindingFields {
    [code: string]: DynamicBindingField;
}
/**
 * # Типы статусов переносимого сервиса модуля
 */
declare enum ServiceStatus {
    /**
     * # Статус сервиса не определен
     */
    Undefined = 0,
    /**
     * # Сервис остановлен
     */
    Stop = 1,
    /**
     * # Сервис находится в процессе смены статуса
     */
    Processing = 2,
    /**
     * # Сервис готов к работе
     */
    Ready = 3,
    /**
     * # При запуске сервиса произошла ошибка
     */
    Error = 4
}
/**
 * # Объект информации о статусе переносимого сервиса модуля
 *
 * Получить информацию можно в любом серверном сценарии модуля.
 *
 * ```
 * const status = await Namespace.services.myService.status();
 * ```
 */
interface ServiceStatusInfo {
    /**
     * Статус переносимого сервиса.
     */
    status: ServiceStatus;
}
/**
 * # Глобальные константы
 *
 * Подробное описание читайте в [статье про глобальные константы](../pages/quick-start/intro_globals.html).
 * @packageDocumentation
 */
/**
 * # Объект приложения
 *
 * Объект приложения доступен в бизнес-процессах и виджетах,
 * которые находятся на уровне приложения.
 * [[Application]] предоставляет методы и данные для работы с текущим приложением.
 */
interface Application<T extends ItemData, P extends ItemData, S extends Processes> {
    /**
     * Метод [[create]] создает новый элемент приложения.
     *
     * После создания и заполнения полей элемент необходимо сохранить с помощью метода
     * [[ApplicationItem.save]].
     *
     * ```typescript
     * const item = Application.create();
     * item.data.__name = Context.data.request_subject;
     * await item.save();
     * ```
     */
    create(): ApplicationItem<T, P>;
    /**
     * Метод [[search]] позволяет выполнить поиск по элементам приложения.
     *
     * Подробнее о поиске по элементам приложения можно прочитать в
     * [этой статье](../pages/quick-start/intro_apps.html#3).
     */
    search(): ApplicationSearch<T, P>;
    /**
     * Метод [[getPermissions]] возвращает права доступа, установленные для данного приложения.
     *
     * Подробнее о работе метода в [[ApplicationItem.getPermissions]].
     */
    getPermissions(): Promise<TPermissionsSettings>;
    /**
     * Метод [[hasPermission]] проверяет наличие права доступа для пользователя, группы, элемента оргструктуры, роли.
     *
     * @param orgunit Пользователь, группа, элемент оргструктуры или роль, которым выданы права.
     * @param type Уровень прав.
     *
     * Подробнее о работе метода в [[ApplicationItem.hasPermission]].
     */
    hasPermission(orgunit: TPermissionOrgunit, type: PermissionType): Promise<boolean>;
    /**
     * Метод [[setPermissions]] устанавливает новые права на элемент приложения.
     *
     * Подробнее о работе метода в [[ApplicationItem.setPermissions]].
     */
    setPermissions(permissions: TPermissions): Promise<void>;
    /**
     * Возвращает настройки, установленные для данного приложения.
     *
     * ```typescript
     * const settings = await Application.getSettings();
     *
     * // Включена ли регистрация
     * const on_registry = settings.registrationSettings.enabled
     *
     * // Список ID дел, в которых доступна регистрация для данного приложения
     * const nomIDs = settings.registrationSettings.nomenclatureIds
     *
     * // Возвращает список дел, доступных для данного приложения
     * const nomenclatures = settings.registrationSettings.getNomenclatures();
     * ```
     */
    getSettings(): Promise<TSettings>;
    /**
     * Описание полей приложения.
     */
    readonly fields: Readonly<{
        [K in keyof (Based<T>)]: StaticFieldType<(Based<T>)[K]>;
    }>;
    /**
     * Название приложения.
     */
    readonly name: string;
    /**
     * Процессы приложения.
     *
     * Подробнее о возможностях в [[Processes]].
     */
    readonly processes: S;
    /**
     * Кэш для временного хранения данных на сервере, изолированный в приложении.
     */
    readonly cache: ICache;
    /**
     * Хранилище для долговременного хранения произвольных строковых данных на сервере, изолированное в приложении.
     */
    readonly storage: IStorage;
    /**
     * Метод [[statusHistory]] позволяет выполнить поиск по истории изменений статусов экземпляров приложения.
     *
     * Метод возвращает объект [[StatusHistorySearch]], который поддерживает
     * фильтрацию и сортировку результатов поиска.
     *
     * ```typescript
     * // Получим историю переходов в статус «Сделано» (done)
     * // за последний день
     * const today = new Datetime();
     * const yesterday = today.addDate(0, 0, -1);
     * const changes = Application.statusHistory()
     *     .where((f, g) => g.and(
     *         f.__createdAt.gte(yesterday),
     *         f.target.eq(Application.fields.__status.variants.done.id),
     *     ))
     *     .all();
     *
     * // Получим полные данные всех элементов,
     * // статус которых изменился на «Сделано» (done)
     * const items = await Promise.all(changes.map(change => change.data.item!.fetch()));
     * ```
     */
    statusHistory(): StatusHistorySearch<T, P>;
    /**
     * Нумератор в приложении.
     */
    readonly serial: Serial;
    /**
     * Метод получает массив папок на уровне приложения (первого уровня вложенности).
     *
     * В примере метод позволяет получить все папки приложения.
     *
     * ```typescript
     * const folders = await Application.getFolders();
     * ```
     * @returns Папки на уровне приложения.
     */
    getFolders(): Promise<TFolder[]>;
    /**
     * Метод создаёт новую папку на уровне приложения (1-й уровень вложенности).
     *
     * В примере с помощью метода мы создаём новую папку в приложении.
     *
     * ```typescript
     * const folder = await Application.createFolder('name');
     * ```
     * @param name Имя создаваемой папки.
     */
    createFolder(name: string): Promise<TFolder>;
}
/**
 * # Объект приложения c дополнительными параметрами
 *
 * Используется в серверных сценариях.
 */
interface ApplicationWithParams<P extends ItemData> {
    /**
     * Дополнительные параметры приложения.
     *
     * Доступны только в серверных сценариях.
     */
    readonly params: ParamsItem<P>;
}
/**
 * # Объект системного приложения профилей внешних пользователей
 *
 * Используется для работы с профилями пользователей в порталах.
 *
 * Профиль как отдельное приложение позволяет хранить дополнительную
 * информацию о внешнем пользователе и использовать это приложение для организации
 * сложных взаимодействий и процессов на портале.
 */
interface ApplicationUserProfile<T extends ItemData, P extends ItemData> {
    /**
     * Заблокировать профиль внешнего пользователя.
     *
     * ```typescript
     * const profile = Context.data.vneshniy_polzovatel;
     * if (profile) {
     *     await Global.ns._system_catalogs.app._user_profiles.block(profile);
     * }
     * ```
     *
     * Если передать в параметр `item` элемент другого приложения, то будет возвращена ошибка.
     * @param item Элемент системного приложения «Внешние пользователи».
     */
    block(item: ApplicationItemRef<T, P>): Promise<void>;
    /**
     * Разблокировать профиль внешнего пользователя.
     *
     * ```typescript
     * const profile = Context.data.vneshniy_polzovatel;
     * if (profile) {
     *     await Global.ns._system_catalogs.app._user_profiles.unblock(profile);
     * }
     * ```
     *
     * Если передать в параметр `item` элемент другого приложения, то будет возвращена ошибка.
     * @param item Элемент системного приложения «Внешние пользователи».
     */
    unblock(item: ApplicationItemRef<T, P>): Promise<void>;
    /**
     * Получить аккаунт внешнего пользователя по его профилю.
     *
     * ```typescript
     * const profile = Context.data.vneshniy_polzovatel;
     * if (profile) {
     *     const user = await Global.ns._system_catalogs.app._user_profiles.getUser(profile);
     * }
     * ```
     *
     * Если передать в параметр `item` элемент другого приложения, то будет возвращена ошибка.
     * @param item Элемент системного приложения «Внешние пользователи».
     */
    getUser(item: ApplicationItemRef<T, P>): Promise<UserItem | undefined>;
    /**
     * Получить профиль внешнего пользователя по его учетной записи.
     *
     * ```typescript
     * const user = Context.data.__createdBy;
     * if (user) {
     *     const portal_profile = await Global.ns._system_catalogs.app._user_profiles.getByUser(user);
     * }
     * ```
     *
     * @param user Системная учетная запись пользователя.
     * @returns Профиль внешнего пользователя или `undefined`, если профиль не привязан.
     */
    getByUser(user: UserItem): Promise<ApplicationItemRef<T, P> | undefined>;
}
/**
 * # Объект проекта
 *
 * Используется для методов, доступных только в контексте приложения «Проекты».
 *
 * Пример использования в сценарии бизнес-процесса в разделе «Проекты»:
 * ```typescript
 * const project = Context.data.project;
 * if (project) {
 *     await Namespace.app._project.initByTemplate(project);
 * }
 * ```
 */
interface ApplicationProject<T extends ItemData, P extends ItemData> {
    /**
     * Инициализировать проект начальными данными по шаблону. Используется в системном бизнес-процессе «Генерация по шаблону».
     *
     * ```typescript
     * const project = Context.data._project;
     * if (project) {
     *     await Application.initByTemplate(project);
     * }
     * ```
     * @param item Ссылка на элемент приложения «Проекты».
     */
    initByTemplate(item: ApplicationItemRef<T, P>): Promise<void>;
    /**
     * Отправить проект в архив. Меняет стадию проекта на «В архиве» и закрывает все проектные задачи.
     * ```typescript
     * const projectApp = Context.fields._project.app;
     * const project = Context.data._project;
     * await projectApp.archive(project);
     * ```
     * @param item Элемент приложения «Проекты».
     */
    archive(item: ApplicationItemRef<T, P>): Promise<void>;
    /**
     * Восстановить проект из архива. Меняет стадию проекта на «Черновик».
     * ```typescript
     * const projectApp = Context.fields._project.app;
     * const project = Context.data._project;
     * await projectApp.restore(project);
     * ```
     * @param item Элемент приложения «Проекты»
     */
    restore(item: ApplicationItemRef<T, P>): Promise<void>;
}
/**
 * @ignore
 */
interface Category<C extends ItemData> {
    create(): CategoryItem<C>;
    search(): CategorySearch<C>;
}
/**
 * # Объект пользователей
 *
 * Используется для поиска по пользователям, создания новых пользователей,
 * получения текущего пользователя и запроса восстановления пароля.
 */
interface Users {
    /**
     * Метод [[Users.search]] позволяет выполнить поиск пользователей.
     *
     * Для выборки элементов коллекций используется объект [[Search]]:
     * ```typescript
     * const users = await System.users.search()
     *     .where(f => f.email.eq("email@example.com"))
     *     .all();
     * ```
     *
     * Пример поиска по статусу пользователя:
     * ```typescript
     * const users = await System.users.search()
     *     .where(u => u.__status.eq(UserStatus.Blocked))
     *     .all();
     * ```
     *
     * Подробнее об использовании объекта поиска можно узнать
     * в статье [Работа с приложениями](../pages/quick-start/intro_apps.html#3).
     */
    search(): UserSearch;
    /**
     * Метод [[Users.create]] позволяет инициализировать нового пользователя.
     *
     * Для новых пользователей обязательным параметром является `email`.
     * После заполнения данных нового пользователя его необходимо сохранить
     * с помощью метода [[UserItem.save]].
     *
     * ```typescript
     * const newUser = System.users.create();
     * newUser.data.email = 'mail@example.com';
     * await newUser.save()
     * ```
     */
    create(): UserItem;
    /**
     * Метод [[Users.getCurrentUser]] позволяет получить текущего пользователя.
     *
     * ```typescript
     * const currentUser = await System.users.getCurrentUser();
     * ```
     */
    getCurrentUser(): Promise<CurrentUserItem>;
    /**
     * Метод [[Users.requestPasswordRecovery]] генерирует новую ссылку на восстановление пароля пользователя
     *
     * и отправляет эту ссылку на email, переданный в качестве параметра.
     *
     * @param email Email пользователя, на который будет отправлена ссылка.
     * ```typescript
     * const currentUser = await System.users.getCurrentUser();
     * const email = currentUser.data.email;
     * await System.users.requestPasswordRecovery(email);
     * ```
     */
    requestPasswordRecovery(email: string): Promise<void>;
    /**
     * Метод [[createWithAuthData]] позволяет инициализировать нового пользователя в активном статусе с заполненными параметрами OAuth2.
     *
     * Для новых пользователей обязательным параметром является email.
     * После заполнения данных нового пользователя его необходимо сохранить
     * с помощью метода [[UserItem.save]].
     *
     * ```typescript
     * const oauth2Record: OAuth2Record = {externalId: "someId", providerId: "someId"};
     * const authData: AuthData = {oauth2: [oauth2Record]};
     * const newUser = System.users.createWithAuthData(authData);
     * newUser.data.email = 'mail@example.com';
     * await newUser.save()
     * ```
     */
    createWithAuthData(authData: AuthData): UserItem;
    /**
     * Метод [[addOAuth2Data]] добавляет способ аутентификации OAuth2 для пользователя.
     *
     * ```typescript
     * const user = await System.users.search().where(f => f.email.eq('mail@example.com')).first();
     * const oauth2Record: OAuth2Record = {externalId: "someId", providerId: "someId"};
     * await System.users.addOAuth2Data(user, oauth2Record);
     * ```
     */
    addOAuth2Data(user: UserItemRef, oauth2Data: TOAuth2): Promise<void>;
    /**
 * Метод [[removeOAuth2Data]] удаляет способ аутентификации OAuth2 у пользователя.
 *
 * ```typescript
 * const user = await System.users.search().where(f => f.email.eq('mail@example.com')).first();
 * const oauth2Record: OAuth2Record = {externalId: "someId", providerId: "someId"};
 * await System.users.removeOAuth2Data(user, oauth2Record);
 * ```
 */
    removeOAuth2Data(user: UserItemRef, oauth2Data: TOAuth2): Promise<void>;
}
/**
 * # Объект группы пользователей
 *
 * Используется для поиска по группам пользователей и для добавления новых групп.
 */
interface UserGroups {
    /**
     * Метод [[UserGroups.search]] позволяет выполнить поиск групп пользователей.
     *
     * Для выборки элементов коллекций используется объект [[Search]]:
     * ```typescript
     * const groups = await System.userGroups.search()
     *     .where(f => f.isRole.eq(true))
     *     .all();
     * ```
     *
     * Подробную информацию об использовании объекта поиска можно найти
     * в статье [Работа с приложениями](../pages/quick-start/intro_apps.html#3).
     */
    search(): UserGroupSearch;
    /**
     * Метод [[UserGroups.create]] создаёт новую группу пользователей.
     *
     * Для сохранения группы используется метод [[UserGroupItem.save]]:
     * ```typescript
     * const newGroup = System.userGroups.create();
     * newGroup.data.__name = 'Руководители';
     * await newGroup.save();
     * ```
     * Если обязательное поле __name не будет заполнено, сценарий вернет
     * ошибку вида:
     * *Error: field /__name is required;*
     */
    create(): UserGroupItem;
}
/**
 * # Объект организационной структуры
 *
 * Используется для получения текущей организационной структуры в виде дерева, для создания нового дерева организационной структуры
 * или ее нового элемента, а также для сохранения заданного дерева в качестве текущей оргструктуры.
 *
 * ```typescript
 * const tree = await System.organisationStructure.fetchTree();
 *
 * const newItem = System.organisationStructure.createItem('Директор по маркетингу', OrganisationStructureItemType.Position);
 *
 * tree.getRoot().addChild(newItem);
 * const errs = await tree.validate();
 * if (errs.length === 0) {
 *     // Валидация успешна
 *     const sErrs = await System.organisationStructure.save(tree);
 * }
 * ```
 */
interface OrganisationStructure {
    /**
     * Метод [[OrganisationStructure.fetchTree]] позволяет загрузить дерево текущей организационной структуры.
     *
     * ```typescript
     * const tree = await System.organisationStructure.fetchTree();
     * ```
     */
    fetchTree(): Promise<OrganisationStructureTree>;
    /**
     * Метод [[OrganisationStructure.createTree]] позволяет создать новое дерево организационной структуры.
     *
     * @param rootName Название должности корневого элемента.
     * ```typescript
     * const tree = System.organisationStructure.createTree('Генеральный директор');
     * ```
     * В результате будет создано дерево с единственным элементом — корневым.
     */
    createTree(rootName: string): OrganisationStructureTree;
    /**
     * Метод [[OrganisationStructure.createItem]] позволяет создать новый элемент организационной структуры.
     *
     * @param name Название создаваемого элемента.
     * @param type Тип создаваемого элемента.
     * ```typescript
     * const item = System.organisationStructure.createItem('Директор по развитию', OrganisationStructureItemType.Position);
     * ```
     */
    createItem(name: string, type: OrganisationStructureItemType): OrganisationStructureItem;
    /**
     * Метод [[OrganisationStructure.save]] позволяет сохранить заданное дерево в качестве текущей организационной структуры.
     *
     * Перед сохранением организационная структура будет автоматически провалидирована.
     * @param tree Сохраняемое дерево.
     * ```typescript
     * const errs = await System.organisationStructure.save(tree);
     * if (errs.length === 0) {
     *      // Успешно сохранено
     * }
     * В случае если сохранение не было выполнено, метод возвращает массив с ошибками.
     * При успешном сохранении возвращается пустой массив.
     * ```
     */
    save(tree: OrganisationStructureTree): Promise<ErrorObject[]>;
    /**
     * Метод [[OrganisationStructure.search]] позволяет выполнять поиск по оргструктуре.
     *
     * С помощью данного метода можно фильтровать, выводить результаты начиная с определенного элемента, ограничивать выборку,
     * сортировать, получать первый элемент и страницу результатов.
     *
     * Пример использования:
     * ```typescript
     * const position = await System.organisationStructure.search().where(position => position.name.eq('Генеральный директор')).first();
     * ```
     */
    search(): OrganisationStructureSearch;
}
/**
 * # Объект дерева организационной структуры
 *
 * Представляет организационную структуру в виде дерева. Используется для получения корневого элемента организационной
 * структуры, для поиска элемента по имени, а также для валидации дерева организационной структуры.
 *
 * Тип не имеет конструктора. Создать новый элемент можно с помощью метода [[OrganisationStructure.createTree]]:
 * ```typescript
 * const tree = System.organisationStructure.createTree('Генеральный директор');
 * ```
 * Текущее дерево организационной структуры можно загрузить с помощью метода [[OrganisationStructure.fetchTree]]:
 * ```typescript
 * const tree = await System.organisationStructure.fetchTree();
 *
 * const newItem = System.organisationStructure.createItem('Директор по маркетингу', OrganisationStructureItemType.Position);
 *
 * tree.getRoot().addChild(newItem);
 * const errs = await tree.validate();
 * if (errs.length === 0) {
 *     // Валидация успешна
 * }
 * ```
 */
interface OrganisationStructureTree {
    /**
     * Метод [[OrganisationStructureTree.getRoot]] позволяет получить корневой элемент организационной структуры.
     *
     * ```typescript
     * const tree = await System.organisationStructure.fetchTree();
     * const root = tree.getRoot();
     * ```
     */
    getRoot(): OrganisationStructureItem;
    /**
     * Метод [[OrganisationStructureTree.find]] производит поиск элемента организационной структуры по названию.
     *
     * Будет возвращен первый найденный элемент или undefined, если такого элемента нет.
     * @param name Название элемента.
     * ```typescript
     * const item = tree.find('Отдел снабжения');
     * if (item === undefined) {
     *     // Элемент не найден
     * }
     * ```
     */
    find(name: string): OrganisationStructureItem | undefined;
    /**
     * Метод [[OrganisationStructureTree.validate]] проводит валидацию организационной структуры.
     *
     * ```typescript
     * const errs = await tree.validate();
     * if (errs.length === 0) {
     *      // Валидация успешна
     * }
     * ```
     * В случае если валидация не пройдена, метод возвращает массив с ошибками.
     * При успешной валидации возвращается пустой массив.
     */
    validate(): Promise<ErrorObject[]>;
}
/**
 * # Файлы
 *
 * Объект для работы с файлами.
 * С помощью данного класса возможно выполнять поиск по файлам и создание временных файлов.
 */
interface Files {
    /**
     * Метод выполняет поиск по файлам, хранимым на диске.
     *
     * Используя метод, можно:
     *
     * * фильтровать файлы, используя различные параметры;
     *
     * * искать и получать конкретный или первый элемент из выборки;
     *
     * * сортировать результаты поиска;
     *
     * * ограничивать количество результатов или получать найденные элементы постранично.
     *
     * Пример использования:
     * ```typescript
     * const position = await System.files.search().where(f => f.__id.eq('<some id>')).first();
     * ```
     *
     * @returns Объект для построения запроса по поиску файла.
     */
    search(): FilesSearch;
    /**
     * Метод создает временный файл.
     *
     * Вы можете временно загрузить файл в систему, чтобы использовать его в процессе или приложении.
     * В случае если файл не будет использован в течение 60 минут, он будет автоматически удален.
     *
     * В примере показано, как создать файл, имея некоторое содержимое файла, представленное в виде массива байтов.
     * В контексте хранится `newName` — новое имя файла.
     *
     * ```typescript
     * const fileData: ArrayBuffer;
     * // ...
     * const newTmpFile = await System.files.createTemporary(Context.data.newName, fileData);
     * ```
     *
     * @param name Имя нового файла.
     * @param body Тело файла в виде массива байтов.
     *
     * @returns Модель временного файла.
     */
    createTemporary(name: string, body: ArrayBuffer): Promise<FileItem>;
}
/**
 * # Директория с файлами
 *
 * Объект предназначен для работы с файловыми директориями. Он позволяет выполнять следующие операции над
 * директориями, хранимыми на диске: поиск; получение директорий внутри директории, родительских и дочерних директорий разного уровня;
 * создание новых директорий и удаление существующих; получение файлов, находящихся в директории.
 */
interface Directories {
    /**
    * Метод выполняет поиск по директориям, хранимым на диске.
    *
    * Используя метод, можно:
    *
    * * фильтровать директории, используя различные параметры;
    *
    * * искать и получать конкретный или первый элемент из выборки;
    *
    * * сортировать результаты поиска;
    *
    * * ограничивать количество результатов или получать найденные элементы постранично.
    *
    * ```typescript
    *    //Пример получения директорий, созданных пользователем (some user_id)
    *    const position = await System.directories.search().where(d => d.__createdBy.eq('<some id>')).all();
    * ```
    *
    * @returns Объект для построения запроса по поиску директории.
    */
    search(): DirectoriesSearch;
    /**
     * Метод создает новую директорию.
     *
     * ```typescript
     * //Пример создания новой директории
     * const name = "Имя новой директории";
     * const parentId = "8c110182-b022-5f31-ac3d-290fdc1d4fe1";
     *
     * const newDirectory = await System.directories.create(name, parentId);
     * ```
     * @param name: string Имя новой дирекории.
     * @param parentId: string ID директории родителя.
     * @returns Объект директории.
     */
    create(name: string, parentId: string): Promise<DirectoryItem>;
    /**
     * Метод удаляет директорию по ID.
     *
     * ```typescript
     *    //Пример удаления всех директорий, созданных пользователем (some user_id)
     *    const searchDirs = await System.directories.search().where(di => di.__createdBy.eq('<some id>')).all();
     *    for (let i = 0; i < searchDirs.length; i += 1) {
     *      await System.directories.delete(searchDirs[i].id);
     *    }
     * ```
     * @param directoryId ID директории.
     * @returns Статус ответа.
     */
    delete(directoryId: string): Promise<number>;
    /**
     * Метод получает родительские директории.
     *
     * ```typescript
     *    // Пример формирования пути до директории на основе полученных данных о родительских директориях
     *    const parents = await System.directories.getParents(idDir);
     *
     *    let pathDir: string = "/";
     *
     *    parents.forEach(dir => {
     *      pathDir = pathDir + dir.data.__name + "/"
     *    });
     * ```
     * @param directoryId ID директории.
     * @returns Массив объектов родительских директорий.
     */
    getParents(directoryId: string): Promise<DirectoryItem[]>;
    /**
     * Метод получает все дочерние директории.
     *
     * ```typescript
     *    //Пример удаления всех дочерних директорий
     *    const childsDir = await System.directories.getChildrens(idDir);
     *    childsDir.forEach(async dir => await dir.delete()); // удалим все дочерние директории
     * ```
     * @param directoryId ID директории.
     * @returns Массив объектов дочерних директорий.
     * @deprecated Метод устаревший, избегайте его использования.
     */
    getChildrens(directoryId: string): Promise<DirectoryItem[]>;
    /**
     * Метод получает все дочерние директории.
     *
     * ```typescript
     *    //Пример удаления всех дочерних директорий
     *    const childsDir = await System.directories.getChildren(idDir);
     *    childsDir.forEach(async dir => await dir.delete()); // удалим все дочерние директории
     * ```
     * @param directoryId ID директории.
     * @returns Массив объектов дочерних директорий.
     */
    getChildren(directoryId: string): Promise<DirectoryItem[]>;
    /**
     * Метод получает файлы из директории.
     *
     * ```typescript
     *     //Пример получения ссылок на файлы в директории
     *     const idDir = "8c110182-b022-5f31-ac3d-290fdc1d4fe1"
     *
     *    const filesInDir = await System.directories.getFiles(idDir);
     *    filesInDir.forEach(file => file.getDownloadUrl());
     * ```
     * @param directoryId ID директории.
     * @returns Массив объектов файлов из директории.
     */
    getFiles(directoryId: string): Promise<FileItem[]>;
    /**
     * Метод получает папки в директории первого уровня вложенности.
     *
     * ```typescript
     *    // Пример использования: получим все файлы в дочерних директориях
     *    const dirsInDir = await System.directories.getDirs(idDir);
     *    let allFilesInAllDirs :FileItem[] = [];
     *
     *    const promises = dirsInDir.map(async dir => {
     *      let files = await dir.getFiles();
     *          files.forEach(async file =>{
     *              allFilesInAllDirs.push(file);
     *          })
     *    });
     *    await Promise.all(promises);
     * ```
     * @param directoryId ID директории.
     * @returns Массив объектов директорий из заданной директории.
     */
    getDirs(directoryId: string): Promise<DirectoryItem[]>;
}
/**
 * @ignore
 */
interface Disk<T extends FileData> {
}
/**
 * @ignore
 */
interface NamespaceBase<T extends Readonly<Record<string, Application<any, any, any>>>> {
    readonly app: T;
    readonly name: string;
    readonly code: string;
    readonly processes: Processes;
    /** Кэш для временного хранения данных на сервере, изолированный в Разделе (Модуле) */
    readonly cache: ICache;
    /** Хранилище для долговременного хранения данных на сервере, изолированное в Разделе (Модуле) */
    readonly storage: IStorage;
    /** Вызов доступных методов API (в модуле) */
    readonly api: Record<string, HttpApiHandler>;
    /** @ignore */
    readonly tokens: AuthTokens;
    /** Внешний портал */
    readonly portal: Portal;
}
/**
 * @ignore
 */
interface Namespace<T extends Readonly<Record<string, Application<any, any, any>>>, C extends ItemData> extends NamespaceBase<T> {
    readonly params: ParamsItem<C>;
}
/**
 * @ignore
 */
interface NamespaceWithService {
    readonly services: Services;
}
/**
 * # Данные, необходимые для авторизации пользователя по OAuth2
 *
 * @ignore
 */
interface OAuth2Record {
    /**
     * ID модуля, настроенного для работы с OAuth2 провайдером.
     */
    providerId: string;
    /**
     * ID, присвоенный пользователю OAuth2 провайдером.
     */
    externalId: string;
}
/**
 * # Доступные методы внешней авторизации
 *
 * @ignore
 */
interface AuthData {
    /**
     * Массив с настройками авторизации через OAuth2 провайдеров.
     */
    oauth2: OAuth2Record[];
}
/**
 * # Внешние порталы.
 */
interface Portals {
    /**
     * Получить портал по коду неймспейса.
     *
     * Пример использования:
     * ```typescript
     * const portal = await System.portals.get(Namespace.code);
     * ```
     *
     * @param code код неймспейса.
     */
    get(code: String): Promise<Portal | undefined>;
    /**
     * Получить список порталов компании.
     *
     * Пример использования:
     * ```typescript
     * const portals = await System.portals.list();
     * ```
     */
    list(): Promise<Portal[]>;
    /**
     * Получить список порталов доступных пользователю.
     *
     * Пример использования:
     * ```typescript
     * const user = System.users.getCurrentUser();
     * const portals = await System.portals.getAvailableForUser(user);
     * ```
     *
     * @param user
     */
    getAvailableForUser(user: UserItem): Promise<Portal[]>;
}
/**
 * # Внешний портал
 *
 * Через этот интерфейс можно работать с внешним порталом в разделе.
 */
interface Portal {
    /**
     * Код неймспейса в рамках которого создан портал.
     */
    readonly namespace: string;
    /**
     * Опубликованный портал доступен внешним пользователям.
     */
    readonly published: boolean;
    /**
     * Управление профилями пользователей.
     */
    readonly profiles: ApplicationUserProfile<ItemData, ItemData>;
    /**
     * Получить ссылку для регистрации внешнего пользователя.
     *
     * Сформировать ссылку для регистрации с подтверждением контактных данных можно следующим образом:
     * ```typescript
     * if (Context.data.user_profile) {
     *     const inviteUrl = await Namespace.portal.signupUrl(Context.data.user_profile);
     * }
     * ```
     *
     * Для формирования ссылки без подтверждения контактных данных для передачи ее доверенному лицу
     * необходимо передать параметр `withSign`:
     * ```typescript
     * if (Context.data.user_profile) {
     *     const inviteUrl = await Namespace.portal.signupUrl(Context.data.user_profile, {
     *         withSign: true
     *     });
     * }
     * ```
     *
     * Если требуется обновить ранее сформированную ссылку, необходимо передать параметр `refresh`:
     * ```typescript
     * if (Context.data.user_profile) {
     *     const inviteUrl = await Namespace.portal.signupUrl(Context.data.user_profile, {
     *         refresh: true,
     *     });
     * }
     * ```
     */
    signupUrl<D extends ItemData, P extends ItemData, S extends Processes>(item: TApplication<D, P, S>, params?: SignupUrlParams): Promise<string>;
    /**
     * Получить список страниц портала для текущего раздела.
     *
     * Пример использования:
     * ```typescript
     * const pages = await Namespace.portal.getPages();
     * ```
     */
    getPages(): Promise<PortalPageInfo[]>;
    /**
     * Добавить пользователя портала по существующему профилю с OAuth2-авторизацией.
     *
     * **Внимание:** после создания пользователя реквизиты для авторизации по OAuth2 нельзя будет изменить.
     *
     * Метод создает нового пользователя портала по профилю и добавляет пользователю реквизиты для авторизации по OAuth2.
     * На данный момент профиль может находится только в системной коллекции «Внешние пользователи» (_user_profiles).
     * Метод генерирует ошибки:
     *
     * — с кодом «400», если не переданы параметры для авторизации по OAuth2 или переданный профиль не является
     *   элементом коллекции «Внешние пользователи»;
     *
     * — с кодом «409», если уже существует пользователь с указанным email или настройками OAuth2-авторизации;
     *
     * — c кодом «412», если отсутствуют доступные лицензии портала;
     *
     * — с кодом «500» во всех остальных случаях.
     *
     * @param portalUserProfile Профиль пользователя.
     *
     * @param auth Доступные методы внешней авторизации.
     *
     * Пример использования:
     * ```typescript
     * const newPortalUser = Global.ns._system_catalogs.app._user_profiles.create();
     * newPortalUser.data.email = "user.email@email.com";
     * newPortalUser.data.fullname = <TFullName>{
     *     firstname: 'firstname',
     *     middlename: 'middlename',
     *     lastname: 'lastname',
     * };
     * await newPortalUser.save();
     * const oAuth2Records: OAuth2Record[] = [
     *     <OAuth2Record>{
     *         providerId: 'a0524184-737e-4680-a549-1e4e94c01707',
     *         externalId: 'abcd123',
     *     }
     * ]
     * const auth: AuthData = <AuthData>{
     *     oauth2: oAuth2Records,
     * }
     * await Namespace.portal.addUserWithoutConfirmation(
     *     newPortalUser,
     *     auth,
     * );
     * ```
     *
     */
    addUserWithoutConfirmation(portalUserProfile: ApplicationItemRef<ItemData, ItemData>, auth: AuthData): Promise<void>;
    /**
     * Создать пользователя портала.
     *
     * Метод создает нового пользователя портала по существующему профилю со статусом «Приглашен».
     *
     * На данный момент профиль может находится только в системной коллекции «Внешние пользователи»(_user_profiles).
     *
     * Метод генерирует ошибки:
     *
     * — с кодом «400», если переданный профиль не является элементом коллекции «Внешние пользователи»;
     *
     * — с кодом «409», если уже существует пользователь с указанным email или настройками OAuth2-авторизации;
     *
     * — c кодом «412», если отсутствуют доступные лицензии портала;
     *
     * — с кодом «500» во всех остальных случаях.
     *
     * @param portalUserProfile Профиль пользователя.
     *
     * Пример использования:
     * ```typescript
     * const newPortalUser = Global.ns._system_catalogs.app._user_profiles.create();
     * newPortalUser.data.email = "user.email@email.com";
     * newPortalUser.data.fullname = <TFullName>{
     *     firstname: 'firstname',
     *     middlename: 'middlename',
     *     lastname: 'lastname',
     * };
     * await newPortalUser.save();
     * const user = await Namespace.portal.addUserWithoutConfirmation(
     *     newPortalUser,
     * );
     * ```
     */
    addUser(portalUserProfile: ApplicationItemRef<UserProfileItemData, ItemData>): Promise<UserItem>;
    /**
     * Предоставить указанному профилю доступ в портал.
     *
     * Пример использования:
     * ```typescript
     * const user = await System.users.search().first();
     * if (user) {
     *     const profile = await Namespace.portal.profiles.getByUser(user);
     *     if (profile) {
     *         await Namespace.portal.addProfile(profile);
     *     }
     * }
     * ```
     *
     * @deprecated Используйте метод `grantAccess()`.
     */
    addProfile(portalUserProfile: ApplicationItemRef<ItemData, ItemData>): Promise<void>;
    /**
     * Предоставить указанному профилю доступ в портал.
     *
     * Пример использования:
     * ```typescript
     * const user = await System.users.search().first();
     * if (user) {
     *     const profile = await Namespace.portal.profiles.getByUser(user);
     *     if (profile) {
     *         await Namespace.portal.grantAccess(profile);
     *     }
     * }
     * ```
     */
    grantAccess(portalUserProfile: ApplicationItemRef<ItemData, ItemData>): Promise<void>;
    /**
     * Запретить указанному профилю доступ в портал.
     *
     * Пример использования:
     * ```typescript
     * const user = await System.users.search().first();
     * if (user) {
     *     const profile = await Namespace.portal.profiles.getByUser(user);
     *     if (profile) {
     *         await Namespace.portal.removeProfile(profile);
     *     }
     * }
     * ```
     *
     * @deprecated Используйте метод `denyAccess()`.
     */
    removeProfile(portalUserProfile: ApplicationItemRef<ItemData, ItemData>): Promise<void>;
    /**
     * Запретить указанному профилю доступ в портал.
     *
     * Пример использования:
     * ```typescript
     * const user = await System.users.search().first();
     * if (user) {
     *     const profile = await Namespace.portal.profiles.getByUser(user);
     *     if (profile) {
     *         await Namespace.portal.denyAccess(profile);
     *     }
     * }
     * ```
     *
     */
    denyAccess(portalUserProfile: ApplicationItemRef<ItemData, ItemData>): Promise<void>;
    /**
     * Сгенерировать ссылку в портал для mobile или desktop приложения.
     *
     * @param withAuthToken В сгенерированную ссылку будет включен короткоживущий токен аутентификации для текущего пользователя,
     * который позволяет автоматически (без дополнительной процедуры аутентификации) войти в целевой Портал.
     * (значение по умолчанию — `false`)
     *
     * Метод доступен только в клиентских сценариях.
     *
     * Пример использования:
     * ```typescript
     * const ELMAAppUrl = await Namespace.portal.generateELMAAppUrl();
     * ```
     */
    generateELMAAppUrl(withAuthToken?: boolean): Promise<string>;
}
/**
 * # Информация о странице портала
 *
 * Пример получения списка страниц портала:
 * ```typescript
 * const pages = await Namespace.portal.getPages();
 * ```
 */
interface PortalPageInfo {
    /**
     * ID страницы.
     */
    __id: TString;
    /**
     * Имя страницы.
     */
    name: TString;
    /**
     * Код страницы.
     */
    code: TString;
    /**
     * Код раздела, к которому принадлежит портал.
     */
    namespace: TString;
    /**
     * Абсолютный адрес страницы портала.
     *
     * @deprecated Используйте метод `getUrl()`.
     */
    url: TString;
    /**
     * Значение используется для сортировки страницы портала при отображении списка.
     */
    sort: number;
    /**
     * Дата создания страницы.
     */
    __createdAt: TDatetime;
    /**
     * Дата последнего обновления страницы.
     */
    __updatedAt: TDatetime;
    /**
     * Получить адрес страницы c учетом алиаса компании.
     *
     * @param absolute Вернуть абсолютный путь (значение по умолчанию — `false`).
     */
    getUrl(absolute?: boolean): TString;
}
/**
 * # Параметры для генерации ссылки регистрации пользователя
 *
 * Используются в методе [[Portal.signupUrl]].
 */
interface SignupUrlParams {
    /**
     * Сформировать ссылку без подтверждения контактных данных.
     *
     * ```typescript
     * const inviteUrl = await Namespace.portal.signupUrl(Context.data.user_profile, {
     *     withSign: true
     * });
     * ```
     *
     * Такая ссылка не требует от пользователя дополнительного подтверждения его адреса email.
     */
    withSign?: boolean;
    /**
     * Сгенерировать новый уникальный код приглашения.
     *
     * ```typescript
     * const inviteUrl = await Namespace.portal.signupUrl(Context.data.user_profile, {
     *     refresh: true
     * });
     * ```
     *
     * Старая ссылка при этом становится не активной.
     */
    refresh?: boolean;
}
/**
 * @ignore
 */
interface PortalUserInvite {
    __id: TString;
    __inviteCode: TString;
    __inviteSign: TString;
}
/**
 * # Описание метода API в модуле
 */
interface HttpApiHandler {
    /**
     * Получение ссылки для внешнего вызова метода API.
     */
    getUrl(): string;
    /**
     * Вызвать метод API.
     *
     * @param req Параметр запроса.
     *
     * ```typescript
     * const response = await Namespace.api.mymethod.call({
     *     method: 'POST',
     *     body: JSON.sringify({ data1: 1, data2: '2' })
     * });
     * ```
     */
    call(req?: FetchRequest): Promise<FetchResponse>;
}
/**
 * # Кэш для временного хранения данных на сервере
 */
interface ICache {
    /**
     * Получить значение из кэша сервера.
     *
     * @param key Ключ значения.
     * @returns Значение, сохраненное в кэше, или `null`, если ничего не найдено по ключу.
     */
    getItem(key: string): Promise<string | null>;
    /**
     * Сохранить значение в кэш на сервер.
     *
     * По умолчанию данные хранятся в кэше 30 секунд,
     * для более длительного хранения установите параметр `ttlInMs`.
     *
     * Обратите внимание, что хранение данных в кэше даже с большим сроком
     * не гарантирует их получения обратно в методе [[getItem]].
     *
     * Для надежного и долговременного хранения используйте `storage` [[IStorage]].
     *
     * ```ts
     * await Application.cache.setItem("key", JSON.stringify({ "some_key" : "some_data", "arr" : [ 1, 2, 3 ] }));
     *
     * // Далее в коде при запросе данных
     * let value = await Application.cache.getItem("key");
     * if (!value) {
     *     // Получаем исходное значение по первичным данным
     *     value = await longOperation_initDefaultValue();
     * }
     * ```
     *
     * @param key Ключ значения.
     * @param value Данные для сохранения.
     * @param ttlInMs Срок хранения в миллисекундах.
     */
    setItem(key: string, value: string, ttlInMs?: number): Promise<void>;
}
/**
 * # Хранилище для долговременного хранения произвольных строковых данных на сервере
 */
interface IStorage {
    /**
     * Получить данные по ключу с сервера.
     */
    getItem(key: string): Promise<string | null>;
    /**
     * Сохранить данные по ключу на сервер.
     *
     * Существует ограничение на размер значения: оно не должно превышать 16 мегабайт.
     *
     * ```ts
     * await Application.storage.setItem("key", JSON.stringify({ "some_key" : "some_data", "arr" : [ 1, 2, 3 ] }));
     *
     * // Далее в коде при запросе данных
     * let value = JSON.parse(await Application.storage.getItem("key"));
     * ```
     *
     * @param key Ключ значения.
     * @param value Данные для сохранения.
     */
    setItem(key: string, value: string): Promise<void>;
}
/**
 * # Получить нумератор приложения
 */
interface Serial {
    /**
     * Получить нумератор приложения.
     *
     * ```ts
     * const serial = await Application.serial.fetch()
     * ```
     */
    fetch(): Promise<SerialData>;
}
/**
 * @ignore
 */
interface Company<T extends Readonly<Record<string, NamespaceBase<any>>>, P extends Processes> {
    readonly ns: T;
    readonly processes: P;
    /** @ignore */
    readonly tokens: GlobalAuthTokens;
    /**
     * @deprecated Перенесено в System.cache, в дальнейшем это поле будет удалено.
     * @ignore
     */
    readonly cache: ICache;
}
/**
 * @ignore
 */
interface CompanyWithParams<C extends ItemData> {
    readonly params: ParamsItem<C>;
}
/**
 * # Список доступных процессов
 */
interface Processes extends Record<string, Process | (() => ProcessInstanceSearch) | (() => ProcessInstanceTaskSearch)> {
    /**
     * Метод выполняет поиск экземпляров процессов по заданным условиям.
     *
     * ```typescript
     *  const instances = await Global.processes._searchInstances().all();
     * ```
     *
     * @returns Объект для поиска экземпляров процессов.
     */
    _searchInstances: () => ProcessInstanceSearch;
    /**
     * Метод выполняет поиск задач по заданным условиям.
     *
     * Рассмотрим, как можно получить все задачи:
     * ```typescript
     * const tasks = await Global.processes._searchTasks().all();
     * ```
     *
     * @returns Объект для поиска задач.
     */
    _searchTasks: () => ProcessInstanceTaskSearch;
}
/**
 * # Объект процесса
 *
 * Служит для запуска процессов, поиска экземпляров процесса и задач по процессу.
 * [[Process.run]] запускает процесс на исполнение.
 * [[Process._searchInstances]] выполняет поиск экземпляров процесса.
 * [[Process._searchTasks]] выполняет поиск задач процесса.
 *
 * Пример запуска процесса:
 * ```typescript
 * await Global.ns._clients.app._leads.processes._call.run({})
 * ```
 */
interface Process<Context extends ProcessContext = ProcessContext> extends ProcessTemplate<Context> {
    /**
     * Метод запускает процесс на исполнение.
     *
     * При запуске процесса необходимо задать данные контекста.
     * Контекст процесса — это данные, с которыми процесс работает во время исполнения.
     *
     * Пример:
     * ```typescript
     *
     * async function runProcess(): Promise<void> {
     *     // Запись процесса moi_process в переменную processTemplate
     *     // для дальнейшего запуска
     *     const processTemplate = Global.processes.moi_process;
     *     // Номер документа получаем из контекста
     *     const documentNumber = Context.data.documentNumber;
     *     // Имя автора получаем из контекста
     *     const authorName = Context.data.authorName;
     *
     *     // Загружаем данные с помощью некоторой функици
     *     const bytesContent = await downloadDocumentFile();
     *     // Создаем временный файл в рамках системы, чтобы поместить его в контекст процесса
     *     const temprorayFile = await System.files.createTemporary('file.docx', bytesContent);
     *
     *     // Запуск процесса. В качестве аргумента передаются его входные данные,
     *     // определяемые контекстом, указанным в процессе
     *     // Формат передачи данных — объект, где в качестве ключей указываются
     *     // коды полей
     *     await processTemplate.run({
     *         authorName: authorName,
     *         documentContent: temprorayFile,
     *         documentNumber: documentNumber,
     *     });
     * }
     * ```
     *
     * @param context Начальный контекст процесса.
     * @returns Идентификатор запущенного процесса.
     */
    run(context: Context): Promise<TString>;
    /**
     * Метод выполняет поиск экземпляров процесса.
     *
     * Пример:
     * ```typescript
     * const instances = await Global.processes.my_process_1._searchInstances().all();
     * ```
     *
     * @returns Объект для поиска процессов.
     */
    _searchInstances(): ProcessInstanceSearch;
    /**
     * Метод выполняет поиск задач процесса по заданным условиям.
     *
     * Пример:
     * ```typescript
     * const tasks = await Global.processes.my_process_1._searchTasks().all();
     * ```
     *
     * @returns Объект для поиска задач.
     */
    _searchTasks(): ProcessInstanceTaskSearch;
}
/**
 * # Объект System
 *
 * Содержит доступ к системным коллекциям,
 * всегда доступен как глобальное значение в сценариях:
 *
 * ```typescript
 * const cu = await System.users.getCurrentUser();
 * ```
 */
interface SystemCollections<P extends Processes> {
    /**
     * Пользователи.
     */
    readonly users: Users;
    /**
     * Временные зоны.
     */
    timezones: TTimezones;
    /**
     * Группы пользователей.
     */
    readonly userGroups: UserGroups;
    /**
     * Организационная структура.
     */
    readonly organisationStructure: OrganisationStructure;
    /**
     * Рабочий календарь.
     */
    readonly productionSchedule: ProductionSchedule;
    /**
     * Кэш для временного хранения данных на сервере.
     */
    readonly cache: ICache;
    /**
     * Хранилище для долговременного хранения произвольных строковых данных на сервере.
     */
    readonly storage: IStorage;
    /**
     * Замещения.
     */
    readonly replacements: Replacements;
    /**
     * Файлы.
     */
    readonly files: Files;
    /**
     * Директории.
     */
    readonly directories: Directories;
    /**
     * Процессы.
     */
    readonly processes: P;
    /**
     * Электронные подписи.
     */
    readonly digitalSigns: DigitalSigns;
    /**
     * Линии.
     */
    readonly lines: LinesCollections;
    /**
     * Шаблонизатор.
     */
    readonly templater: Templater;
    /**
     * Порталы.
     */
    readonly portals: Portals;
}
/**
 * # Авторизационный токен
 *
 * @ignore
 */
interface AuthToken {
    /**
     * Добавить авторизационные данные в запрос.
     */
    apply(req?: FetchRequest): FetchRequest;
}
/**
 * # Коллекция авторизационных токенов
 *
 * Доступна для глобальных токенов на уровне переменной `Global` только для чтения.
 * Также доступна на уровне пространства имён `Namespace` для чтения и создания.
 *
 * @ignore
 */
interface AuthTokens {
    /**
     * Получить временный токен.
     *
     * @param namespace Пространство имён токена.
     * @param code Код токена.
     *
     * ```typescript
     * const token = await Global.tokens.get('amocrm');
     * if (token) {
     *     const deal = await fetch(
     *         `https://mycompany.amocrm.com/api/v4/leads/{ $id }`,
     *         token.apply(),
     *     ).then(res => res.json());
     * }
     * ```
     */
    getToken(code: string): Promise<AuthToken | undefined>;
    /**
     * Зарегистрировать токен авторизации.
     *
     * ```typescript
     * const token = Namespace.tokens.createOAuth2();
     * token.data.code = 'foo'
     * // ...
     * await token.save();
     * ```
     */
    createOAuth2(): OAuth2Token;
}
/**
 * @ignore
 */
interface GlobalAuthTokens {
    getToken(code: string): Promise<AuthToken | undefined>;
}
/**
 * # Данные для создания OAuth2-токена
 *
 * @ignore
 */
interface OAuth2TokenData extends ItemData {
    /**
     * Код.
     */
    code: TString;
    /**
     * Идентификатор клиента.
     */
    client_id: TString;
    /**
     * Секрет клиента.
     */
    client_secret: TString;
    /**
     * Адрес перенаправления.
     */
    redirect_url: TLink;
    /**
     * Адрес авторизации.
     */
    auth_url: TLink;
    /**
     * Адрес получения токена.
     */
    token_url: TLink;
    /**
     * Доступы токена.
     */
    scopes: TString[];
    /**
     * Авторизационный код.
     */
    authorization_code: TString;
    /**
     * Разрешено ли получать данный токен на клиенте.
     */
    allow_in_client: TBoolean;
}
/**
 * # OAuth2-токен
 *
 * @ignore
 */
interface OAuth2Token extends ItemRef<Item<OAuth2TokenData>> {
    /**
     * Сохранение токена.
     */
    save(): Promise<void>;
}
/**
 * # Объект замещения
 *
 * Используется для создания замещений.
 */
interface Replacements {
    /**
     * Метод [[Replacements.create]] инициализирует новое замещение.
     *
     * После заполнения информации о замещении необходимо сохранить информацию, вызвав метод [[ReplacementItem.save]].
     * ```typescript
     * // Создадим замещение для сотрудника в отпуске
     * const rpl = System.replacements.create();
     *
     * rpl.data.type = rpl.fields.type.variants.reassign;
     * rpl.data.absent = Context.data.__createdBy;
     * rpl.data.replacement = Context.data.substitution;
     * rpl.data.begin = Context.data.vacation_start;
     * rpl.data.end = Context.data.vacation_end;
     *
     * await rpl.save();
     *```
     */
    create(): ReplacementItem;
    /**
     * Метод [[Replacements.search]] позволяет выполнить поиск замещений.
     *
     * Для выборки элементов коллекций используется объект [[Search]]:
     * ```typescript
     * const replacements = await System.replacements.search()
     *     .where(r => r.absent.eq(Context.data.absent_user))
     *     .all();
     * ```
     *
     * Подробнее об использовании объекта поиска можно посмотреть в
     * [статье про объект поиска пользователей](../interfaces/_04_application_.usersearch.html).
     */
    search(): ReplacementSearch;
}
/**
 * # Объект Server
 *
 * Используется для прозрачного взаимодействия с серверными сценариями.
 *
 * Пример вызова серверного метода из клиента:
 * ```typescript
 * await Server.rpc.doSomething()
 * ```
 *
 * Подробнее в статье справки [Сценарии в виджетах](https://elma365.com/ru/help/client_server_scripts.html).
 */
interface ServerCollection {
    /**
     * Список серверных функций.
     *
     * Генерируется на клиенте из функций сервера, которые подходят под сигнатуру:
     * ```typescript
     * async function() : Promise<void>;
     * ```
     */
    readonly rpc: RPCMethodList;
}
/**
 * @ignore
 */
declare type RPCMethodList = Record<string, (...args: any[]) => void>;
/**
 * # Объект рабочего календаря
 *
 * Используется для получения настроек рабочего календаря, таких как:
 * * интервалы рабочего и обеденного времени;
 * * выходные дни;
 * * укороченные и праздничные дни.
 */
interface ProductionSchedule {
    /**
     * Метод [[ProductionSchedule.getGeneralSettings]] получает общие настройки рабочего календаря.
     *
     * К общим настройкам относятся режим рабочего времени и выходные дни недели.
     *
     * ```typescript
     * const generalSettings = await System.productionSchedule.getGeneralSettings();
     * ```
     */
    getGeneralSettings(): Promise<ProductionScheduleGeneralSettings>;
    /**
     * Метод [[ProductionSchedule.getSpecialDays]] получает укороченные и праздничные дни рабочего календаря.
     *
     * Укороченные и праздничные дни возвращаются за определенный период,
     * передаваемый в аргументах метода:
     * @param from Начало периода.
     * @param to Конец периода.
     * ```typescript
     * const fromDate = Context.data.__createdAt;
     * const toDate = Context.data.request_deadline
     * const specialDays = await System.productionSchedule.getSpecialDays(fromDate, toDate);
     * ```
     */
    getSpecialDays(from: TDatetime, to: TDatetime): Promise<ProductionScheduleSpecialDay[]>;
    /**
     * Метод [[ProductionSchedule.getWorkingTime]] позволяет получить продолжительность рабочего времени за определённый период.
     *
     * Продолжительность рабочего времени возвращается за период,
     * передаваемый в аргументах метода:
     * @param from Начало периода.
     * @param to Конец периода.
     * ```typescript
     * const fromDatetime = Context.data.report_start;
     * const toDatetime = Context.data.report_end;
     * const reportedWorkingTime = await System.productionSchedule.getWorkingTime(fromDatetime, toDatetime);
     * const weeklyHours = new Duration(40, "hours");
     * if (workingTime.hours > eightHours.hours) {
     *     Context.data.notification = "Указанная длительность выходит за рамки рабочего времени";
     * };
     * ```
     */
    getWorkingTime(from: TDatetime, to: TDatetime): Promise<TDuration>;
    /**
     * Метод [[ProductionSchedule.calcDate]] позволяет вычислить дату, входящую в интервал рабочего времени.
     *
     * Дата вычисляется от заданной даты и с указанной продолжительностью.
     *
     * Например, можно вычислить, какая дата в рамках рабочего времени
     * будет стоять через 14 часов после даты запуска процесса:
     * ```typescript
     * const workingTime = await System.productionSchedule.calcDate(Context.data.__createdAt, new Duration(14, 'hours'));
     * ```
     *
     * **Обратите внимание, что параметр `time` должен быть кратен минутам.**
     *
     * @param from Дата и время, от которых начинается отсчет.
     * @param time Интервал в часах или в виде значения [[TDuration]].
     */
    calcDate(from: TDatetime, time: number | TDuration): Promise<TDatetime>;
}
/**
 * # Объект переносимого сервиса в модуле
 *
 * Служит для выполнения запросов к сервису.
 *
 * [[Service.fetch]] выполняет запрос к сервису.
 *
 * Пример выполнения запроса:
 * ```typescript
 * await Namespace.services.myService.fetch("/MyServiceMethod")
 * ```
 *
 * [[Service.status]] получает информацию о статусе сервиса.
 *
 * Пример получения статуса:
 * ```typescript
 * const serviceStatusInfo = await Namespace.services.myService.status();
 * if (serviceStatusInfo.status == ServiceStatus.Ready) {
 *     // Некоторая логика
 * }
 * ```
 */
interface Service {
    /**
     * Уникальное название сервиса.
     */
    readonly code: string;
    /**
     * Выполнить запрос.
     *
     * @param url Относительная ссылка для запроса в сервис.
     * @param options Стандартный объект запроса [[FetchRequest]].
     */
    fetch(url: string, options?: FetchRequest): Promise<FetchResponse>;
    /**
     * Получить информацию о статусе сервиса.
     */
    status(): Promise<ServiceStatusInfo>;
}
/**
 * # Список доступных переносимых сервисов
 *
 * @ignore
 */
declare type Services = Record<string, Service>;
/**
 * # Объект шаблонизатора
 *
 * Используется для обработки шаблонов текста.
 *
 */
interface Templater {
    /**
     * Метод обходит шаблон и подставляет значения из контекста переданного элемента приложения.
     *
     * @param item Элемент приложения.
     * @param template Шаблон.
     *
     * ```typescript
     * const item = Context.data.n1!;
     * const text = await System.templater.generateText(item,'test {$__name}');
     * ```
     *
     * @returns Результат обхода через шаблонизатор.
     */
    generateText(item: RefItem, template: string): Promise<string>;
}
/**
 * # Объект для работы с переводами
 *
 * Используется для локализации строк.
 *
 */
interface Translator {
    /**
     * Метод возвращает перевод строки исходя из локали пользователя.
     *
     * @param str Строка для перевода.
     *
     * ```typescript
     * // Локаль пользователя: 'en-US', 'ru-RU' и т.п.
     * const res = SR.T('привет'); // return 'hello'
     * ```
     * @returns Перевод строки.
     */
    T(str: string): string;
}
/**
 * # Объект, содержащий логику для работы с переводами строковых значений
 *
 */
declare const SR: Translator;
/**
 * # Работа с приложениями
 *
 * Подробное описание в статье [Работа с приложениями](../pages/quick-start/intro_apps.html).
 * @packageDocumentation
 */
/** */
/**
 * @ignore
 */
declare type FilterClosure<T extends ItemData> = (f: FieldsOperands<T>, g: GlobalFilters) => Filter;
/**
 * @ignore
 */
declare type CollFilterClosure<T extends ItemData> = (
/**
 * Фабрика фильтров по полям приложения.
 * Генерирует [[FieldOperand]], [[StringFieldOperand]] и [[FieldArrayOperand]]
 * по контекстным переменным приложения.
 */
f: FieldsOperands<T>, 
/**
 * Коллекция операндов для текущего контекста
 * (например, контекста бизнес-процесса или виджета).
 */
t: ContextOperands, 
/**
 * Фабрика глобальных фильтров — [[GlobalFilters]], —
 * которые используются для составных фильтров и полнотекстового поиска.
 */
g: GlobalFilters) => Filter;
/**
 * @ignore
 */
declare type DatetimeFilterClosure<T extends TDatetime | TDate | TTime> = (f: DatetimeFieldOperand<T>, g: BaseGlobalFilters) => Filter;
/**
 * @ignore
 */
interface ContextOperands {
    [key: string]: ContextOperand;
}
/**
 * # Объект поиска элементов коллекции
 *
 * [[Search]] позволяет осуществлять поиск по различным коллекциям:
 * * приложениям,
 * * истории изменения статусов приложения,
 * * пользователям,
 * * файлам,
 * * организационной структуре,
 * * группам,
 * * экземплярам процессов,
 * * задачам процесса.
 */
interface Search<T extends ItemData, I extends Item<T>> {
    /**
     * Метод [[Search.where]] позволяет задать фильтрацию элементов коллекции.
     *
     * @param fc Фильтры для поиска.
     * ```typescript
     * const searchResults = await Application.search()
     *     .where((f, g) => g.and (
     *         f.__deletedAt.eq(null),
     *         f.service.link(Context.data.service)
     *     ))
     *     .all();
     * ```
     */
    where(fc: FilterClosure<T>): this;
    /**
     * Метод [[Search.from]] позволяет пропустить заданное количество элементов.
     *
     * @param n Количество элементов, которое необходимо пропустить.
     *
     * Например, при работе с большим количеством элементов приложения
     * можно разбить поиск на порции и динамически определять начало выборки.
     * ```typescript
     * Context.data.from += 100;
     * const searchResults = await Application.search()
     *     .from(Context.data.from)
     *     .where((f, g) => g.and (
     *         f.__deletedAt.eq(null),
     *         f.service.link(Context.data.service)
     *     ))
     *     .all();
     * ```
     */
    from(n: number): this;
    /**
     * Метод [[Search.size]] позволяет задать ограничение выборки элементов.
     *
     * @param n Размер выборки (по умолчанию 10, максимум 10000).
     * ```typescript
     * const searchResults = await Application.search()
     *     .size(500)
     *     .where((f, g) => g.and (
     *         f.__deletedAt.eq(null),
     *         f.service.link(Context.data.service)
     *     ))
     *     .all();
     * ```
     */
    size(n: number): this;
    /**
     * Метод [[Search.sort]] позволяет выполнить сортировку результатов поиска.
     *
     * Если необходимо отсортировать результаты по нескольким параметрам,
     * можно вызывать метод несколько раз последовательно.
     *
     * @param field Код поля, по которому выполняется сортировка.
     * @param ascending Если значение параметра — `true`, сортировка выполняется по возрастанию, если `false` — по убыванию.
     * ```typescript
     * const searchResults = await Application.search()
     *     .size(500)
     *     .sort("__createdAt", true)
     *     .where((f, g) => g.and (
     *         f.__deletedAt.eq(null),
     *         f.service.link(Context.data.service)
     *     ))
     *     .all();
     * ```
     */
    sort(field: keyof T, ascending?: boolean): this;
    /**
     * Метод [[Search.count]] позволяет получить количество элементов в выборке (игнорирует [[Search.from]] и [[Search.size]]).
     *
     * ```typescript
     * const searchResults = await Application.search()
     *     .where((f, g) => g.and (
     *         f.__deletedAt.eq(null),
     *         f.service.link(Context.data.service)
     *     ))
     *     .count();
     * ```
     */
    count(): Promise<number>;
    /**
     * Метод [[Search.first]] возвращает первый элемент выборки.
     *
     * ```typescript
     * const searchResults = await Application.search()
     *     .where((f, g) => g.and (
     *         f.__deletedAt.eq(null),
     *         f.service.link(Context.data.service)
     *     ))
     *     .first();
     * ```
     */
    first(): Promise<I | undefined>;
    /**
     * Метод [[Search.all]] возвращает страницу результатов поиска с количеством результатов [[Search.size]], начиная с [[Search.from]].
     *
     * По умолчанию размер выборки ограничен 10 записями. Если нужно выбрать больше элементов, используйте метод [[Search.size]].
     *
     * ```typescript
     * const searchResults = await Application.search()
     *     .where((f, g) => g.and (
     *         f.__deletedAt.eq(null),
     *         f.service.link(Context.data.service)
     *     ))
     *     .all();
     * ```
     */
    all(): Promise<I[]>;
}
/**
 * @ignore
 */
interface ApplicationSearch<T extends ItemData, P extends ItemData> extends Search<T, ApplicationItem<T, P>> {
}
/**
 * @ignore
 */
interface CategorySearch<C extends ItemData> extends Search<C, CategoryItem<C>> {
}
/**
 * # Объект поиска пользователей
 *
 * Подробнее работа поиска описана в [[Search]].
 */
interface UserSearch extends Search<UserData, UserItem> {
}
/**
 * # Объект поиска файлов
 *
 * Подробнее работа поиска описана в [[Search]].
 */
interface FilesSearch extends Search<FileData, FileItem> {
}
/**
 * # Объект поиска групп пользователей
 *
 * Подробнее работа поиска описана в [[Search]].
 */
interface DirectoriesSearch extends Search<DirectoryData, DirectoryItem> {
}
/**
 * # Объект поиска элементов коллекции
 */
interface UserGroupSearch extends Search<UserGroupData, UserGroupItem> {
}
/**
 * # Объект поиска элементов организационной структуры
 *
 * Подробнее работа поиска описана в [[Search]].
 */
interface OrganisationStructureSearch extends Search<OrganisationStructureData, OrganisationStructureItem> {
}
/**
 * # Объект поиска экземпляров процессов
 */
interface ProcessInstanceSearch extends Search<ProcessInstanceData, ProcessInstanceItem> {
}
/**
 * # Объект поиска задач процессов
 */
interface ProcessInstanceTaskSearch extends Search<ProcessTaskData, ProcessTaskItem> {
}
/**
 * # Объект поиска замещений
 *
 * Подробнее работа поиска описана в [[Search]].
 */
interface ReplacementSearch extends Search<ReplacementData, ReplacementItem> {
}
/**
 * # Объект поиска по истории изменения статусов
 *
 * Подробнее работа поиска описана в [[Search]].
 */
interface StatusHistorySearch<T extends ItemData, P extends ItemData> extends Search<StatusHistoryData<T, P>, StatusHistoryItem<T, P>> {
}
/**
 * @ignore
 */
interface Filter {
    json(): any;
}
/**
 * # Фильтрация по полю коллекции
 *
 * [[FieldOperand]] предоставляет набор методов для составления фильтров
 * в [[Search.where]].
 */
interface FieldOperand<T extends Type> {
    /**
     * Поле равно другому полю или константе либо не определено.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     */
    eq(x: FieldOperand<T> | ConstOperandType<T> | null | ContextOperand): Filter;
    /**
     * Поле не равно другому полю или константе либо определено.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     */
    neq(x: FieldOperand<T> | ConstOperandType<T> | null | ContextOperand): Filter;
    /**
     * Поле больше другого поля или константы.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     */
    gt(x: FieldOperand<T> | ConstOperandType<T> | ContextOperand): Filter;
    /**
     * Поле больше или равно другому полю или константе.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     */
    gte(x: FieldOperand<T> | ConstOperandType<T> | ContextOperand): Filter;
    /**
     * Поле меньше другого поля или константы.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     */
    lt(x: FieldOperand<T> | ConstOperandType<T> | ContextOperand): Filter;
    /**
     * Поле меньше или равно другому полю или константе.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     */
    lte(x: FieldOperand<T> | ConstOperandType<T> | ContextOperand): Filter;
    /**
     * Поле входит в множественное поле как элемент.
     *
     * @param x Массив, вхождение в который проверяется для поля.
     */
    in(x: FieldArrayOperand<T> | ConstOperandType<T>[] | ContextOperand[]): Filter;
}
/**
 * # Фильтрация по полю контекста
 *
 * Хранит текущий контекст и используется, например, в [[StaticApplicationFieldData.setFilter]].
 */
interface ContextOperand {
    /**
     * @ignore
     */
    json(): {
        context: string;
    };
}
/**
 * # Фильтрация по строковому полю коллекции
 *
 * [[StringFieldOperand]] предоставляет метод для фильтрации по полям типа Строка.
 */
interface StringFieldOperand<T extends StringedTypes> extends FieldOperand<T> {
    /**
     * Фильтрация по вхождению строки в переданную переменную или константу.
     *
     * @param x Строка, вхождение в которую проверяется при фильтрации.
     */
    like(x: string): Filter;
}
/**
 * # Фильтрация по множественному полю коллекции
 *
 * [[FieldArrayOperand]] предоставляет методы для фильтрации множественных полей.
 */
interface FieldArrayOperand<T extends Type> {
    /**
     * Фильтрация по нахождению значения в списке.
     *
     * @param x Поле или контстанта, которые должны содержаться во множественном поле элемента коллекции.
     */
    has(x: FieldOperand<T> | ConstOperandType<T>): Filter;
    /**
     * Фильтрация по вхождению списка в заданный список.
     *
     * @param x Список, вхождение в который проверяется для множественного поля элемента коллекции.
     */
    all(x: FieldArrayOperand<T> | ConstOperandType<T>[]): Filter;
}
/**
 * # Фильтрация коллекции по ссылке на элемент приложения
 *
 * [[ApplicationFieldOperand]] предоставляет метод для фильтрации элементов по наличию ссылки на элемент приложения.
 */
interface ApplicationFieldOperand<T extends TApplication<any, any, any>> {
    /**
     * Фильтрация по наличию ссылки на элемент приложения.
     *
     * @param x Поле или константа. Наличие ссылки на этот элемент проверяется при фильтрации.
     * Допустимо единичное или множественное значение.
     */
    link(x: T | T[] | TRefItem | TRefItem[]): Filter;
    /**
     * Поле равно пустому значению.
     *
     * @param x Значение, с которым необходимо сравнить поле.
     */
    eq(x: null): Filter;
    /**
     * Поле не равно пустому значению.
     *
     * @param x Значение, с которым необходимо сравнить поле.
     */
    neq(x: null): Filter;
}
/**
 * # Фильтрация коллекции по ссылке на элемент произвольного приложения
 *
 * [[RefItemFieldOperand]] предоставляет метод для фильтрации элементов по наличию ссылки на элемент произвольного приложения.
 */
interface RefItemFieldOperand<T extends TRefItem> {
    /**
     * Поле равно другому полю, константе или не определено.
     *
     * @param x Поле или константа, с которой необходимо сравнить поле.
     */
    eq(x: FieldOperand<T> | ConstOperandType<T> | null | ContextOperand): Filter;
    /**
     * Поле не равно другому полю, константе или определено.
     *
     * @param x Поле или константа, с которой необходимо сравнить поле.
     */
    neq(x: FieldOperand<T> | ConstOperandType<T> | null | ContextOperand): Filter;
    /**
     * Поле входит в множественное поле как элемент.
     *
     * @param x Массив, вхождение в который проверяется для поля.
     */
    in(x: FieldArrayOperand<T> | ConstOperandType<T>[] | ContextOperand[]): Filter;
}
/**
 * # Фильтрация коллекции по полю типа Телефон
 *
 * [[PhoneFieldOperand]] предоставляет методы для фильтрации по данным поля типа Телефон.
 */
interface PhoneFieldOperand<T extends TPhone<PhoneType>> {
    /**
     * Поле равно другому полю, константе или не определено.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     * Если константа типа Телефон, то фильтрация идёт только по номеру телефона.
     */
    eq(x: FieldOperand<T> | ConstOperandType<T> | null | ContextOperand): Filter;
    /**
     * Поле не равно другому полю, константе или не определено.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     * Если константа типа Телефон, то фильтрация идёт только по номеру телефона.
     */
    neq(x: FieldOperand<T> | ConstOperandType<T> | null | ContextOperand): Filter;
    /**
     * @deprecated Избегайте использования этого метода для поля типа Телефон.
     *
     * Поле больше другого поля или константы.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     */
    gt(x: FieldOperand<T> | ConstOperandType<T> | ContextOperand): Filter;
    /**
     * @deprecated Используйте методы `eq()` и `neq()`.
     *
     * Поле больше или равно другому полю или константе.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     */
    gte(x: FieldOperand<T> | ConstOperandType<T> | ContextOperand): Filter;
    /**
     * @deprecated Избегайте использования этого метода для поля типа Телефон.
     *
     * Поле меньше другого поля или константы.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     */
    lt(x: FieldOperand<T> | ConstOperandType<T> | ContextOperand): Filter;
    /**
     * @deprecated Используйте методы `eq()` и `neq()`.
     *
     * Поле меньше или равно другому полю или константе.
     *
     * @param x Поле или константа, с которыми необходимо сравнить поле.
     */
    lte(x: FieldOperand<T> | ConstOperandType<T> | ContextOperand): Filter;
    /**
     * Поле входит в множественное поле как элемент.
     *
     * @param x Массив, вхождение в который проверяется для поля.
     *
     */
    in(x: FieldArrayOperand<T> | ConstOperandType<T>[] | ContextOperand[]): Filter;
    /**
     * Фильтрация по вхождению подстроки в переданную переменную или константу.
     *
     * @param x Строка, вхождение в которую проверяется при фильтрации.
     */
    like(x: string): Filter;
}
/**
 * # Фильтрация по полю типа «Дата/время»
 *
 * [[DatetimeFieldOperand]] предоставляет методы для фильтрации по данным поля типа «Дата/время».
 */
interface DatetimeFieldOperand<T extends TDatetime | TDate | TTime> {
    /**
     * Поле равно константе.
     *
     * @param x Константа, с которой необходимо сравнить поле.
     */
    eq(x: T): Filter;
    /**
     * Поле не равно константе.
     *
     * @param x Константа, с которой необходимо сравнить поле.
     */
    neq(x: T): Filter;
    /**
     * Поле больше константы.
     *
     * @param x Константа, с которой необходимо сравнить поле.
     */
    gt(x: T): Filter;
    /**
     * Поле меньше константы.
     *
     * @param x Константа, с которой необходимо сравнить поле.
     */
    lt(x: T): Filter;
    /**
     * Поле больше или равно константе.
     *
     * @param x Константа, с которой необходимо сравнить поле.
     */
    gte(x: T): Filter;
    /**
     * Поле меньше или равно константе.
     *
     * @param x Константа, с которой необходимо сравнить поле.
     */
    lte(x: T): Filter;
}
/**
 * @ignore
 */
declare type FieldOperandChoice<T extends Type | Type[]> = T extends undefined | undefined[] ? never : T extends TPhone<PhoneType> ? PhoneFieldOperand<T> : T extends StringedTypes ? StringFieldOperand<T> : T extends TApplication<any, any, any> ? ApplicationFieldOperand<T> : T extends TRefItem ? RefItemFieldOperand<TRefItem> : T extends TBoolean ? FieldOperand<TBoolean> : T extends Type[] ? FieldArrayOperand<T> : T extends Type ? FieldOperand<T> : never;
/**
 * @ignore
 */
declare type FieldsOperands<T extends ItemData> = {
    [K in keyof T]-?: FieldOperandChoice<T[K]>;
};
/**
 * @ignore
 */
declare type ConstOperandType<T extends Type | Type[]> = T extends TString | TString[] ? TString : T extends TFloat | TFloat[] ? TFloat : T extends TBoolean | TBoolean[] ? TBoolean : T extends TDatetime | TDatetime[] ? TDatetime : T extends TDate | TDate[] ? TDate : T extends TTime | TTime[] ? TTime : T extends TFile | TFile[] ? TFile | TString : T extends TImage | TImage[] ? TImage | TString : T extends TUser | TUser[] ? TUser | TString : T extends TApplication<infer D, infer DD, infer DDD> | TApplication<infer D, infer DD, infer DDD>[] ? TApplication<D, DD, DDD> | TString : T extends TRefItem | TRefItem[] ? TRefItem : T extends TCategory<infer C> | TCategory<infer C>[] ? TString : T extends TMoney<infer CC> | TMoney<infer CC>[] ? TMoney<CC> | TFloat : T extends TPhone<infer P> | TPhone<PhoneType>[] ? TPhone<PhoneType> | TString : T extends TAccount<infer A> | TAccount<AccountType>[] ? TAccount<AccountType> | TString : T extends TEmail<infer E> | TEmail<EmailType>[] ? TEmail<EmailType> | TString : T extends TStatus<infer S, infer SS> | TStatus<infer S, infer SS>[] ? TStatus<S, SS> | TFloat : T extends TFullName | TFullName[] ? TFullName | TString : T extends TLink | TLink[] ? TLink | TString : T extends TEnum<infer K> | TEnum<infer K>[] ? TEnum<K> | TString : never;
/**
 * @ignore
 */
declare type StringedTypes = TString | TPhone<PhoneType> | TAccount<AccountType> | TEmail<EmailType> | TFullName | TLink | TEnum<string>;
/**
 * # Базовые глобальные функции, доступные в фильтрах
 */
interface BaseGlobalFilters {
    /**
     * Объединение нескольких фильтров логическим И.
     */
    and(...operands: Filter[]): Filter;
    /**
     * Объединение нескольких фильтров логическим ИЛИ.
     */
    or(...operands: Filter[]): Filter;
}
/**
 * # Глобальные функции, доступные в фильтрах
 *
 * [[GlobalFilters]] предоставляет методы для связки параметров фильтрации
 * в методе [[Search.where]], а также возможность полнотекстового поиска
 * по строковым полям.
 */
interface GlobalFilters extends BaseGlobalFilters {
    /**
     * Полнотекстовый поиск.
     */
    fts(query: string): Filter;
}
/**
 * # Папка внутри приложения
 */
interface TFolder {
    /**
     * Идентификатор папки.
     */
    id: string;
    /**
     * Уровень вложенности папки внутри приложения.
     *
     */
    level: number;
    /**
     * Название папки.
     */
    name: string;
    /**
     * Дата и время удаления.
     */
    __deletedAt?: TDatetime;
    /**
     * Метод получает массив дочерних папок.
     *
     * В примере с помощью метода мы получаем все папки второго уровня вложенности.
     * Они являются дочерними по отношению к папкам на уровне приложения.
     *
     * ```typescript
     * const folders = await Application.getFolders();
     * const allChildren: TFolder[] = [];
     * folders.forEach(folder => {
     *     const children = await folder.getChildren();
     *     allChildren.push(...children);
     *});
     * ```
     * @returns Дочерние папки.
     */
    getChildren(): Promise<TFolder[]>;
    /**
     * Метод получает родительскую папку.
     *
     * В примере с помощью метода мы получаем родительскую папку элемента приложения.
     *
     * ```typescript
     * const folder = await Context.data.item?.getFolder();
     * const parentFolder = await folder.getParent();
     * ```
     * @returns Родительская папка или `undefined`, если папка находится на высшем уровне.
     */
    getParent(): Promise<TFolder | undefined>;
    /**
     * Метод создаёт новую дочернюю папку.
     *
     * В примере с помощью метода мы получаем папку элемента приложения и создаём внутри неё новую папку.
     *
     * ```typescript
     * const folder = await Context.data.item?.getFolder();
     * const childFolder = await folder.createFolder('name');
     * ```
     * @param name Имя создаваемой папки.
     */
    createFolder(name: string): Promise<TFolder>;
}
/**
 * # Поля настроек приложения
 */
interface TSettings {
    /**
     * Настройки регистрации для данного приложения.
     */
    readonly registrationSettings: RegistrationSettings;
    /**
     * Настройки подписи для приложения.
     */
    readonly signature: SignatureSettings;
    /**
     * Настройки архивирования листов согласования.
     */
    readonly docflow: DocflowSettings;
    /**
     * Настройки иерархического справочника.
     */
    readonly folderSettings: FolderSettings;
    /**
     * Получить шаблоны документов в приложении.
     *
     * ```typescript
     * const settings = await Application.getSettings();
     * const docTemplates = await settings.getDocTemplates();
     * ```
     */
    getDocTemplates(): Promise<TDocTemplate[]>;
}
/**
 * # Шаблон документа приложения
 */
interface TDocTemplate extends BaseItemData {
    /**
     * Расширение файла шаблона документа.
     */
    readonly extension: string;
    /**
     * ID файла шаблона документа.
     */
    readonly fileId: string;
}
/**
 * # Настройки подписи приложения
 */
interface SignatureSettings {
    /**
     * Если флаг включен, система исключает все системные поля элемента из процедуры подписания.
     */
    excludeSystemFields: boolean;
    /**
     * Поля, исключенные из списка полей для подписания. Заполнено, если `excludeSystemFields` имеет значение `false`.
     */
    excludeFields: string[];
}
/**
 * # Настройки иерархического справочника
 */
interface FolderSettings {
    /**
     * Если флаг включен, в приложении включен иерархический справочник.
     */
    enabledFolders: boolean;
}
/**
 * # Настройки архивирования листов согласования
 */
interface DocflowSettings {
    /**
     * Если флаг включен, система исключает все поля элемента из процедуры архивирования листов.
     */
    excludeAllFields: boolean;
    /**
     * Если флаг включен, система исключает все системные поля элемента из процедуры архивирования листов.
     */
    excludeSystemFields: boolean;
    /**
     * Поля, исключенные из списка полей для подписи. Заполнено, если `excludeAllFields` и `excludeSystemFields` имеют значение `false`.
     */
    excludeFields: string[];
}
/**
 * # Поля настроек регистрации
 */
interface RegistrationSettings {
    /**
     * Возвращает список дел, доступных для данного приложения.
     * ```typescript
     * const settings = await Application.getSettings();
     * const nomenclatures = await settings.registrationSettings.getNomenclatures();
     * ```
     */
    getNomenclatures(): Promise<TNomenclature[]>;
    /**
     * Если поле `enabled` имеет значение `true`, то регистрация в данном приложении включена.
     */
    readonly enabled: boolean;
    /**
     * Список ID дел, в которых доступна регистрация для данного приложения.
     */
    readonly nomenclatureIds: string[];
}
/**
 * # Дело
 */
interface TNomenclature extends BaseItemData {
    /**
     * Полное название дела с учетом всей иерархии мест регистрации и разделов, в которых оно расположено.
     */
    readonly __dirname: string;
    /**
     * ID родительского места регистрации/раздела.
     */
    readonly directoryID: string;
    /**
     * Настройки дела.
     */
    readonly settings: NomenclatureRegistrationSettings;
    /**
     * Метод получает нумератор.
     *
     * В примере с помощью метода мы получаем нумератор первого дела, указанного в настройках регистрации.
     * Для его получения необходим элемент приложения. В данном сценарии он хранится в контексте.
     *
     * ```typescript
     * const settings = await Application.getSettings();
     * const nomenclatures = await settings.registrationSettings.getNomenclatures();
     * const nom = nomenclatures[0];
     * const serial = await nom.getSerial();
     * ```
     * @returns Нумератор дела.
     */
    getSerial(): Promise<SerialData>;
    /**
     * Метод получает текущий раздел и/или место регистрации.
     *
     * Рассмотрим, как с помощью метода получить директорию первого дела, указанного в настройках регистрации.
     * Для её получения необходим элемент приложения. В данном сценарии он хранится в контексте.
     *
     * ```typescript
     * const settings = await Application.getSettings();
     * const nomenclatures = await settings.registrationSettings.getNomenclatures();
     * const nom = nomenclatures[0];
     * const directory = await nom.getDirectory();
     * ```
     * @returns Директория дела.
     */
    getDirectory(): Promise<TNomenclatureDirectory>;
}
/**
 * # Место регистрации/раздел
 */
interface TNomenclatureDirectory extends BaseItemData {
    /**
     * Тип элемента номенклатуры:
     *
     * * место регистрации (place),
     *
     * * раздел (section).
     */
    readonly type: 'place' | 'section';
    /**
     * Родитель. Для раздела — место регистрации, для места регистрации — `undefined`.
     */
    readonly directory: TNomenclatureDirectory | undefined;
}
/**
 * # Настройки номенклатуры
 */
interface NomenclatureRegistrationSettings {
    /**
     * Если параметр имеет значение `true`, используется автоматическая регистрация, если `false` — ручная.
     */
    readonly templateEnabled: boolean;
    /**
     * @deprecated Настройка ежегодного сброса заменена настройками периодического сброса.
     *
     * Использовать:
     *
     * 1) `resetInPeriod` для проверки активности периодического сброса.
     * 2) `resetSettings` для просмотра текущих настроек сброса.
     *
     * Значение будет true, если включены настройки сброса (`resetInPeriod`),
     * в настройках (`resetSettings`) период сброса — год,
     * количество — 1, а дата следующего сброса выпадает на 1-е января.
     */
    readonly resetNewYear: boolean;
    /**
     * Если задано значение `true`, то включен сброс нумерации раз в установленный период.
     */
    readonly resetInPeriod: boolean;
    /**
     * Настройки периодического сброса нумерации для дела.
     */
    readonly resetSettings: ResetSettings | null;
    /**
     * Если задано значение `true`, то резервирование номера доступно.
     */
    readonly reserveEnabled: boolean;
    /**
     * Если задано значение `true`, то после регистрации будет доступно редактирование номера.
     */
    readonly editAfterRegistration: boolean;
    /**
     * Если задано значение `true`, то включена сквозная нумерация с другим делом.
     */
    readonly through: boolean;
    /**
     * ID дела, с которым задана сквозная нумерация.
     */
    readonly throughSerialId: string | null;
}
/**
 * # Настройки периодического сброса нумерации
 */
interface ResetSettings {
    /**
     * Доступные единицы сброса нумерации:
     *
     * 1) `year` — год;
     * 2) `month` — месяц;
     * 3) `week` — неделя;
     * 4) `day` — день.
     */
    readonly resetPeriod: string;
    /**
     * Количество единиц в периоде сброса нумерации.
     */
    readonly resetPeriodCount: number;
}
/**
 * # Объект для работы с заявками на выпуск сертификата электронной подписи
 */
interface DigitalSigns {
    /**
     * Получение последней заявки текущего пользователя.
     *
     * Метод получает последнюю заявку на выпуск сертификата, созданную пользователем. Используется
     * для организации процессов выпуска сертификатов электронных подписей. Например, после создания заявки требуется
     * подтвердить выпуск сертификата с помощью пароля или авторизации на стороннем сервисе. Для этого
     * необходимо сначала получить последнюю заявку, созданную пользователем, и запросить для нее пароль.
     *
     * В примере выполняется получение последней заявки текущего пользователя и запрос пароля от провайдера.
     *
     * ```typescript
     * // Получение последней созданной заявки
     * const lastRequest = await System.digitalSigns.getLastRequest();
     * // Запрос пароля для заявки
     * await lastRequest.getSecret();
     * ```
     *
     * @param provider Провайдер, указанный в заявке на выпуск сертификата.
     */
    getLastRequest(provider: DigitalSignProviderRef): Promise<DigitalSign>;
}
/**
 * # Сертификат электронной подписи
 *
 * Сертификат выпускается при помощи интеграции с каким-либо провайдером, предоставляющим
 * услуги по выпуску сертификатов электронных подписей и подписанию пользовательских данных.
 */
interface DigitalSign {
    /**
     * Получает тип идентификации личности пользователя.
     *
     * Метод возвращает тип идентификации личности, который используется для выпуска сертификата электронной подписи.
     *
     * В примере показана ситуация, когда в зависимости от типа идентификации должны выполняться различные действия.
     * Сначала получим последнюю созданную подпись с помощью метода [[DigitalSigns.getLastRequest]]. Затем определим
     * дальнейшие действия: при идентификации через Госуслуги никаких действий не требуется, но при авторизации с помощью
     * пароля необходимо ввести пароль, полученный от провайдера.
     *
     * ```typescript
     * const lastDigitalSign = await System.digitalSigns.getLastRequest();
     *
     * if (lastDigitalSign.getIdentification() === DigitalSignIdentificationType.ESIA) {
     *     // Если используется идентификация через Госуслуги, действий не требуется
     *     return;
     * }
     *
     * if (lastDigitalSign.getIdentification() === DigitalSignIdentificationType.Secret) {
     *     // Если используется идентификация через пароль, запрашиваем его
     *     await lastDigitalSign.getSecret();
     *     // Отображаем окно для ввода пароля
     *     // Функция отображена для примера
     *     // В качестве окна ввода пароля может быть использован любой подходящий виджет
     *     this.showConfirmWindow();
     * }
     *
     * ```
     */
    getIdentification(): DigitalSignIdentificationType;
    /**
     * Получает пароль для подтверждения личности пользователя в рамках заявки на выпуск сертификата электронной подписи.
     *
     * Метод запрашивает у провайдера пароль для пользователя, выпускающего сертификат.
     * Провайдер выполняет отправку пароля пользователю на контактные данные,
     * указанные в заявке. Способ отправки данных зависит от провайдера и его настроек.
     *
     * В примере рассматривается получение последней заявки на выпуск сертификата и запрос пароля для этой заявки.
     *
     * ```typescript
     * // Получение последней созданной заявки
     * const lastRequest = await System.digitalSigns.getLastRequest();
     * // Запрос пароля для заявки
     * await lastRequest.getSecret();
     * ```
     */
    receiveSecret(): Promise<void>;
    /**
     * Подтверждение выпуска сертификата электронной подписи.
     *
     * @param secret Пароль, полученный от провайдера.
     *
     * Используется для подтверждения выпуска сертификата по созданной заявке. Метод отправляет полученный
     * пользователем пароль провайдеру, который выпускает сертификат. Проверку корректности пароля осуществляет
     * провайдер.
     *
     * В примере рассматривается отправка пароля, полученного из контекста. Для этого используется поле `password`.
     *
     * ```typescript
     * // Получение заявки
     * const lastRequest = await System.digitalSigns.getLastRequest();
     * // Извлечение пароля из контекста
     * const userPassword = Context.data.password;
     * // Отправка пароля
     * await lastRequest.confirm(userPassword);
     * ```
     */
    confirm(secret: string): Promise<boolean>;
}
/**
 * # Данные, хранимые в сертификате электронной подписи
 */
interface DigitalSignItemData {
    /**
     * Идентификатор сертификата электронной подписи.
     */
    id: string;
    /**
     * Идентификатор сертификата электронной подписи во внешней системе.
     *
     * Формат идентификатора зависит от провайдера, выпускающего сертификат.
     */
    issueID: string;
    /**
     * Статус сертификата.
     */
    cert_status: DigitalSignRequestStatus;
    /**
     * Ссылка на провайдера для работы с электронной подписью.
     */
    sign_provider: DigitalSignProviderRef;
    /**
     * Данные для создания заявки.
     *
     * Содержат информацию о процессе выпуска сертификата и отправке данных провайдеру.
     */
    actualized: DigitalSignActualizationData;
    /**
     * Последняя ошибка, возникшая при выпуске сертификата.
     */
    lastError: string;
    /**
     * Тип идентификации пользователя для выпуска сертификата.
     */
    identificationType: DigitalSignIdentificationType;
}
/**
 * # Данные заявки на выпуск сертификата электронной подписи
 */
interface DigitalSignActualizationData {
    /**
     * Данные, использующиеся для создания заявки на выпуск сертификата электронной подписи.
     */
    data: DigitalSignRequest;
    /**
     * Флаг, обозначающий статус заполнения данных заявки. Истина, когда данные заполнены и обработаны на стороне провайдера.
     */
    actual: boolean;
}
/**
 * # Ссылка на провайдера для работы с электронной подписью
 */
interface DigitalSignProviderRef {
    /**
     * Namespace провайдера.
     */
    namespace: string;
    /**
     * Уникальный код провайдера.
     */
    code: string;
}
/**
 * # Статус заявки на выпуск сертификата электронной подписи
 */
declare enum DigitalSignRequestStatus {
    /**
     * # Статус заявки неизвестен
     */
    Unknown = "unknown",
    /**
     * # Заявка подготавливается
     *
     * На данном этапе данные и документы отправляются в систему провайдера.
     */
    Preparing = "preparing",
    /**
     * # Заявка проверяется
     *
     * Провайдер выполняет проверку указанных в заявке данных.
     */
    Validating = "validating",
    /**
     * # В данные заявки необходимо внести исправления
     *
     * После проверки в заявке найдены ошибки, которые необходимо исправить.
     */
    Correction = "correction",
    /**
     * # Запущена процедура идентификации личности пользователя
     */
    IdentificationRunning = "identification_running",
    /**
     * # Процедура идентификации личности пользователя завершена
     */
    IdentificationFinished = "identification_finished",
    /**
     * # Заявка на выпуск сертификата одобрена
     */
    Approved = "approved",
    /**
     * # Сертификат выпускается
     */
    Releasing = "releasing",
    /**
     * # Сертификат выпущен
     */
    Released = "released",
    /**
     * # В процессе работы с заявкой произошла ошибка
     */
    Error = "error"
}
/**
 * # Заявка на выпуск сертификата электронной подписи
 *
 * Содержит основную информацию для выпуска сертификата электронной подписи.
 */
interface DigitalSignRequest {
    /**
     * Идентификатор пользователя, выполняющего проверку личности пользователя-заявителя.
     */
    moderatedBy: string;
    /**
     * Тип идентификации личности пользователя.
     */
    identificationType: DigitalSignIdentificationType;
}
/**
 * # Тип идентификации личности пользователя
 *
 * Подтверждение личности пользователя требуется для выпуска сертификата электронной подписи.
 */
declare enum DigitalSignIdentificationType {
    /**
     * # Идентификация личности пользователя, которую провайдер использует по умолчанию
     */
    Default = "default",
    /**
     * # Идентификация личности пользователя с помощью Госуслуг
     */
    ESIA = "ESIA",
    /**
     * # Идентификация личности пользователя с помощью пароля
     *
     * Может использоваться обычный пароль, высылаемый провайдером, или код, который отправляется через SMS.
     */
    Secret = "secret"
}
/**
 * # Подписи версии элемента приложения
 *
 * Представляет список подписей по некоторой версии элемента приложения.
 */
interface EntityVersion {
    /**
     * Отпечаток подписанных данных.
     */
    hash: SignHash;
    /**
     * Тип подписи некоторой версии элемента приложения.
     */
    type: SignType;
    /**
     * Архив подписей версии элемента приложения.
     *
     * Содержит в себе информацию о сохраненных подписях версии элемента приложения.
     */
    signs: EntitySign[];
}
/**
 * # Подпись
 *
 * Хранит информацию о подписании элемента приложения.
 */
interface EntitySign {
    /**
     * Идентификатор подписи.
     */
    id: string;
    /**
     * Содержимое вычисленной подписи.
     *
     * В поле хранится тело подписи, представленное в формате `base64`.
     */
    sign: string;
    /**
     * Тип вычисленной подписи.
     */
    type: SignType;
    /**
     * Статус подписи.
     */
    status: SignStatus;
    /**
     * Дата создания.
     */
    createdAt: string;
    /**
     * ID пользователя, подписавшего элемент системы.
     */
    userID: string;
    /**
     * Подписанные данные.
     */
    content: SignedContent;
    /**
     * Метод генерирует файл с подписью.
     *
     * Возвращает файл с содержимым подписи. Используется для получения тела подписи в виде файла.
     *
     * В примере используется подпись, полученная из архива.
     *
     * ```typescript
     * const signFile = await signHistory[0].signs[0].createSignFile();
     * ```
     *
     * @returns Файл с подписью.
     */
    createSignFile(): Promise<FileItem>;
    /**
     * Метод создает файл из подписанных атрибутов элемента приложения.
     *
     * Возвращает значения атрибутов, которые были подписаны, в виде файла.
     *
     * В примере используется ранее полученная подпись из архива подписей элемента приложения.
     *
     * ```typescript
     * const attributes = await signHistory[0].signs[0].createAttributesFile();
     * ```
     *
     * @returns Файл с атрибутами элемента приложения, которые были подписаны.
     */
    createAttributesFile(): Promise<FileItem | undefined>;
    /**
     * Метод получает детальную информацию о подписи.
     *
     * Возвращает подробную информацию о подписи и публичном ключе,
     * с помощью которого она вычислена. Из публичного ключа
     * извлекаются атрибуты выдавшего и получившего сертификат, а также
     * даты действия, название и номер публичного ключа. Атрибуты именуются в
     * соответствии с RFC 2253, однако атрибуты, не входящие
     * в список стандартных [[CertNames]], не кодируются в формат hex.
     *
     * В примере использутся подпись, ранее полученная из архива подписей приложения.
     *
     * ```typescript
     * const signDetails = await signHistory[0].signs[0].getSignDetails();
     * ```
     */
    getDetails(): Promise<SignDetails>;
}
/**
 * # Запрос сохранения подписи
 *
 * Представляет набор данных, необходимый для сохранения подписи в системе.
 */
interface NewSign {
    /**
     * Содержимое подписи в формате base64.
     */
    sign: string;
    /**
     * Тип сохраняемой подписи.
     */
    signType?: SignType;
    /**
     * Код провайдера, с помощью которого вычислена подпись.
     */
    codeProvider: string;
    /**
     * Подписанные данные.
     *
     * Для файлов используется хэш.
     */
    body: SignedContent;
    /**
     * Отпечаток подписанных данных.
     */
    hash?: SignHash;
}
/**
 * # Формат внутреннего отпечатка данных
 *
 * Позволяет проверить актуальность данных элемента приложения,
 * установить, отличаются ли подписанные данные у двух подписей.
 */
interface SignData {
    /**
     * Хэш данных.
     */
    hash: SignHash;
    /**
     * Подписанные данные.
     */
    body: SignedContent;
    /**
     * Тип подписи.
     */
    type: SignType;
}
/**
 * # Информация о подписи
 *
 * Объект включает в себя базовую информацию о подписи (данные из публичного
 * ключа, который из неё извлекается). Извлечение данных происходит по RFC 5652.
 */
interface SignDetails {
    /**
     * Тип подписи.
     */
    type: SignType;
    /**
     * Статус подписи.
     */
    status: SignStatus;
    /**
     * Создатель подписи.
     */
    createdBy: string;
    /**
     * Дата подписания.
     */
    signDate: string;
    /**
     * Дата оконачания действия подписи.
     */
    signValidUntilAt: string;
    /**
     * Дата окончания действия сертификата.
     */
    certValidUntilAt: string;
    /**
     * Номер сертификата.
     */
    certSerialNumber: string;
    /**
     * Имя сертификата.
     */
    commonName: string;
    /**
     * Информация о получателе сертификата.
     *
     * В поле хранится объект, содержащий информацию, извлеченную из сертификата.
     * Извлекаются базовые и дополнительные поля.
     */
    subject: CertNames;
    /**
     * Информация о выдавшем сертификат.
     *
     * В поле хранится объект, содержащий информацию, извлеченную из сертификата.
     * Извлекаются базовые и дополнительные поля.
     */
    issuer: CertNames;
    /**
     * Информация о цепочке сертификатов.
     *
     * В поле хранится массив объектов, содержащий информацию, извлеченную из сертификата.
     * Извлекаются базовые и дополнительные поля.
     */
    chain: CertData[];
}
/**
 * # Информация о сертификате
 *
 * Объект включает в себя базовую информацию о подписи. Извлечение данных происходит по RFC 5652.
 */
interface CertData {
    /**
     * Информация о получателе сертификата.
     *
     * В поле хранится объект, содержащий информацию, извлеченную из сертификата.
     * Извлекаются базовые и дополнительные поля.
     */
    subject: CertNames;
    /**
     * Информация о выдавшем сертификат.
     *
     * В поле хранится объект, содержащий информацию, извлеченную из сертификата.
     * Извлекаются базовые и дополнительные поля.
     */
    issuer: CertNames;
}
/**
 * # Значения полей сертификата
 *
 * Значения полей публичного ключа, содержащие информацию, извлеченную из сертификата.
 * Извлекаются все данные, хранящиеся в сертификате. Распознаются базовые поля сертификата:
 * C, O, OU, CN, SERIALNUMBER, L, ST, STREET, POSTALCODE — и дополнительные поля,
 * хранящиеся в сертификате по RFC 2253. Атрибуты, не попадающие в список базовых полей, не кодируются в
 * формат hex.
 */
interface CertNames {
    [key: string]: string;
}
/**
 * # Типы подписи
 */
declare enum SignType {
    /**
     * # Неизвестный тип подписи
     */
    Unknown = "unknown",
    /**
     * # Подпись атрибутов
     *
     * Подписываются атрибуты приложения. В процессе подписания атрибуты сохраняются
     * в файл в виде объекта, представленного в формате JSON.
     */
    Attributes = "attributes",
    /**
     * # Подпись файла
     *
     * Подписывается содержимое файла или контрольная сумма —
     * зависит от конечного провайдера.
     */
    File = "file",
    /**
     * # Подпись решения в документообороте
     *
     * Подписывается решение согласования элемента приложения.
     */
    Docflow = "docflow"
}
/**
 * # Типы подписи
 *
 * @deprecated Используйте `SignType`.
 */
declare enum SignTypes {
    /**
     * # Неизвестный тип подписи
     */
    Unknown = "unknown",
    /**
     * # Подпись атрибутов
     *
     * Подписываются атрибуты приложения. В процессе подписания атрибуты сохраняются
     * в файл в виде объекта, представленного в формате JSON.
     */
    Attributes = "attributes",
    /**
     * # Подпись файла
     *
     * Подписывается содержимое файла или контрольная сумма —
     * зависит от конечного провайдера.
     */
    File = "file",
    /**
     * # Подпись решения в документообороте
     *
     * Подписывается решение о согласовании элемента приложения.
     */
    Docflow = "docflow"
}
/**
 * # Статусы подписи
 *
 * Представляют статус подписи в некоторый момент времени.
 */
declare enum SignStatus {
    /**
     * # Статус подписи неизвестен
     */
    Unknown = "unknown",
    /**
     * # Подпись готова к использованию, содержимое не проверялось
     */
    No_validation = "no_validation",
    /**
     * # Подпись сохранена и прошла процедуры проверки содержимого
     */
    Valid = "valid",
    /**
     * # Содержимое подписи содержит ошибки, ее нельзя использовать
     */
    Invalid = "invalid",
    /**
     * # Подпись устарела
     */
    Outdated = "outdated"
}
/**
 * # Хэш подписанных данных
 *
 * Последовательность символов, вычисляемая на основе типа подписи и контрольных данных элемента приложения,
 * которая обеспечивает защиту от изменения контрольных данных элемента после подписания.
 */
declare type SignHash = string;
/**
 * # Подписанные данные
 *
 * Хранит данные, подписанные пользователем:
 *
 * * при подписи атрибутов хранит объект данных в формате JSON;
 *
 * * при подписи файлов хранит хэш файла, идентифицирующий его содержимое в системе;
 *
 * * при подписи решений в процессе согласования хранит информацию о полученном решении.
 */
declare type SignedContent = string;
/**
 * # Данные объекта Нумератор
 *
 * Предоставляет набор данных, необходимый для установления шага нумератора, и его следующий номер.
 */
interface SerialData extends BaseItemData {
    /**
     * Номер в виде UUID.
     */
    readonly id: string;
    /**
     * Версия текущего нумератора.
     */
    readonly version: string;
    /**
     * Название.
     */
    readonly name: string;
    /**
     * Следующий номер.
     */
    readonly nextValue: string;
    /**
     * Настройки.
     */
    readonly settings: SerialSettings;
}
/**
 * # Настройки нумератора
 */
interface SerialSettings {
    /**
     * Использовать номера, для которых резервирование было отменено.
     */
    readonly useReleased: boolean;
    /**
     * Шаг нумерации.
     */
    readonly iterationStep: number;
}
/**
 * # Веб-запросы
 *
 * Подробно про использование веб-запросов к внешним ресурсам в сценариях
 * смотрите в [статье про работу с внешними сервисами](../pages/quick-start/intro_fetch.html).
 * @packageDocumentation
 */
/**
 * # Параметры запроса
 */
interface FetchRequest {
    /**
     * Тело запроса.
     */
    body?: string | FormData;
    /**
     * Заголовки.
     */
    headers?: Record<string, string>;
    /**
     * HTTP-метод запроса.
     *
     * По умолчанию используется `GET`.
     */
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | string;
    /**
     * Параметры URL-строки для веб-запроса.
     *
     * Сформировать веб-запрос для адреса `https://yandex.ru/search/?text=elma365` можно таким образом:
     * ```typescript
     * const result = await fetch('https://yandex.ru/search/', {
     *   query: { 'text': 'elma365' }
     * });
     * ```
     *
     * Существующие параметры в строке адреса будут объединены с тем, что указано в `query`.
     */
    query?: URLSearchParams;
}
/**
 * # Результат запроса
 */
interface FetchResponse {
    /**
     * Дождаться полного ответа и разобрать его как JSON.
     */
    json(): Promise<any>;
    /**
     * Дождаться полного ответа и вернуть его текстом.
     */
    text(): Promise<string>;
    /**
     * Дождаться полного ответа и вернуть его как массив бинарных данных.
     */
    arrayBuffer(): Promise<ArrayBuffer>;
    /**
     * Заголовки ответа.
     *
     * ```
     * const result = await fetch('https://yandex.ru');
     * // Получение списка заголовков ответа в json-формате.
     * const headersJson = JSON.stringify(Object.fromEntries(result.headers));
     * // Получение значения заголовка ответа.
     * const setCookie = result.headers.get('set-cookie');
     * ```
     */
    headers: ReadonlyMap<string, string>;
    /**
     * Сокращённый флаг того, что код ответа меньше 300.
     */
    ok: boolean;
    /**
     * Размер ответа в байтах.
     */
    size: number;
    /**
     * Код ответа HTTP.
     *
     * Подробнее о кодах ответа читайте в [[HttpStatusCode]].
     */
    status: HttpStatusCode | number;
    /**
     * Текстовое представление кода ответа.
     */
    statusText: string;
    /**
     * Таймаут на время выполнения запроса в миллисекундах.
     */
    timeout: number;
    /**
     * Тип ответа.
     */
    type: 'basic' | 'cors' | 'default' | 'error' | 'opaque' | 'opaqueredirect';
    /**
     * Адрес ресурса.
     */
    url: string;
}
/**
 * # Метод для выполнения веб-запроса
 *
 * Подробно об использовании смотрите в [статье про метод fetch](../pages/quick-start/intro_fetch.html#fetch).
 *
 * @param url Ссылка на запрашиваемый ресурс.
 * @param init Параметры запроса.
 * @returns Результат запроса ресурса.
 */
declare function fetch(url: string, init?: FetchRequest): Promise<FetchResponse>;
/**
 * # Параметры URL запроса
 *
 * Используются в объекте [[FetchRequest]].
 */
declare type URLSearchParams = Record<string, string | string[]>;
/**
 * # Код ответа (состояния) HTTP
 *
 * Код ответа показывает, был ли успешно выполнен определённый HTTP-запрос.
 * Коды разделены на пять классов:
 * * Информационные: 100–199,
 * * Успешные: 200–299,
 * * Перенаправления: 300–399,
 * * Клиентские ошибки: 400–499,
 * * Серверные ошибки: 500–599.
 *
 * Данное перечисление содержит только часто используемые коды.
 *
 * Подробнее:
 * * {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}
 * * {@link https://developer.mozilla.org/ru/docs/Web/HTTP/Status}
 * * {@link https://datatracker.ietf.org/doc/html/rfc7231#section-6}
 */
declare enum HttpStatusCode {
    /**
     * # Продолжить
     *
     * Этот промежуточный ответ указывает, что запрос успешно принят,
     * и клиент может продолжать присылать запросы
     * либо проигнорировать этот ответ, если запрос был завершён.
     */
    CONTINUE = 100,
    /**
     * # Переключение протокола
     *
     * Этот код присылается в ответ на запрос клиента,
     * содержащий заголовок `Upgrade:`, и указывает,
     * что сервер переключился на протокол, который был указан в заголовке.
     *
     * Эта возможность позволяет перейти на несовместимую версию протокола и обычно не используется.
     */
    SWITCHING_PROTOCOLS = 101,
    /**
     * # В обработке
     *
     * Этот код указывает, что сервер получил запрос и обрабатывает его,
     * но обработка ещё не завершена.
     */
    PROCESSING = 102,
    /**
     * # Успешно
     *
     * Запрос успешно обработан. Что означает «успешно»
     * зависит от метода HTTP, который был запрошен:
     * * GET: Запрошенный ресурс был найден и передан в теле ответа.
     * * HEAD: Заголовки переданы в ответе.
     * * POST: Ресурс, описывающий результат действия сервера на запрос, передан в теле ответа.
     */
    OK = 200,
    /**
     * # Создан
     *
     * Запрос успешно выполнен, и в результате был создан ресурс.
     * Этот код обычно присылается в ответ на запрос PUT.
     */
    CREATED = 201,
    /**
     * # Принят
     *
     * Запрос принят, но ещё не обработан.
     *
     * Не поддерживается, т. е. нет способа с помощью HTTP позже отправить асинхронный ответ,
     * который будет показывать итог обработки запроса.
     * Код предназначен для случаев, когда запрос обрабатывается другим процессом
     * или сервером, либо для пакетной обработки.
     */
    ACCEPTED = 202,
    /**
     * # Информация не авторитетна
     *
     * Этот код ответа означает, что информация, которая возвращена,
     * была предоставлена не от исходного сервера, а из какого-либо другого источника.
     * Во всех остальных ситуациях более предпочтителен код ответа `200 OK`.
     */
    NON_AUTHORITATIVE_INFORMATION = 203,
    /**
     * # Нет содержимого
     *
     * Нет содержимого для ответа на запрос, но заголовки ответа,
     * которые могут быть полезны, присылаются.
     * Клиент может использовать их для обновления кэшированных заголовков,
     * полученных ранее для этого ресурса.
     */
    NO_CONTENT = 204,
    /**
     * # Сбросить содержимое
     *
     * Этот код присылается после успешной обработки запроса и сообщает клиенту,
     * что необходимо сбросить отображение документа, присланного в ответ на запрос.
     */
    RESET_CONTENT = 205,
    /**
     * # Частичное содержимое
     *
     * Этот код ответа используется, когда клиент присылает заголовок диапазона,
     * чтобы выполнить загрузку раздельно, в несколько потоков.
     */
    PARTIAL_CONTENT = 206,
    /**
     * # Множественный выбор
     *
     * Этот код ответа присылается, когда запрос имеет более чем один возможный ответ,
     * и агент пользователя или пользователь должен выбрать один из ответов.
     * Не существует стандартизированного способа выбора одного из полученных ответов.
     */
    MULTIPLE_CHOICES = 300,
    /**
     * # Перемещён на постоянной основе
     *
     * Этот код ответа означает, что URI запрашиваемого ресурса был изменён.
     * Возможно, новый URI будет предоставлен в ответе.
     */
    MOVED_PERMANENTLY = 301,
    /**
     * # Найден
     *
     * Этот код ответа означает, что запрошенный ресурс временно изменён.
     * В будущем новые изменения могут быть доступны по данному URI.
     * Таким образом, в последующих запросах клиент должен продолжать использовать этот URI.
     */
    FOUND = 302,
    /**
     * # Просмотр других ресурсов
     *
     * Этот код ответа присылается, чтобы направлять клиента с запросом GET
     * для получения запрашиваемого ресурса в другой URI.
     */
    SEE_OTHER = 303,
    /**
     * # Не модифицирован
     *
     * Используется для кэширования. Это код ответа означает, что запрошенный ресурс не был изменён.
     * Таким образом, клиент может продолжать использовать кэшированную версию ответа.
     */
    NOT_MODIFIED = 304,
    /**
     * # Временное перенаправление
     *
     * Сервер отправил этот ответ, чтобы клиент получил запрошенный ресурс на другой URL-адрес
     * с тем же методом, который использовал предыдущий запрос.
     *
     * Данный код ответа похож на `302 Found`, за исключением того,
     * что в `307 Temporary Redirect` агент пользователя не должен изменять используемый метод HTTP:
     * если в первом запросе использовался POST, то во втором запросе также должен быть использован POST.
     */
    TEMPORARY_REDIRECT = 307,
    /**
     * # Перенаправление на постоянной основе
     *
     * Это означает, что ресурс теперь постоянно находится в другом URL,
     * указанном в заголовке `Location: HTTP Response`.
     *
     * Данный код ответа похож на `301 Moved Permanently`,
     * за исключением того, что агент пользователя не должен изменять используемый метод HTTP:
     * если в первом запросе использовался POST, то во втором запросе также должен быть использован POST.
     */
    PERMANENT_REDIRECT = 308,
    /**
     * # Плохой запрос
     *
     * Этот ответ означает, что сервер не понимает запрос из-за неверного синтаксиса.
     */
    BAD_REQUEST = 400,
    /**
     * # Не авторизован
     *
     * Для получения запрашиваемого ответа нужна аутентификация.
     * Статус похож на статус 403, но,в этом случае, аутентификация возможна.
     */
    UNAUTHORIZED = 401,
    /**
     * # Необходима оплата
     *
     * Этот код ответа зарезервирован для будущего использования.
     * Первоначальная цель для создания этого когда была в использовании его
     * для цифровых платёжных систем (на данный момент не используется).
     *
     * Некоторые платформы используют этот код в программном API
     * при превышении доступных лимитов.
     */
    PAYMENT_REQUIRED = 402,
    /**
     * # Запрещён
     *
     * У клиента нет прав доступа к содержимому,
     * поэтому сервер отказывается удовлетворить запрос.
     */
    FORBIDDEN = 403,
    /**
     * # Не найден
     *
     * Сервер не может найти запрашиваемый ресурс.
     * Код этого ответа, наверное, самый известный из-за частоты его появления в вебе.
     */
    NOT_FOUND = 404,
    /**
     * # Метод не разрешён
     *
     * Сервер знает о запрашиваемом методе, но он был деактивирован и не может быть использован.
     * Два обязательных метода, GET и HEAD, никогда не должны быть деактивированы
     * и не должны возвращать этот код ошибки.
     */
    METHOD_NOT_ALLOWED = 405,
    /**
     * # Неприемлемо
     *
     * Этот ответ используется, когда веб-сервер после выполнения
     * server-driven content negotiation не находит контента,
     * отвечающего критериям, полученным от агента пользователя.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#server-driven_content_negotiation}
     */
    NOT_ACCEPTABLE = 406,
    /**
     * # Необходима аутентификация прокси-сервера
     *
     * Этот код ответа аналогичен коду 401, только аутентификация требуется для прокси-сервера.
     */
    PROXY_AUTHENTICATION_REQUIRED = 407,
    /**
     * # Таймаут соединения
     *
     * Ответ с таким кодом может прийти даже без предшествующего запроса.
     * Он означает, что сервер хотел бы отключить это неиспользуемое соединение.
     * Также учитывайте, что некоторые серверы прерывают соединение, не отправляя подобных сообщений.
     */
    REQUEST_TIMEOUT = 408,
    /**
     * # Конфликт
     *
     * Этот ответ отсылается, когда выполнение запроса конфликтует с текущим состоянием сервера.
     */
    CONFLICT = 409,
    /**
     * # Отсутствует
     *
     * Этот ответ отсылается, когда запрашиваемый контент удалён с сервера.
     */
    GONE = 410,
    /**
     * # Необходимо указать длину
     *
     * Запрос отклонён, потому что сервер требует указание заголовка `Content-Length`, но он не указан.
     */
    LENGTH_REQUIRED = 411,
    /**
     * # Предварительное условие не может быть выполнено
     *
     * Клиент указал в своих заголовках условия, которые сервер не может выполнить.
     */
    PRECONDITION_FAILED = 412,
    /**
     * # Слишком большой запрос
     *
     * Размер запроса превышает лимит, объявленный сервером. Сервер может закрыть соединение,
     * вернув заголовок `Retry-After`.
     */
    PAYLOAD_TOO_LARGE = 413,
    /**
     * # Слишком длинный URI
     *
     * URI, запрашиваемый клиентом, слишком длинный для того, чтобы сервер смог его обработать.
     */
    URI_TOO_LONG = 414,
    /**
     * # Неподдерживаемый тип данных
     *
     * Формат запрашиваемых данных не поддерживается сервером, поэтому запрос отклонён.
     */
    UNSUPPORTED_MEDIA_TYPE = 415,
    /**
     * # Невозможно предоставить диапазон
     *
     * Диапазон, указанный заголовком запроса `Range`, невозможно предоставить;
     * возможно, он выходит за пределы переданного URI.
     */
    RANGE_NOT_SATISFIABLE = 416,
    /**
     * # Ожидание не может быть выполнено
     *
     * Этот код ответа означает, что ожидание,
     * полученное из заголовка запроса `Expect`,
     * не может быть выполнено сервером.
     */
    EXPECTATION_FAILED = 417,
    /**
     * # I am a teapot
     *
     * This code was defined in 1998 as one of the traditional IETF April Fools' jokes,
     * in RFC 2324, Hyper Text Coffee Pot Control Protocol,
     * and is not expected to be implemented by actual HTTP servers.
     * The RFC specifies this code should be returned by teapots requested to brew coffee.
     * This HTTP status is used as an Easter egg in some websites, including Google.com.
     */
    I_AM_A_TEAPOT = 418,
    /**
     * # Необходимо предварительное условие
     *
     * Сервер указывает клиенту на необходимость
     * использования в запросе заголовков условий,
     * наподобие `If-Match`.
     */
    PRECONDITION_REQUIRED = 428,
    /**
     * # Слишком много запросов
     *
     * Клиент попытался отправить слишком много запросов за короткое время,
     * что может указывать, например, на попытку DDoS-атаки.
     * Может сопровождаться заголовком `Retry-After`, указывающим, через какое время можно повторить запрос.
     */
    TOO_MANY_REQUESTS = 429,
    /**
     * # Превышена допустимая длина заголовков
     *
     * Сервер не обязан отвечать этим кодом. Вместо этого он может просто сбросить соединение.
     */
    REQUEST_HEADER_FIELDS_TOO_LARGE = 431,
    /**
     * # Недоступно по закону
     *
     * Доступ к ресурсу закрыт по юридическим причинам, например,
     * по требованию органов государственной власти
     * или по требованию правообладателя в случае нарушения авторских прав.
     *
     * Код ошибки является отсылкой к роману Рэя Брэдбери «451 градус по Фаренгейту».
     */
    UNAVAILABLE_FOR_LEGAL_REASONS = 451,
    /**
     * # Внутренняя ошибка сервера
     *
     * Сервер столкнулся с ситуацией, которую он не умеет обрабатывать.
     */
    INTERNAL_SERVER_ERROR = 500,
    /**
     * # Не реализовано
     *
     * Метод запроса не поддерживается сервером и не может быть обработан.
     * Если же метод серверу известен, но он неприменим к данному ресурсу,
     * то должен вернуться ответ `405 Method Not Allowed`.
     */
    NOT_IMPLEMENTED = 501,
    /**
     * # Плохой шлюз
     *
     * Эта ошибка означает, что во время работы в качестве шлюза для получения ответа,
     * нужного для обработки запроса, сервер получил недействительный (недопустимый) ответ.
     */
    BAD_GATEWAY = 502,
    /**
     * # Обслуживание недоступно
     *
     * Сервер не готов обработать запрос.
     * Зачастую причинами являются отключение сервера или то, что он перегружен.
     * Обратите внимание, что вместе с этим ответом следует отправлять
     * удобную для пользователя страницу с объяснением проблемы.
     *
     * Этот ответ должен использоваться для временных состояний.
     * HTTP-заголовок `Retry-After` должен, если это возможно, содержать
     * предполагаемое время до восстановления нормальной работы.
     *
     * Веб-мастер также должен позаботиться о заголовках, связанных с кэшированием,
     * которые отправляются вместе с этим ответом. Такие ответы,
     * указывающие на временное состояние сервера, обычно не должны кэшироваться.
     */
    SERVICE_UNAVAILABLE = 503,
    /**
     * # Таймаут шлюза
     *
     * Сервер в роли шлюза или прокси-сервера не дождался ответа от вышестоящего сервера
     * для завершения текущего запроса.
     */
    GATEWAY_TIMEOUT = 504,
    /**
     * # HTTP-версия не поддерживается
     *
     * HTTP-версия, используемая в запросе, не поддерживается сервером.
     */
    HTTP_VERSION_NOT_SUPPORTED = 505
}
/**
 * @ignore
 *
 * @packageDocumentation
 */
/**
 * @ignore
 */
interface FormData {
    append(name: string, value: string): void;
    append(name: string, buf: ArrayBuffer, fileName: string): void;
}
/**
 * @ignore
 */
interface FormDataConstructor {
    new (): FormData;
}
/**
 * @ignore
 */
declare const FormData: FormDataConstructor;
/**
 * @ignore
 */
declare function atob(encodedString: string): string;
/**
 * @ignore
 */
declare function btoa(rawString: string): string;
/**
 * @ignore
 */
interface CallbackRequest {
    method: string;
    header: Record<string, string>;
    body: string;
}
/**
 * @ignore
 */
declare function setTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;
/**
 * @ignore
 */
declare type TimerHandler = string | Function;
/**
 * # Права доступа
 *
 * Применяются для установки и получения списка прав для элементов приложения.
 *
 * Подробнее читайте в статье {@page Права доступа}.
 * @packageDocumentation
 */
/**
 * # Настройки прав доступа для коллекции
 *
 * Получить эти настройки можно с помощью метода [[Application.getPermissions]].
 */
interface TPermissionsSettings {
    /**
     * Вид разграничения прав коллекции. Доступны следующие варианты:
     *
     * * на уровне коллекции (`collection`),
     * * на уровне папок (`directory`),
     * * на уровне отдельных элементов (`row`).
     */
    accessType: string;
    /**
     * Права доступа.
     */
    __permissions: TPermissions;
}
/**
 * # Список прав доступа
 *
 * Дадим пользователю право на создание:
 * ```typescript
 * const user = Context.data.__createdBy;
 * const permissions = new Permissions([new PermissionValue(user, [PermissionType.CREATE])]);
 *
 * await Application.setPermissions(permissions);
 * ```
 */
interface TPermissions {
    /**
     * Список предоставленных разрешений.
     */
    values: TPermissionValue[];
    /**
     * Признак наследования от родительской директории.
     */
    inheritParent?: boolean;
}
/**
 * @ignore
 */
declare type PermissionsConstructor = new (values: TPermissionValue[], inheritParent?: boolean) => TPermissions;
/**
 * @ignore
 */
declare const Permissions: PermissionsConstructor;
/**
 * # Строка прав доступа
 *
 * Строка прав доступа конкретного пользователя, группы или элемента оргструктуры.
 *
 * ```typescript
 * const permission = new PermissionValue(user, [PermissionType.READ, PermissionType.CREATE, PermissionType.UPDATE]);
 * ```
 */
interface TPermissionValue {
    /**
     * Ссылка на пользователя, группу, элемент оргструктуры или роль.
     */
    group?: TPermissionOrgunit;
    /**
     * Поле приложения типа «Пользователи».
     *
     * ```typescript
     * const permission = new PermissionValue(Application.fields.ispolnitel, [PermissionType.READ]);
     * ```
     */
    orgunitField?: TOrgunitField;
    /**
     * Список типов прав доступа.
     */
    types: PermissionType[];
    /**
     * Признак наследования от родительской директории.
     */
    inherited?: boolean;
}
/**
 * @ignore
 */
interface PermissionRole {
    id: string;
    kind: 'role';
}
/**
 * @ignore
 */
declare type TOrgunitItemRef = UserGroupItemRef | UserItemRef | OrganisationStructureItemRef;
/**
 * @ignore
 */
declare type TOrgunitField = StaticUserField | StaticRoleField;
/**
 * @ignore
 */
declare type TPermissionOrgunit = TOrgunitItemRef | PermissionRole;
/**
 * @ignore
 */
declare type PermissionValueConstructor = new (orgunit: TPermissionOrgunit | TOrgunitField, types: PermissionType[], inheritParent?: boolean) => TPermissionValue;
/**
 * @ignore
 */
declare const PermissionValue: PermissionValueConstructor;
/**
 * # Типы прав доступа
 *
 * Используются при создании строки прав доступа [[TPermissionValue]].
 * ```typescript
 * new PermissionValue(user, [PermissionType.READ, PermissionType.UPDATE])
 * ```
 */
declare enum PermissionType {
    /**
     * # Просмотр/Загрузка
     */
    READ = "read",
    /**
     * # Создание
     */
    CREATE = "create",
    /**
     * # Редактирование
     */
    UPDATE = "update",
    /**
     * # Удаление
     */
    DELETE = "delete",
    /**
     * # Назначение прав
     */
    ASSIGN = "assign",
    /**
     * # Управление процессами
     */
    BPMANAGE = "bpmanage"
}
/**
 * # Документооборот
 *
 * Работа с номенклатурой (делами), регистрациями и резервированием регистрационных номеров документов,
 * а также с листами согласования и ознакомления
 * осуществляется с помощью методов типа [[DocflowApplicationItemRef]].
 *
 * ## Работа с листами согласования/ознакомления
 *
 * Получить листы согласования/ознакомления можно с помощью методов [[getApprovalLists]] и
 * [[getInformLists]]. Так можно получить листы согласования:
 * ```typescript
 * const item = await Context.data.n1;
 * const approvalLists = await item.docflow().getApprovalLists();
 * ```
 *
 * В дальнейшем можно продолжать работу с листами — например, получить статусы,
 * списки согласующих/информируемых (респондентов), даты создания и изменения:
 * ```typescript
 * for (const list of approvalLists) {
 *     const {status, respondents, createdAt: __createdAt} = list;
 * }
 * ```
 *
 * Листы согласования/ознакомления представлены типом [[BaseList]].
 *
 * ## Работа с номенклатурой (делами)
 *
 * Получить конкретное дело можно с помощью метода [[DocflowApplicationItemRef.getNomenclature]].
 * Для получения данных дела необходимо передать его идентификатор. Его можно получить двумя способами.
 *
 * Пример получения идентификатора из настроек регистрации приложения:
 * ```typescript
 * const settings = await Application.getSettings();
 * settings.registrationSettings.nomenclatureIds.forEach(nomenclatureId => {
 *     ...
 * });
 * ```
 * Пример получения идентификатора из списка регистраций элемента приложения:
 * ```typescript
 * const item = Context.data.d1!
 * const registrations = item.docflow().getRegistrations();
 * registrations.forEach(registration => {
 *     const {nomenclatureId} = registration;
 *     ...
 * })
 * ```
 * Данные дела представлены типом [[TNomenclature]].
 * Получение и обработка данных дела может выглядеть так:
 * ```typescript
 * const item = Context.data.d1!
 * const settings = await Application.getSettings();
 * const nomenclatures = [];
 * for (const nomenclatureId of settings.registrationSettings.nomenclatureIds) {
 *     const nomenclature = await item.docflow().getNomenclature(nomenclatureId);
 *     if (nomenclature !== undefined) {
 *         const {id: __id, name: __name} = nomenclature;
 *         nomenclatures.push(nomenclature);
 *     }
 * }
 * ```
 *
 * ## Регистрация и резервирование регистрационных номеров приложений
 *
 * Каждое приложение может быть зарегистрировано в нескольких делах, если такое предусмотрено настройками приложения.
 * Для получения регистраций документа можно воспользоваться методом [[DocflowApplicationItemRef.getRegistrations]].
 * Регистрации имеют тип [[ApplicationItemRegistration]]. Например, получить идентификаторы дел, в которых могут быть
 * зарегистрированы элементы приложения, можно следующим образом:
 * ```typescript
 * const item = Context.data.d1!
 * const registrations = await item.docflow().getRegistrations();
 * for (const registration of registrations) {
 *     const nomenclatureId = registration.nomenclatureId;
 * }
 * ```
 *
 * Для управления регистрациями можно использовать методы [[DocflowApplicationItemRef.register]] и
 * [[DocflowApplicationItemRef.deleteReservation]]. Данные методы принимают идентификатор дела, в котором надо зарегистрировать
 * элемент приложения или для которого нужно отменить регистрацию.
 * Пример регистрации элемента приложения для всех дел из настроек приложения:
 * ```typescript
 * const item = Context.data.d1!
 * const settings = await Application.getSettings();
 * settings.registrationSettings.nomenclatureIds.forEach(nomenclatureId => {
 *      item.docflow().register(nomenclatureId);
 * })
 * ```
 *
 * Также существует возможность ручной регистрации с указанием номера регистрации.
 * Ручная регистрация доступна в том случае, если предусмотрена настройками дела.
 * Для ручной регистрации элемента приложения можно использовать метод [[DocflowApplicationItemRef.manualRegister]].
 * Пример ручной регистрации:
 * ```typescript
 * const item = Context.data.d1!
 * const settings = await Application.getSettings();
 * settings.registrationSettings.nomenclatureIds.forEach(nomenclatureId => {
 *      item.docflow().manualRegister("Номер тест 1", nomenclatureId);
 * })
 * ```
 *
 * Для предварительного резервирования номера регистрации можно использовать метод [[DocflowApplicationItemRef.reserve]].
 * Этот метод возвращает зарезервированный номер.
 * Для отмены резервирования номера используется метод [[DocflowApplicationItemRef.deleteReservation]].
 * Оба метода принимают идентификатор дела в качестве параметра.
 * При ошибке резервирования будет сгенерирована ошибка.
 * Пример резервирования номера для конкретного дела:
 * ```typescript
 * const item = Context.data.d1!
 * const settings = await Application.getSettings();
 * const nomenclatures = [];
 * for (const nomenclatureId of settings.registrationSettings.nomenclatureIds) {
 *     const nomenclature = await item.docflow().getNomenclature(nomenclatureId);
 *     if (nomenclature !== undefined) {
 *         nomenclatures.push(nomenclature);
 *     }
 * }
 * const nomenclatureName = 'Название нужного дела';
 * const nomenclatureForReservation = nomenclatures.find(nom => nom.name === nomenclatureName);
 * if (nomenclatureForReservation !== undefined) {
 *     const reservedNumber = await item.docflow().reserve(nomenclatureForReservation.__id);
 * }
 * ```
 * @packageDocumentation
 */
/**
 * # Тип листа
 */
declare enum DocflowListType {
    /**
     * # Лист согласования
     */
    Approval = "approval",
    /**
     * # Лист ознакомления
     */
    Inform = "inform"
}
/**
 * # Статус листа согласования/ознакомления
 */
declare enum DocflowListStatus {
    /**
     * # Операция выполняется
     */
    InProgress = "in_progress",
    /**
     * # Согласование завершилось успешно
     *
     * Согласование завершено; документ согласован участниками согласования.
     */
    Approved = "approved",
    /**
     * # Согласование завершалась отменой
     *
     * Участники согласования не согласовали документ.
     */
    Rejected = "rejected",
    /**
     * # Ознакомление завершено
     */
    Done = "done",
    /**
     * # Процесс прерван
     */
    Terminated = "terminated"
}
/**
 * # Лист согласования/ознакомления
 */
interface BaseList {
    /**
     * Идентификатор листа.
     */
    readonly __id: string;
    /**
     * Тип листа.
     */
    readonly type: DocflowListType;
    /**
     * Статус.
     */
    readonly status: DocflowListStatus;
    /**
     * Участники процесса.
     */
    readonly respondents: Respondent[];
    /**
     * Раздел, в котором находится объект согласования/ознакомления.
     */
    readonly targetNamespace: string;
    /**
     * Код объекта согласования/ознакомления.
     */
    readonly targetCode: string;
    /**
     * Идентификатор объекта согласования/ознакомления.
     */
    readonly targetId: string;
    /**
     * Версия объекта согласования/ознакомления.
     */
    readonly targetVersion: string;
    /**
     * Дата создания.
     */
    readonly __createdAt: TDatetime;
    /**
     * Идентификатор автора.
     */
    readonly __createdBy: string;
    /**
     * Дата обновления.
     */
    readonly __updatedAt: TDatetime;
    /**
     * Идентификатор пользователя, изменившего лист.
     */
    readonly __updatedBy: string;
    /**
     * Дата удаления.
     */
    readonly __deletedAt?: TDatetime;
}
/**
 * # Участник листа согласования/ознакомления
 */
interface Respondent {
    /**
     * Идентификатор участника.
     */
    readonly id: string;
    /**
     * @deprecated
     *
     * Имя участника.
     */
    readonly name: string;
    /**
     * Решение участника (статус).
     */
    readonly status: DocflowListStatus;
    /**
     * Текст решения участника.
     */
    readonly statusText: string;
    /**
     * Признак использования пользовательского статуса участником в листе согласования/ознакомления.
     */
    readonly customStatusUsed: boolean;
    /**
     * Тип листа.
     */
    readonly listType: DocflowListType;
    /**
     * Комментарий к решению (отказу).
     */
    readonly comment: string;
    /**
     * Дата последнего обновления.
     */
    readonly ts: TDatetime;
}
/**
 * # Объект для работы с регистрациями и листами элемента
 */
interface DocflowApplicationItemRef {
    /**
     * Метод загружает активные листы согласования.
     *
     * ```typescript
     * const item = await Context.data.n1;
     * const approvalLists = await item.docflow().getApprovalLists();
     * ```
     *
     * @returns Активные листы согласования.
     */
    getApprovalLists(): Promise<BaseList[]>;
    /**
     * Метод переводит лист согласования из архива в активный статус.
     *
     * ```typescript
     * // Активация всех листов из архива
     * const item = await Context.data.n1;
     * const approvalLists = await item.docflow().getApprovalArchivedLists();
     * approvalLists.forEach(list => item.docflow().unarchiveApprovalList(list.__id))
     * ```
     *
     * @param listId Номер листа.
     */
    unarchiveApprovalList(listId: string): Promise<void>;
    /**
     * Метод загружает активные листы ознакомления.
     *
     * ```typescript
     * const item = await Context.data.n1;
     * const approvalLists = await item.docflow().getInformLists();
     * ```
     *
     * @returns Активные листы ознакомления.
     */
    getInformLists(): Promise<BaseList[]>;
    /**
     * Метод загружает листы согласования, находящиеся в архиве.
     *
     * ```typescript
     * const item = await Context.data.n1;
     * const approvalLists = await item.docflow().getApprovalArchivedLists();
     * ```
     *
     * @returns Листы согласования в архиве.
     */
    getApprovalArchivedLists(): Promise<BaseList[]>;
    /**
      * Метод загружает листы ознакомления, находящиеся в архиве.
     *
     * ```typescript
     * const item = await Context.data.n1;
     * const approvalLists = await item.docflow().getInformArchivedLists();
     * ```
     *
     * @returns Листы ознакомления в архиве.
     */
    getInformArchivedLists(): Promise<BaseList[]>;
    /**
     * Метод получает список регистраций элемента приложения.
     *
     * ```typescript
     * const item = Context.data.d1!
     * await item.docflow().getRegistrations();
     * ```
     *
     * @returns Список регистраций элемента приложения.
     */
    getRegistrations(): Promise<ApplicationItemRegistration[]>;
    /**
     * Метод получает дело по номеру.
     *
     * ```typescript
     * const item = Context.data.d1!
     * const settings = await Application.getSettings();
     * const nomenclatures = [];
     * for (const nomenclatureId of settings.registrationSettings.nomenclatureIds) {
     *     const nomenclature = await item.docflow().getNomenclature(nomenclatureId);
     *     if (nomenclature !== undefined) {
     *         nomenclatures.push(nomenclature);
     *     }
     * }
     * ```
     *
     * @param nomenclatureId Номер дела.
     * @returns Дело, если найдено.
     */
    getNomenclature(nomenclatureId: string): Promise<TNomenclature | undefined>;
    /**
     * Метод резервирует номер для элемента приложения в конкретном деле.
     *
     * Номер будет сформирован автоматически в соответствии с шаблоном, установленным для дела.
     *
     * ```typescript
     * // Пример резервирования номера для элемента приложения в конкретном деле
     * const item = Context.data.d1!
     * const settings = await Application.getSettings();
     * const nomenclatures = [];
     * for (const nomenclatureId of settings.registrationSettings.nomenclatureIds) {
     *     const nomenclature = await item.docflow().getNomenclature(nomenclatureId);
     *     if (nomenclature !== undefined) {
     *         nomenclatures.push(nomenclature);
     *     }
     * }
     * const nomenclatureName = 'Название дела';
     * const nomenclatureForReservation = nomenclatures.find(nom => nom.name === nomenclatureName);
     * if (nomenclatureForReservation !== undefined) {
     *     const reservedNumber = await item.docflow().reserve(nomenclatureForReservation.__id);
     * }
     * ```
     *
     * @param nomenclatureId Номер дела.
     * @returns Зарезервированный номер.
     */
    reserve(nomenclatureId: string): Promise<string>;
    /**
     * Метод отменяет резервирование номера для элемента приложения в конкретном деле.
     *
     * ```typescript
     * // Пример отмены резервирования номера для элемента приложения в конкретном деле.
     * const item = Context.data.d1!
     * const settings = await Application.getSettings();
     * const nomenclatures = [];
     * for (const nomenclatureId of settings.registrationSettings.nomenclatureIds) {
     *     const nomenclature = await item.docflow().getNomenclature(nomenclatureId);
     *     if (nomenclature !== undefined) {
     *         nomenclatures.push(nomenclature);
     *     }
     * }
     * const nomenclatureName = 'Название дела'
     * const nomenclatureForReservation = nomenclatures.find(nom => nom.name === nomenclatureName);
     * if (nomenclatureForReservation !== undefined) {
     *     await item.docflow().deleteReservation(nomenclatureForReservation.__id);
     * }
     * ```
     *
     * @param nomenclatureId Номер дела.
     */
    deleteReservation(nomenclatureId: string): Promise<void>;
    /**
     * Метод автоматически регистрирует элемент приложения.
     *
     * Номер регистрации будет сформирован автоматически в соответствии с шаблоном, установленным для дела.
     * ```typescript
     * // Пример автоматической регистрации во всех доступных для приложения делах
     * const item = Context.data.d1!
     * const settings = await Application.getSettings();
     * settings.registrationSettings.nomenclatureIds.forEach(nomenclatureId => {
     *      item.docflow().register(nomenclatureId);
     * })
     * ```
     *
     * @param nomenclatureId Номер дела.
     * @returns Результат регистрации.
     */
    register(nomenclatureId: string): Promise<boolean>;
    /**
     * Метод вручную регистрирует элемент приложения.
     *
     * Для использования метода должна быть включена ручная регистрация в настройках дела.
     *
     * ```typescript
     * // Пример ручной регистрации всех элементов приложения в делах, доступных для приложения
     * const item = Context.data.d1!
     * const settings = await Application.getSettings();
     * settings.registrationSettings.nomenclatureIds.forEach(nomenclatureId => {
     *      item.docflow().manualRegister("Номер тест 1", nomenclatureId);
     * })
     * ```
     *
     * @param nameReg Номер регистрации.
     * @param nomenclatureId Номер дела.
     * @returns Результат регистрации.
     */
    manualRegister(nameReg: string, nomenclatureId: string): Promise<boolean>;
    /**
     * Метод удаляет регистрацию элемента приложения.
     *
     * ```typescript
     * // Пример удаления регистрации во всех делах для элемента приложения типа Документ
     * const item = Context.data.d1!
     * const settings = await Application.getSettings();
     * settings.registrationSettings.nomenclatureIds.forEach(nomenclatureId => {
     *      item.docflow().deleteRegistration(nomenclatureId);
     * })
     * ```
     *
     * @param nomenclatureId Номер дела.
     * @returns Результат удаления.
     */
    deleteRegistration(nomenclatureId: string): Promise<boolean>;
}
/**
 * # Линии
 *
 * Доступ к управлению линиями, сессиями и каналами, а также получение переписки и данных метрик линий
 * осуществляется с помощью свойств типа [[LinesCollections]].
 *
 * ## Работа с линиями
 *
 * Получить линии и их параметры можно с помощью метода [[Lines.search]].
 *
 * Получить линию с названием “some line” можно следующим образом:
 * ```typescript
 * const line = await System.lines.lines.search()
 *     .where((f, g) => g.and(
 *         f.__deletedAt.eq(null),
 *         f.__name.eq("some line"),
 *     ))
 *     .first();
 * ```
 *
 * ## Работа с каналами (мессенджерами)
 *
 * Получить конкретные каналы можно с помощью метода [[LineChannels.search]].
 *
 * Канал может находиться в одном из трех статусов: «Активен», «Разорван», «Ошибка» (см. [[LineChannelState]]).
 *
 * Пример получения всех неактивных каналов:
 * ```typescript
 * const inactiveChannels = await System.lines.channels.search()
 *     .where((f, g) => g.and(
 *         f.__deletedAt.eq(null),
 *         f._state.neq(LineChannelState.active),
 *     ))
 *     .all();
 * ```
 *
 * В дальнейшем можно изменять статус активности канала с помощью методов типа [[LineChannelItemRef]].
 *
 * Отключить канал можно следующим образом:
 * ```typescript
 * const channel = await System.lines.channels.search()
 *     .where((f, g) => g.and(
 *         f.__deletedAt.eq(null),
 *         f._state.eq(LineChannelState.active),
 *     ))
 *     .first();
 * await channel.disconnect();
 * ```
 * Отключенные каналы можно переподключить, однако это возможно только для каналов определенных типов:
 * `telegramBot`, `inbox`, `viberbot`, `livechat`, `instagram` (см. [[LineChannelType]]).
 *
 * Пример переподключения каналов:
 * ```typescript
 * // Ищем неактивные каналы разрешённых типов
 * const channels = await System.lines.channels.search()
 *     .where((f, g) => g.and(
 *         f.__deletedAt.eq(null),
 *         f._state.neq(LineChannelState.active),
 *         f._type.in([
 *             LineChannelType.inbox,
 *             LineChannelType.telegramBot,
 *             LineChannelType.viberbot,
 *             LineChannelType.livechat,
 *             LineChannelType.instagram,
 *         ]),
 *     ))
 *     .size(100)
 *     .all();
 * for (const channel of channels) {
 *     await channel.reconnect();
 * }
 * ```
 *
 * ## Работа с клиентами
 *
 * Клиенты — пользователи каналов (мессенджеров), которые пишут в линию.
 * Для поиска клиента можно воспользоваться методом [[LineClients.search]].
 *
 * Например, можно найти пользователя Telegram по его учетной записи:
 * ```typescript
 * // Ищем канал типа telegram
 * const channel = await System.lines.channels.search()
 *     .where((f, g) => g.and(
 *         f.__deletedAt.eq(null),
 *         f._type.eq(LineChannelType.telegram),
 *     ))
 *     .first();
 * // Ищем привязанного к найденному каналу клиента
 * const client = await System.lines.clients.search()
 *     .where((f, g) => g.and(
 *         f.__deletedAt.eq(null),
 *         f._channel.eq(channel),
 *         f._username.eq("telegram_username"),
 *     ))
 *     .first();
 * ```
 *
 * Для привязки элемента приложения к клиенту можно использовать метод [[LineClientItem.save]].
 * Для этого в поле клиента [[LineClientData._applicationItem]] нужно сохранить ссылку на элемент приложения.
 * Следует обратить внимание, что упомянутое приложение должно быть выбрано для связи с учетной записью в настройках линии,
 * к которой привязан клиент.
 *
 * Пример такой привязки:
 * ```typescript
 * const contact = Context.data.contact!;
 * const client = await System.lines.clients.search()
 *     .where((f, g) => g.and(
 *         f.__deletedAt.eq(null),
 *         f._username.eq("telegram_username"),
 *     ))
 *     .first();
 * client.data._applicationItem = contact;
 * await client.save();
 * ```
 *
 * ## Работа с сессиями
 *
 * Сессия — это основной объект, содержащий переписку клиентов и операторов линий.
 *
 * Сессия может находиться в одном из четырех статусов (см. [[LineSessionState]]):
 * * «В очереди» — сессия ожидает назначения оператора, никто не может ответить на сообщения клиента;
 *
 * * «Назначена на бота» — клиент ведёт переписку с ELMA Bot;
 *
 * * «Назначена на оператора» — клиент ведёт переписку с конкретным оператором;
 *
 * * «Закрыта» — переписка в рамках этой сессии завершена. Если клиент напишет снова, будет создана новая сессия.
 *
 * Поиск и создание сессий осуществляется с помощью методов типа [[LineSessions]].
 *
 * Пример поиска открытой сессии с конкретным клиентом:
 * ```typescript
 * const client = await System.lines.clients.search()
 *     .where((f, g) => g.and(
 *         f.__deletedAt.eq(null),
 *         f._username.eq("telegram_username"),
 *     ))
 *     .first();
 * const session = await System.lines.sessions.search()
 *     .where((f,c) => c.and(
 *         f.__deletedAt.eq(null),
 *         f._clients.all([client]),
 *         f._state.neq(LineSessionState.Closed),
 *     ))
 *     .first();
 * ```
 *
 * Для создания новой сессии от имени оператора можно использовать метод [[LineSessions.create]].
 * Метод принимает канал, в рамках которого необходимо создать сессию, и учетную запись (аккаунт) клиента,
 * с которым необходимо начать переписку.
 * В зависимости от типа канала это может быть учетная запись (или псевдоним), номер телефона, электронная почта и т.д.
 *
 * ```typescript
 * const contact = await Context.data.contact.fetch();
 * const account = contact.data._account[0].login;
 * const newSession = await System.lines.sessions.create(Context.data.channel, account);
 * ```
 *
 * В дальнейшем можно управлять сессией (назначать на оператора, бота или группу операторов, закрывать, получать переписку)
 * с помощью методов типа [[LineSessionItemRef]].
 *
 * Например, назначить сессию на конкретного оператора можно так:
 * ```typescript
 * const session = await System.lines.sessions.search()
 *     .where((f,c) => c.and(
 *         f.__deletedAt.eq(null),
 *         f.__id.eq(Context.data.sessionId!),
 *     ))
 *     .first();
 * await session.assignToOperator(Context.data.user);
 * ```
 *
 * Пример получения последнего сообщения в сессии:
 * ```typescript
 * const session = await System.lines.sessions.search()
 *     .where((f,c) => c.and(
 *         f.__deletedAt.eq(null),
 *         f.__id.eq(Context.data.sessionId!),
 *     ))
 *     .first();
 * const lastMessage = await session.getLastMessage();
 * ```
 * @packageDocumentation
 */
/**
 * # Объект System.lines
 *
 * Содержит доступ к системным коллекциям Линий,
 * всегда доступен как глобальное значение в сценариях:
 *
 * ```typescript
 * const cu = await System.users.getCurrentUser();
 * await System.lines.sessions.assignToOperator(cu);
 * ```
 */
interface LinesCollections {
    /**
     * Сессии.
     */
    readonly sessions: LineSessions;
    /**
     * Линии.
     */
    readonly lines: Lines;
    /**
     * Клиенты.
     */
    readonly clients: LineClients;
    /**
     * Каналы (мессенджеры).
     */
    readonly channels: LineChannels;
    /**
     * Метрики.
     */
    readonly metrics: LineMetrics;
}
/**
 * # Объект поиска линий
 *
 * Подробнее работа поиска описана в [[Search]].
 */
interface LineSearch extends Search<LineData, LineItem> {
}
/**
 * # Объект поиска каналов Линий
 *
 * Подробнее работа поиска описана в [[Search]].
 */
interface LineChannelSearch extends Search<LineChannelData, LineChannelItem> {
}
/**
 * # Объект поиска клиентов Линий
 *
 * Подробнее работа поиска описана в [[Search]].
 */
interface LineClientSearch extends Search<LineClientData, LineClientItem> {
}
/**
 * # Объект поиска сессий Линий
 *
 * Подробнее работа поиска описана в [[Search]].
 */
interface LineSessionSearch extends Search<LineSessionData, LineSessionItem> {
}
/**
 * # Объект линий
 *
 * Используется для поиска по линиям.
 */
interface Lines {
    /**
     * Метод [[Lines.search]] позволяет выполнить поиск линий.
     *
     * Для выборки элементов коллекций используется объект [[Search]]:
     * ```typescript
     * const lines = await System.lines.lines.search()
     *     .where(f => f.__name.eq("some line"))
     *     .all();
     * ```
     *
     *
     * Подробнее об использовании объекта поиска можно узнать
     * в статье [Работа с приложениями](../pages/quick-start/intro_apps.html#3).
     */
    search(): LineSearch;
}
/**
 * # Объект канала Линий
 *
 * Используется для поиска по каналам Линий.
 */
interface LineChannels {
    /**
     * Метод [[LineChannels.search]] позволяет выполнить поиск каналов Линий.
     *
     * Для выборки элементов коллекций используется объект [[Search]]:
     * ```typescript
     * const channels = await System.lines.channels.search()
     *     .where(f => f.__name.eq("some channel"))
     *     .all();
     * ```
     *
     *
     * Подробнее об использовании объекта поиска можно узнать
     * в статье [Работа с приложениями](../pages/quick-start/intro_apps.html#3).
     */
    search(): LineChannelSearch;
}
/**
 * # Объект клиента Линий
 *
 * Используется для поиска по клиентам Линий.
 */
interface LineClients {
    /**
     * Метод [[LineClients.search]] позволяет выполнить поиск клиентов Линий.
     *
     * Для выборки элементов коллекций используется объект [[Search]]:
     * ```typescript
     * const clients = await System.lines.clients.search()
     *     .where(f => f._username.eq("login"))
     *     .all();
     * ```
     *
     *
     * Подробнее об использовании объекта поиска можно узнать
     * в статье [Работа с приложениями](../pages/quick-start/intro_apps.html#3).
     */
    search(): LineClientSearch;
}
/**
 * # Объект сессий Линий
 *
 * Используется для поиска по сессиям, создания новых сессий,
 * перевода сессий на оператора и др.
 */
interface LineSessions {
    /**
     * Метод [[LineSessions.search]] позволяет выполнить поиск сессий Линий.
     *
     * Для выборки элементов коллекций используется объект [[Search]]:
     * ```typescript
     * const cu = await System.users.getCurrentUser();
     * const sessions = await System.lines.sessions.search()
     *     .where(f => f._userId.eq(cu))
     *     .all();
     * ```
     *
     * Подробнее об использовании объекта поиска можно узнать
     * в статье [Работа с приложениями](../pages/quick-start/intro_apps.html#3).
     */
    search(): LineSessionSearch;
    /**
     * Метод [[LineSessions.create]] позволяет создать новую сессию Линий.
     *
     * @param channel Канал, в рамках которого необходимо создать сессию.
     * @param account Аккаунт клиента, с которым необходимо создать сессию.
     * В зависимости от типа канала это может быть учетная запись (или псевдоним),
     * номер телефона, электронная почта.
     *
     * ```typescript
     * const contact = await Context.data.contact.fetch();
     * const account = contact.data._account[0].login;
     * const newSession = await System.lines.sessions.create(Context.data.channel, account);
     * ```
     */
    create(channel: LineChannelItemRef, account: string): Promise<LineSessionItemRef>;
}
/**
 * # Объект метрик Линий
 *
 * Используется для получения метрик Линий за период.
 */
interface LineMetrics {
    /**
     * Метод [[LineMetrics.get]] позволяет получить значения метрик Линий.
     *
     * @param type Тип метрики. Допустимые значения см. [[LineMetricType]].
     * @param start Начало периода.
     * @param end Конец периода.
     * @param from Количество элементов, которое необходимо пропустить (по умолчанию 0).
     * @param size Размер выборки (по умолчанию 10, максимум 10000).
     *
     * ```typescript
     * // Получим набор данных (100 записей) для метрики
     * // Время ответа за неделю
     * const now = new Datetime();
     * const start = now.addDate(0, 0, -7).truncateTime();
     * const metrics = await System.lines.metrics.get(
     *     LineMetricType.responseTime,
     *     start, now, 0, 100,
     * );
     * ```
     */
    get(type: LineMetricType, start: TDatetime, end: TDatetime, from?: number, size?: number): Promise<LineMetricItem[]>;
}
/**
 * # Перечисление типов правил маршрутизации линии
 *
 * @obsolete Избегайте использования. Тип удален.
 * @ignore
 */
declare enum LineRoutingRuleType {
    /**
     * # Кто первый
     */
    whoFirst = "whoFirst",
    /**
     * # Бот всегда
     */
    bot = "bot",
    /**
     * # Бот в нерабочее время
     */
    workTime = "workTime"
}
/**
 * # Поля объекта линии
 */
interface LineData extends Based<ItemData> {
    /**
     * Супервизоры линии.
     */
    readonly _supervisors: TRole[];
    /**
     * Операторы линии.
     */
    readonly _operators: TRole[];
    /**
     * Группы, имеющие доступ к сессиям линии для чтения.
     */
    readonly _readers: TRole[];
    /**
     * Группы, которые могут написать в линию через раздел Сообщения (внутренний канал).
     */
    readonly _members: TRole[];
    /**
     * Приложения для фиксации обращений (привязки сессий).
     */
    readonly _sessionApps: LineBindingApplication[];
    /**
     * Приложение для связи учётной записи (клиента).
     */
    readonly _clientApp: LineBindingApplication;
    /**
     * Правила маршрутизации.
     *
     * @obsolete Избегайте использования. Поле удалено.
     * @ignore
     */
    readonly _routingRules: LineRoutingRule[];
}
/**
 * # Объект линии
 */
interface LineItem extends BaseItem<LineData>, ItemRef<LineItem>, LineItemRef {
    /**
     * @ignore
     */
    readonly kind: 'line';
}
/**
 * # Ссылка на объект линии
 */
interface LineItemRef extends ItemRef<LineItem> {
    /**
     * @ignore
     */
    readonly kind: 'line';
}
/**
 * # Объект привязки приложения к линии
 */
interface LineBindingApplication {
    /**
     * Наименование связанного свойства приложения.
     *
     * Это свойство должно иметь тип «Учетная запись».
     */
    fieldCode: TString;
    /**
     * Ссылка на приложение.
     */
    application: LineApplicationRef;
}
/**
 * # Ссылка на приложение в линии
 */
interface LineApplicationRef {
    /**
     * Код раздела приложения.
     */
    namespace: TString;
    /**
     * Код приложения.
     */
    code: TString;
}
/**
 * # Правило маршрутизации линии
 *
 * @obsolete Избегайте использования. Тип удален.
 * @ignore
 */
interface LineRoutingRule {
    /**
     * Правило.
     *
     * Допустимые значения см. [[LineRoutingRuleType]].
     */
    rule: TString;
    /**
     * Операторы линии.
     */
    operators: TRole[];
}
/**
 * # Перечисление типов каналов Линий
 */
declare enum LineChannelType {
    /**
     * # Telegram
     */
    telegram = "telegram",
    /**
     * # Instagram
     */
    instagram = "instagram",
    /**
     * # Whatsapp
     */
    whatsapp = "whatsapp",
    /**
     * # TelegramBot
     */
    telegramBot = "telegram_bot",
    /**
     * # Инбокс (электронная почта)
     */
    inbox = "inbox",
    /**
     * # ViberBot
     */
    viberbot = "viberbot",
    /**
     * # VK
     */
    vk = "vkontakte",
    /**
     * # LiveChat
     */
    livechat = "livechat",
    /**
     * # Произвольный мессенджер
     */
    other = "other",
    /**
     * # Внутренний канал
     */
    internal = "quick",
    /**
     * # Техническая поддержка
     */
    support = "support"
}
/**
 * # Перечисление статусов каналов Линий
 */
declare enum LineChannelState {
    /**
     * # Активен
     */
    active = 1,
    /**
     * # Разорван
     */
    disconnected = 0,
    /**
     * # Ошибка
     */
    error = 3
}
/**
 * # Поля объекта канала Линий
 */
interface LineChannelData extends Based<ItemData> {
    /**
     * Логин (учетная запись) подключенного канала.
     */
    readonly _login: TString;
    /**
     * Тип канала.
     *
     * Допустимые значения см. [[LineChannelType]].
     */
    readonly _type: TString;
    /**
     * Статус канала.
     *
     * Допустимые значения см. [[LineChannelState]].
     */
    readonly _state: TFloat;
    /**
     * Линия, в рамках которой подключен канал.
     */
    readonly _line: LineItemRef;
}
/**
 * # Объект канала Линий
 */
interface LineChannelItem extends BaseItem<LineChannelData>, ItemRef<LineChannelItem>, LineChannelItemRef {
    /**
     * @ignore
     */
    readonly kind: 'channel';
}
/**
 * # Ссылка на объект канала Линий
 */
interface LineChannelItemRef extends ItemRef<LineChannelItem> {
    /**
     * @ignore
     */
    readonly kind: 'channel';
    /**
     * Метод [[LineChannelItemRef.reconnect]] подключает ранее отключенный канал Линий.
     *
     * Переподключение поддерживается для каналов типов `telegramBot`, `inbox`,
     * `viberbot`, `livechat`, `instagram` (см. [[LineChannelType]]).
     *
     * ```typescript
     * await Context.data.channel.reconnect();
     * ```
     */
    reconnect(): Promise<void>;
    /**
     * Метод [[LineChannelItemRef.disconnect]] отключает канал Линий.
     *
     * ```typescript
     * await Context.data.channel.disconnect();
     * ```
     */
    disconnect(): Promise<void>;
}
/**
 * # Поля объекта клиента Линий
 */
interface LineClientData extends Based<ItemData> {
    /**
     * Связанное приложение — элемент приложения, к которому привязан клиент (учетная запись).
     */
    _applicationItem: RefItem;
    /**
     * Внешний идентификатор клиента — идентификатор клиента со стороны мессенджера (канала).
     */
    readonly _externalId: TString;
    /**
     * Логин (учетная запись) со стороны мессенджера (канала).
     */
    readonly _username: TString;
    /**
     * Номер телефона клиента.
     */
    readonly _phoneNumber: TString;
    /**
     * Аватар клиента.
     */
    readonly _avatar: FileItemRef;
    /**
     * Связанный пользователь.
     */
    readonly _user: UserItemRef;
    /**
     * Дополнительная информация о клиенте.
     */
    readonly _extraData: LineClientExtraData;
    /**
     * Канал, в рамках которого создан клиент.
     */
    readonly _channel: LineChannelItemRef;
}
/**
 * # Дополнительная информация о клиенте линии
 */
interface LineClientExtraData {
    /**
     * Электронная почта.
     */
    mail: TString;
}
/**
 * # Объект клиента Линий
 */
interface LineClientItem extends BaseItem<LineClientData>, ItemRef<LineClientItem>, LineClientItemRef {
    /**
     * @ignore
     */
    readonly kind: 'client';
    /**
     * Метод [[LineClientItem.save]] сохраняет объект клиента Линий.
     *
     * Метод позволяет обновлять текущего клиента.
     * Поля, доступные для редактирования: `_applicationItem`.
     *
     * ```typescript
     *     const client = await Context.data.client.fetch();
     *     client.data._applicationItem = Context.data.contact;
     *
     *     await client.save();
     * ```
     */
    save(): Promise<void>;
}
/**
 * # Ссылка на объект клиента Линий
 */
interface LineClientItemRef extends ItemRef<LineClientItem> {
    /**
     * @ignore
     */
    readonly kind: 'client';
}
/**
 * # Перечисление статусов (состояний) сессии Линий
 *
 * Используется в типе [[LineSessionStateEnumBase]].
 */
declare enum LineSessionState {
    /**
     * # Сессия находится в очереди
     */
    Waiting = "wait_operator",
    /**
     * # Сессия назначена на бота
     */
    AssignedToBot = "assigned_to_bot",
    /**
     * # Сессия назначена на оператора
     */
    AssignedToOperator = "assigned_to_operator",
    /**
     * # Сессия закрыта
     */
    Closed = "closed"
}
/**
 * # Перечисление приоритетов сессии Линий
 *
 * Используется в типе [[LineSessionPriorityEnumBase]].
 */
declare enum LineSessionPriority {
    /**
     * # Сессия находится в низком приоритете
     */
    Low = "low",
    /**
     * # Сессия находится в среднем приоритете
     */
    Medium = "medium",
    /**
     * # Сессия находится в высоком приоритете
     */
    High = "high"
}
/**
 * # Статусы (состояния) сессии Линий
 *
 * * Waiting — находится в очереди;
 *
 * * AssignedToBot — назначена на бота;
 *
 * * AssignedToOperator — назначена на оператора;
 *
 * * Closed — закрыта.
 */
declare type LineSessionStateEnumBase = LineSessionState.Waiting | LineSessionState.AssignedToBot | LineSessionState.AssignedToOperator | LineSessionState.Closed;
/**
 * # Приоритеты сессии Линий
 *
 * * Low — низкий;
 *
 * * Medium — средний;
 *
 * * High — высокий;
 */
declare type LineSessionPriorityEnumBase = LineSessionPriority.Low | LineSessionPriority.Medium | LineSessionPriority.High;
/**
 * # Поля объекта сессии Линий
 */
interface LineSessionData extends Based<ItemData> {
    /**
     * Связанные обращения — элементы приложений, к которым привязана сессия.
     */
    _apps: RefItem[];
    /**
     * Приоритет сессии.
     */
    readonly _priority: TEnum<LineSessionPriorityEnumBase>;
    /**
     * Оператор сессии — пользователь, на которого назначена сессия.
     */
    readonly _userId: UserItemRef;
    /**
     * Назначенная группа операторов — группа пользователей, которым доступна сессия (могут назначить её из очереди на себя).
     */
    readonly _userGroupId: TRole;
    /**
     * Статус (состояние) сессии.
     */
    readonly _state: TEnum<LineSessionStateEnumBase>;
    /**
     * Внешний идентификатор чата — идентификатор чата канала со стороны мессенджера.
     */
    readonly _externalChatId: TString;
    /**
     * Наименование чата — наименование чата со стороны мессенджера.
     */
    readonly _externalChatName: TString;
    /**
     * Дата закрытия сессии (перевода в статус «Закрыта»).
     */
    readonly _closedAt: TDate;
    /**
     * Дата последней активности (последнего сообщения) в сессии.
     */
    readonly _lastActivityAt: TDate;
    /**
     * Дата последнего переназначения сессии (изменения статуса).
     */
    readonly _acceptedAt: TDate;
    /**
     * Линия, в рамках которой создана сессия.
     */
    readonly _line: LineItemRef;
    /**
     * Клиенты сессии.
     */
    readonly _clients: LineClientItemRef[];
    /**
     * Канал, в рамках которого создана сессия.
     */
    readonly _channel: LineChannelItemRef;
}
/**
 * # Объект сессии Линий
 */
interface LineSessionItem extends BaseItem<LineSessionData>, ItemRef<LineSessionItem>, LineSessionItemRef {
    /**
     * @ignore
     */
    readonly kind: 'session';
    /**
     * Метод [[LineSessionItem.save]] сохраняет объект сессии.
     *
     * Метод позволяет обновлять текущую сессию.
     * Поля, доступные для редактирования: `__name`, `_apps`.
     *
     * ```typescript
     *     const session = await Context.data.session.fetch();
     *     session.data.__name = "new session name";
     *     session.data._apps.push(Context.data.lead);
     *
     *     await session.save();
     *
     * ```
     */
    save(): Promise<void>;
}
/**
 * # Ссылка на объект сессии Линий
 */
interface LineSessionItemRef extends ItemRef<LineSessionItem> {
    /**
     * @ignore
     */
    readonly kind: 'session';
    /**
     * Метод [[LineSessionItemRef.assignToOperator]] назначает сессию на оператора.
     *
     * @param operator Оператор.
     *
     * ```typescript
     * await Context.data.session.assignToOperator(Context.data.user);
     * ```
     */
    assignToOperator(operator: UserItemRef): Promise<void>;
    /**
     * Метод [[LineSessionItemRef.assignToOperatorGroup]] назначает сессию на группу операторов.
     *
     * @param userGroup Группа операторов. Должна быть добавлена в список операторов Линии.
     *
     * ```typescript
     * await Context.data.session.assignToOperatorGroup(Context.data.userGroup);
     * ```
     */
    assignToOperatorGroup(userGroup: UserGroupItemRef): Promise<void>;
    /**
     * Метод [[LineSessionItemRef.assignToBot]] назначает сессию на бота.
     *
     * Метод выполняет перевод сессии на бота в случае, если бот подключен в Линию.
     *
     * ```typescript
     * await Context.data.session.assignToBot();
     * ```
     */
    assignToBot(): Promise<void>;
    /**
     * Метод [[LineSessionItemRef.close]] закрывает активную сессию.
     *
     * ```typescript
     * await Context.data.session.close();
     * ```
     */
    close(): Promise<void>;
    /**
     * Метод [[LineSessionItemRef.setPriority]] устанавливает приоритет сессии.
     *
     * ```typescript
     * await Context.data.session.setPriority(LineSessionPriority.Low);
     * ```
     */
    setPriority(priority?: LineSessionPriorityEnumBase): Promise<void>;
    /**
     * Метод [[LineSessionItemRef.getAllMessages]] получает всю переписку сессии.
     *
     * @param from Количество элементов, которое необходимо пропустить (по умолчанию 0).
     * @param size Размер выборки (по умолчанию 10, максимум 10000).
     *
     * ```typescript
     * // Получим 100 первых сообщений сессии.
     * const messages = await Context.data.session.getAllMessages(0, 100);
     * ```
     */
    getAllMessages(from?: number, size?: number): Promise<LineMessageItem[]>;
    /**
     * Метод [[LineSessionItemRef.getLastMessage]] получает последнее сообщение сессии.
     *
     * ```typescript
     * const lastMessage = await Context.data.session.getLastMessage();
     * ```
     */
    getLastMessage(): Promise<LineMessageItem>;
}
/**
 * # Перечисление типов метрик Линий
 */
declare enum LineMetricType {
    /**
     * # Время ожидания
     */
    acceptedTime = "accepted_time",
    /**
     * # Новая сессия
     */
    newSession = "new_session",
    /**
     * # Время ответа
     */
    responseTime = "response_time",
    /**
     * # Длительность сессии
     */
    sessionDuration = "session_life_time"
}
/**
 * # Поля объекта метрики Линий
 */
interface LineMetricData extends Based<ItemData> {
    /**
     * Значение метрики.
     */
    readonly value: number;
    /**
     * Линия.
     */
    readonly line: LineItemRef;
    /**
     * Сессия Линии.
     */
    readonly session: LineSessionItemRef;
    /**
     * Клиент Линии.
     */
    readonly client?: LineClientItemRef;
    /**
     * Оператор сессии.
     */
    readonly operator?: UserItemRef;
    /**
     * Группа операторов сессии.
     */
    readonly operatorGroup?: UserGroupItemRef;
    /**
     * Признак первого сообщения в сессии.
     */
    readonly isFirstMessage?: boolean;
    /**
     * Признак сообщения, отправленного от ELMA Bot.
     */
    readonly isBot?: boolean;
}
/**
 * # Объект метрики Линий
 */
interface LineMetricItem extends BaseItem<LineMetricData> {
    /**
     * @ignore
     */
    readonly kind: 'metric';
}
/**
 * # Перечисление типов сообщений в Линиях
 */
declare enum LineMessageType {
    /**
     * # Сообщение от клиента сессии
     */
    clientMessage = "client_message",
    /**
     * # Сообщение от оператора сессии
     */
    operatorMessage = "operator_message",
    /**
     * # Сообщение от ELMA Bot
     */
    botMessage = "bot_message",
    /**
     * # Системное сообщение о переназначении сессии
     */
    sessionReassignMessage = "session_reassign_message",
    /**
     * # Системное сообщение об обновлении информации о клиенте
     */
    clientUpdateMessage = "client_update_message",
    /**
     * # Системное сообщение об обновлении информации о клиенте
     */
    processMessage = "process_message",
    /**
     * # Системное тестовое сообщение
     */
    systemTextMessage = "session_system_text_message"
}
/**
 * # Поля объекта сообщения Линий
 */
interface LineMessageData extends Based<ItemData> {
    /**
     * Тип сообщения.
     *
     * Допустимые значения см. [[LineMessageType]].
     */
    readonly type: LineMessageType;
    /**
     * Сессия Линии.
     */
    readonly session: LineSessionItemRef;
    /**
     * Идентификатор (внешний) сообщения.
     */
    readonly externalId: TString;
    /**
     * Признак того, что сообщение прочитано.
     */
    readonly isRead: boolean;
    /**
     * Клиент Линии, если сообщение от клиента.
     */
    readonly client?: LineClientItemRef;
    /**
     * Оператор, если сообщение от оператора.
     */
    readonly operator?: UserItemRef;
    /**
     * Текст сообщения.
     */
    readonly body: TString;
    /**
     * Вложения сообщения.
     */
    readonly files?: FileItemRef[];
}
/**
 * # Объект сообщения Линий
 */
interface LineMessageItem extends BaseItem<LineMessageData> {
    /**
     * @ignore
     */
    readonly kind: 'lineMessage';
}
/**
 * @ignore
 * @packageDocumentation
 */
/**
 * @ignore
 */
/**
 * # Корневой объект API для клиентских сценариев.
 */
interface UI {
    /**
     * Доступ к API отображения виджетов (применяется для виджета «Код»).
     */
    widget: Widget;
}
/**
 * # Инструменты для работы с UI.
 */
interface BaseUI {
    /**
     * Возвращает текущий режим UI.
     *
     * Пример использования:
     * ```typescript
     * if (UI.getViewMode() === UIViewMode.MobileApp) {
     *     Context.data.showMobilePanel = true;
     * }
     * ```
     */
    getViewMode(): UIViewMode;
}
/**
 * # Режимы отображения пользовательского интерфейса.
 */
declare enum UIViewMode {
    /**
      * # Мобильное приложение.
      */
    MobileApp = "MOBILE_APP",
    /**
     * Декстопное приложение.
     */
    DesktopApp = "DESKTOP_APP",
    /**
     * Режим просмотра на мобильных устройствах.
     */
    MobileWeb = "MOBILE_WEB",
    /**
     * Режим просмотра на декстопных устройствах.
     */
    DesktopWeb = "DESKTOP_WEB"
}
/**
 * # Виджет «Код»
 *
 * Данный API применяется только для клиентских сценариев (на формах в приложениях и бизнес-процессах, на страницах и т. д.).
 *
 * ## Отображение стандартных виджетов
 * Для отображения стандартных виджетов в виджете «Код» можно использовать конструкцию следующего вида:
 * ```html
 * <%= UI.widget.contextValue('__name') %>
 * ```
 *
 * Полный список функций смотрите в [списке функций отображения виджетов](../interfaces/_102_ui_widgets_.widget.html#contextrow).
 *
 * @packageDocumentation
 */
/**
 * # HTML-строка для отображения в виджете «Код»
 */
declare type HtmlString = string;
/**
 * # Тип для передачи произвольного контента в содержимое какой-либо области виджета
 *
 * Функция возвращает строку.
 */
declare type HtmlContent = () => HtmlString;
/**
 * # Базовые параметры отображения виджетов
 */
interface WidgetParams {
    /**
     * Функция, вызываемая после отображения виджета.
     *
     * @param node Корневой HTML-элемент, соответствующий отображаемому виджету.
     */
    onRender?: (node: any) => void;
}
/**
 * # Параметры отображения значения поля
 */
interface WidgetContextValueParams extends WidgetParams {
    /**
     * Обязательность заполнения поля.
     *
     * По умолчанию имеет значение `false`.
     */
    required?: boolean;
    /**
     * Признак «Только для чтения».
     *
     * По умолчанию имеет значение `false`.
     *
     * Если нужно вывести значение в режиме «Только для чтения», необходимо передать `true`.
     * Если в режиме редактирования — не указывать или передать `false`.
     */
    readonly?: boolean;
    /**
     * Фукнция, вызываемая при изменении значения поля.
     *
     * @param value Новое значение поля.
     */
    onChange?: (value: any) => void;
}
/**
 * # Параметры отображения строки контекста
 */
interface WidgetContextRowParams extends WidgetContextValueParams {
    /**
     * Отображаемое имя.
     */
    name?: string;
    /**
     * Подсказка.
     */
    tooltip?: string;
}
/**
 * # Параметры для виджета «Панель с заголовком»
 */
interface WidgetGroupboxParams extends WidgetParams {
    /**
     * Заголовок панели.
     */
    title: string;
}
/**
 * # Данные для отображения виджета «Вкладка»
 */
interface WidgetTabData {
    /**
     * Заголовок вкладки.
     */
    title: string;
    /**
     * Содержимое.
     */
    content: HtmlContent;
}
/**
 * # Параметры для отображения виджетов «Выпадающее окно» и «Выпадающее меню»
 */
interface WidgetPopoverParams extends WidgetParams {
    /**
     * Расположение выпадающего окна/меню относительно элемента для открывания.
     *
     * По умолчанию имеет значение `vertical`. Доступные значения:
     *
     * `horizontal` — разворачивается горизонтально.
     *
     * `vertical` — разворачивается вертикально.
     *
     * `top` — сверху.
     *
     * `right` — справа.
     *
     * `bottom` — снизу.
     *
     * `left` — слева.
     *
     */
    position?: `horizontal` | `vertical` | `top` | `right` | `bottom` | `left`;
    /**
     * Размер выпадающего окна/меню.
     *
     * По умолчанию имеет значение `default`. Доступные значения:
     *
     * `default` — по содержимому.
     *
     * `sm` — маленький.
     *
     * `md` — средний.
     *
     * `lg` — большой.
     *
     */
    size?: `default` | `sm` | `md` | `lg`;
    /**
     * Массив элементов выпадающего меню.
     */
    items?: ContextMenuItem[];
}
/**
 * # Элемент выпадающего меню
 */
interface ContextMenuItem {
    /**
     * Название элемента меню.
     */
    label?: string;
    /**
     * Признак «Разделитель».
     *
     * По умолчанию имеет значение `false`.
     *
     * Если установлено значение `true`, то данный элемент будет являться разделителем.
     */
    separator?: boolean;
    /**
     * Признак «Недоступен».
     *
     * По умолчанию имеет значение `false`.
     *
     * Если необходимо запретить выбор данного элемента, нужно передать `true`.
     */
    disabled?: boolean;
    /**
     * Ссылка, переход по которой будет осуществлен при клике по элементу меню.
     */
    link?: string;
    /**
     * Атрибут, обозначающий, где будет открыта ссылка.
     *
     * По умолчанию имеет значение `_self`.
     *
     * `_blank` — ссылка будет открыта в новом окне или новой вкладке.
     *
     * `_self` — ссылка будет открыта в текущем окне или вкладке.
     *
     * `_parent` — ссылка будет открыта в родительском фрейме. Если фреймов нет, то будет открыта как `_self`.
     *
     * `_top` отменяет все фреймы и загружает страницу в полном окне браузера. Если фреймов нет, то ссылка будет открыта как `_self`.
     */
    linkTarget?: string;
    /**
     * Действие, выполняемое при клике по элементу.
     *
     * Сюда можно передать функцию, которая будет выполнена при клике по элементу меню.
     *
     * Например, при клике по элементу будет вызвана функция `onClickMenuItem`, объявленная в сценариях:
     * ```typescript
     * {
     *    label: 'Меню 2',
     *    click: function () {
     *          Scripts.onClickMenuItem();
     *    }
     * }
     * ```
     */
    click?(): void;
    /**
     * Метод для получения элементов меню следующего уровня при наведении курсора на данный элемент меню.
     *
     * Передаваемая в данный параметр функция должна возвращать массив дочерних элементов меню.
     *
     * Например, при наведении курсора на элемент будет открыт список дочерних элементов:
     * ```typescript
     * {
     *    getItems: async function () {
     *          return [
     *              {
     *                  label: 'Дочерний элемент 1',
     *              },
     *              {
     *                  label: 'Дочерний элемент 2',
     *              },
     *          ];
     *    }
     * }
     * ```
     */
    getItems?(): Promise<ContextMenuItem[]>;
}
/**
 * # API для отображения стандартных виджетов (применяется для виджета «Код»)
 *
 * Список доступных виджетов смотрите в пункте [Methods](#contextrow).
 */
interface Widget {
    /**
     * Путь к файлам виджета.
     *
     * Пример использования в виджете «Код»:
     * ```html
     * <img src="<%= UI.widget.filePath %>/filename.png" />
     * ```
     */
    readonly filePath: HtmlString;
    /**
     * Рендер виджета по его коду.
     *
     * Пример использования в виджете «Код»:
     * ```html
     * <%= UI.widget.render('@custom_widget_1', {comment: "Некоторый текст комментария"}) %>
     * ```
     *
     * @param code Код виджета.
     * @param params Параметры, передаваемые виджету (объект, где ключи соответсвуют кодам свойств виджета).
     * @param content Контент, который будет рендериться внутри виджета.
     */
    render(code: string, params?: Record<string, any> & WidgetParams, content?: HtmlContent): HtmlString;
    /**
     * Отобразить строку со значением поля контекста.
     *
     * Пример использования в виджете «Код»:
     * ```html
     * <%= UI.widget.contextValue('__name', {required: true}) %>
     * ```
     * @param fieldCode Код поля.
     * @param params Параметры отображения поля.
     */
    contextValue(fieldCode: string, params?: WidgetContextValueParams): HtmlString;
    /**
     * Отобразить строку со значением поля View-контекста.
     *
     * Пример использования в виджете «Код»:
     * ```html
     * <%= UI.widget.viewContextValue('__name', {required: true}) %>
     * ```
     * @param fieldCode Код поля.
     * @param params Параметры отображения поля.
     */
    viewContextValue(fieldCode: string, params?: WidgetContextValueParams): HtmlString;
    /**
     * Отобразить строку с полем контекста (название и значение).
     *
     * Рассмотрим, как можно применить это в виджете «Код».
     * Пример подсчёта суммы на основании цены и количества и её отображения только в том случае, если нужное поле не остаётся пустым:
     * ```typescript
     * <%
     * Scripts.calcTotal = function () {
     *     Context.data.total = Context.data.price && Context.data.count ? Context.data.price.multiply(Context.data.count) : undefined;
     *     Scripts.totalNode.style.display = Context.data.total ? '' : 'none';
     * }
     * Scripts.onTotalRender = function (node) {
     *     Scripts.totalNode = node;
     *     node.style.display = 'none';
     * }
     * %>
     * <%= UI.widget.contextRow('__name', { required: true }) %>
     * <%= UI.widget.contextRow('price', { required: true, onChange: Scripts.calcTotal }) %>
     * <%= UI.widget.contextRow('count', { required: true, onChange: Scripts.calcTotal }) %>
     * <%= UI.widget.contextRow('total', {
     *     name: 'ИТОГО',
     *     tooltip: 'Сумма подсчитана автоматически',
     *     readonly: true,
     *     onRender: Scripts.onTotalRender,
     * }) %>
     *
     * ```
     * @param fieldCode Код поля.
     * @param params Параметры отображения поля.
     */
    contextRow(fieldCode: string, params?: WidgetContextRowParams): HtmlString;
    /**
     * Отобразить строку с полем View-контекста (название и значение).
     *
     * Рассмотрим, как можно применить это в виджете «Код».
     * Пример подсчёта суммы на основании цены и количества и её отображения только в том случае, если нужное поле не остаётся пустым.
     * ```typescript
     * <%
     * Scripts.calcTotal = function () {
     *     ViewContext.data.total = ViewContext.data.price && ViewContext.data.count
     *     ? ViewContext.data.price.multiply(ViewContext.data.count)
     *     : undefined;
     *     Scripts.totalNode.style.display = Context.data.total ? '' : 'none';
     * }
     * Scripts.onTotalRender = function (node) {
     *     Scripts.totalNode = node;
     *     node.style.display = 'none';
     * }
     * %>
     * <%= UI.widget.viewContextRow('__name', { required: true }) %>
     * <%= UI.widget.viewContextRow('price', { required: true, onChange: Scripts.calcTotal }) %>
     * <%= UI.widget.viewContextRow('count', { required: true, onChange: Scripts.calcTotal }) %>
     * <%= UI.widget.viewContextRow('total', {
     *     name: 'ИТОГО',
     *     tooltip: 'Сумма подсчитана автоматически',
     *     readonly: true,
     *     onRender: Scripts.onTotalRender,
     * }) %>
     *
     * ```
     * @param fieldCode Код поля.
     * @param params Параметры отображения поля.
     */
    viewContextRow(fieldCode: string, params?: WidgetContextRowParams): HtmlString;
    /**
     * Отобразить виджет «Панель с заголовком».
     *
     * Пример использования в виджете «Код»:
     * ```html
     * <%= UI.widget.groupbox({title: 'Заголовок'}, panelContent) %>
     *
     * <% $template panelContent %>
     *     <div> Здесь отобразим содержимое панели </div>
     * <% $endtemplate %>
     * ```
     * @param params Параметры отображения.
     * @param content Содержимое панели.
     */
    groupbox(params: WidgetGroupboxParams, content: HtmlContent): HtmlString;
    /**
     * Отобразить виджет «Вкладки».
     *
     * Пример использования в виджете «Код»:
     * ```html
     * <%= UI.widget.tabset({}, [{title: 'Вкладка 1', content: firstTabContent}, {title: 'Вкладка 2', content: secondTabContent}]) %>
     *
     * <% $template firstTabContent %>
     *     <div> Здесь отобразим содержимое первой вкладки </div>
     * <% $endtemplate %>
     *
     * <% $template secondTabContent %>
     *     <div> Здесь отобразим содержимое второй вкладки </div>
     * <% $endtemplate %>
     * ```
     * @param values
     * @param tabs
     */
    tabset(values: WidgetParams, tabs: WidgetTabData[]): HtmlString;
    /**
     * Отобразить виджет «Выпадающее окно».
     *
     * Представляет собой выпадающее окно с произвольным содержимым, открывающееся после клика по элементу для открывания.
     *
     * Пример использования в виджете «Код»:
     * ```html
     * <% $template panelContent %>
     *     <p> Здесь отобразим содержимое выпадающего окна </p>
     *     <%= UI.widget.contextRow('__name', { name: 'Название' }) %>
     * <% $endtemplate %>
     *
     * <% $template popoverOpener %>
     *     <button type="button">Открыть</button>
     * <% $endtemplate %>
     *
     * <%= UI.widget.popover(
     *     popoverOpener,
     *     {
     *          type: 'widgets',
     *          size: 'md',
     *          position: 'bottom',
     *     },
     *     panelContent
     * ) %>
     * ```
     * @param opener Элемент для открывания выпадающего окна. Может содержать HTML-контент или другие виджеты.
     * @param params Параметры отображения.
     * @param content Содержимое выпадающего окна.
     */
    popover(opener: HtmlContent, params: WidgetPopoverParams, content?: HtmlContent): HtmlString;
    /**
     * Отобразить виджет «Выпадающее меню».
     *
     * Представляет собой выпадающее многоуровневое меню, открывающееся после клика по элементу для открывания.
     * Пункты меню описываются массивом в свойстве `items` параметров отображения.
     *
     * Пример использования в виджете «Код»:
     * ```html
     * <% $template popoverMenuOpener %>
     *     <button type="button">Открыть меню</button>
     * <% $endtemplate %>
     *
     * <%= UI.widget.popover(
     *     popoverMenuOpener,
     *     {
     *          position: 'right',
     *          items: [
     *              {
     *                  label: "Меню 1",
     *                  click: function () {
     *                      Scripts.onClickMenuItem('Меню 1');
     *                  },
     *              },
     *              {
     *                  label: "Меню 2",
     *                  click: function () {
     *                      Scripts.onClickMenuItem('Меню 2');
     *                  },
     *              },
     *              {
     *                  label: "Раздел 1",
     *                  getItems: function () {
     *                      return [
     *                          {
     *                              label: "Меню второго уровня",
     *                              click: function () {
     *                                  ViewContext.data.test = 'Дочерний элемент 1';
     *                              }
     *                          },
     *                      ]
     *                  },
     *              },
     *          ],
     *     }
     * ) %>
     * ```
     * @param opener Элемент для открывания выпадающего меню. Может содержать HTML-контент или другие виджеты.
     * @param params Параметры отображения.
     */
    popoverMenu(opener: HtmlContent, params: WidgetPopoverParams): HtmlString;
}
/**
 * # Интеграция с IP-телефонией
 *
 * Система из коробки включает в себя интеграции с различными провайдерами IP-телефонии. Если нужной именно вам
 * интеграции не нашлось, вы можете воспользоваться данным API для создания собственной интеграции. Для этого вам нужно
 * создать пользовательский модуль и реализовать несколько функций в сценариях модуля на языке TypeScript.
 *
 * Встроенные и пользовательские модули интеграции с IP-телефонией по функционалу принципиально ничем не отличаются.
 * Вашему модулю будут доступны следующие возможности:
 *
 * - инициация исходящего звонка из системы по нажатию на поле типа Телефон;
 * - всплывающая карточка, сигнализирующая о входящем звонке и отображающая краткую информацию, например, телефон,
 * имя контакта и имя ответственного за этого клиента пользователя;
 * - открытие карточки элемента, содержащего номер телефона, с которого поступает звонок;
 * - автоматическое создание и сохранение элемента приложения, если звонок был пропущен, а номера нет в базе;
 * - регистрация пропущенных звонков;
 * - сохранение в ленте объекта оповещения о входящем или исходящем звонке. Если разговор состоялся, то к оповещению
 * прикладывается ссылка на запись звонка; запись можно воспроизвести в интерфейсе системы, а также оставить
 * комментарий, содержащий, к примеру, краткое резюме звонка;
 * - сопоставление учетных записей пользователей IP-телефонии и пользователей системы для маршрутизации и
 * корректного отражения информации об операторе, принявшем или осуществившем звонок.
 *
 * ## Ограничения
 *
 * Прежде чем реализовывать модуль интеграции, обратите внимание на следующие ограничения API:
 *
 * 1. На стороне системы не осуществляется маршрутизация звонка во избежание конфликтов с настройками маршрутизации
 * на стороне телефонии и на стороне системы. Такую возможность предоставляет практически каждый провайдер: после
 * того, как звонок маршрутизирован на сотрудника или группу, входящий вызов отображается в системе для указанных
 * пользователей.
 * 2. На текущий момент обработка событий телефонии производится путем доставки сообщений на определенную HTTP-ссылку
 * (Webhook). Если провайдер телефонии не предоставляет возможность указать ссылку для доставки сообщений, то необходимо
 * создать промежуточный сервис, который преобразует данные провайдера телефонии в запрос на сервер системы.
 * 3. Для записей звонков сохраняется только ссылка на файл. Обычно провайдеры телефонии сохраняют записи звонков за
 * вас, и ссылка на запись звонка уже существует, но вам следует обратить внимание на политику хранения файлов на
 * серверах провайдера телефонии: возможно, провайдер сохраняет записи звонков в течение ограниченного времени.
 *
 * ## Реализация
 *
 * Для создания модуля интеграции вам необходимо в сценариях пользовательского модуля реализовать следующие функции:
 *
 * ```typescript
 * // Проверить соединение с телефонией. Вызывается при нажатии на кнопку «Проверить соединение» на странице модуля
 * // Возвращает статус проверки соединения, который отобразится для пользователя на странице модуля
 * async function VoipTestConnection(): Promise<VoipTestConnectionResult> { }
 *
 * // Обработать запрос от провайдера IP-телефонии. Вызывается когда происходит запрос на вебхук модуля
 * // В параметре “request” содержится информация об HTTP-запросе, в том числе HTTP-заголовки и содержимое тела запроса
 * // Функция возвращает результат обработки запроса, на основании которого система будет показывать уведомления
 * // о входящем звонке, сохранять запись звонка и т. д.
 * async function VoipParseWebhookRequest(request: FetchRequest): Promise<VoipWebhookParseResult> { }
 *
 * // Получить список пользователей со стороны провайдера IP-телефонии
 * // Вызывается при сопоставлении пользователей телефонии с пользователями системы после нажатия кнопки «Настроить» на странице модуля
 * // Возвращает список пользователей провайдера IP-телефонии
 * async function VoipGetMembers(): Promise<VoipMember[]> { }
 *
 * // Сгенерировать исходящий звонок. Данная функция вызывается, когда пользователь системы нажимает на кнопку звонка
 * // в поле типа Телефон элемента приложения. В параметрах “srcPhone” указывается номер звонящего пользователя,
 * // в “dstPhone” — номер, на который нужно позвонить
 * async function VoipGenerateCall(srcPhone: string, dstPhone: string): Promise<void> { }
 *
 * // Получить ссылку на запись звонка. Функция вызывается, когда пользователь системы проигрывает запись звонка из
 * // ленты элемента приложения. В параметре “callData” содержатся данные, которые были указаны при сохранении
 * // информации о записи звонка из функции “VoipParseWebhookRequest”. Функция должна возвращать ссылку на файл
 * async function VoipGetCallLink(callData: any): Promise<string> { }
 *
 * // Вызывается автоматически при изменении ссылки на вебхук (например, при обновлении токена)
 * // В параметре “webhookUrl” указывается абсолютная ссылка на вебхук модуля интеграции. Функция не обязательна к реализации
 * async function VoipOnWebhookUpdated(webhookUrl: string): Promise<void> { }
 * ```
 *
 * После реализации этих функций и сохранения сценария на странице модуля вы найдете новый раздел под названием
 * «Настройки телефонии». В этом разделе будет указана ссылка на вебхук — при отправке данных на эту ссылку будет
 * вызываться функция `VoipParseWebhookRequest` из сценария. В этой функции вы должны обработать запрос и вернуть из
 * неё экземпляр `VoipWebhookParseResult`, на основании которого система отобразит уведомления о входящем звонке или
 * сохранит информацию о записи звонка. Саму ссылку на вебхук вам необходимо указать в настройках вашего провайдера
 * телефонии. Ссылка обрабатывает HTTP-запросы типа GET и POST. Также в ссылке должен присутствовать обязательный
 * параметр `token`.
 *
 * Рекомендуем вам ознакомиться со статьей справки
 * [«Интеграция с IP-телефонией через пользовательский модуль»](https://elma365.com/ru/help/platform/ip-tel-integration.html).
 * Внутри статьи вы найдете заготовку модуля и пример реального использования API на основе интеграции с IP-телефонией
 * «Гравител».
 *
 * @packageDocumentation
 */
/**
 * # Тип события телефонии
 *
 * Используется в `VoipWebhookRequest` для указания типа события телефонии. В зависимости от типа события, в интерфейсе
 * системы отображаются различные типы уведомлений при звонке.
 */
declare enum VoipWebhookEvent {
    /**
     * # Начало звонка
     */
    NotifyStart = "notify_start",
    /**
     * # Ответ на звонок
     */
    NotifyAnswer = "notify_answer",
    /**
     * # Конец звонка
     */
    NotifyEnd = "notify_end"
}
/**
 * # Направление звонка
 *
 * Определяет, является ли звонок входящим или исходящим.
 */
declare enum VoipCallDirection {
    /**
     * # Входящий звонок
     */
    In = "in",
    /**
     * # Исходящий звонок
     */
    Out = "out"
}
/**
 * # Результат звонка
 *
 * Определяет результат звонка.
 */
declare enum VoipCallDisposition {
    /**
     * # Неизвестно
     */
    Unknown = "unknown",
    /**
     * # Отвечен
     */
    Answered = "answered",
    /**
     * # Занято
     */
    Busy = "busy",
    /**
     * # Отменен
     */
    Cancel = "cancel",
    /**
     * # Нет ответа
     */
    NoAnswer = "no_answer",
    /**
     * # Ошибка
     */
    Failed = "failed"
}
/**
 * # Событие телефонии
 *
 * Представляет собой событие телефонии. Система использует эти данные, чтобы отобразить уведомления о звонке связанным
 * пользователям.
 *
 * ```typescript
 * async function VoipParseWebhookRequest(request: FetchRequest): Promise<VoipWebhookParseResult> {
 *    const data = JSON.parse(request.body);
 *    return {
 *        event: {
 *            event: VoipWebhookEvent.NotifyStart,
 *            direction: VoipCallDirection.In,
 *            dstPhone: data.dstPhone,
 *            srcPhone: data.srcPhone,
 *            disposition: VoipCallDisposition.Unknown,
 *        };
 *    };
 * }
 * ```
 */
interface VoipWebhookRequest {
    /**
     * Номер, с которого звонят.
     */
    srcPhone: string;
    /**
     * Номер, на который звонят.
     */
    dstPhone: string;
    /**
     * Тип события телефонии.
     */
    event: VoipWebhookEvent;
    /**
     * Направление звонка.
     */
    direction: VoipCallDirection;
    /**
     * Результат звонка.
     */
    disposition: VoipCallDisposition;
}
/**
 * # Запись звонка
 *
 * Содержит данные о записи звонка. Система использует эти данные для отображения виджета прослушивания записи звонка
 * в ленте элемента приложения.
 */
interface VoipCallRecord {
    /**
     * Номер, с которого звонят.
     */
    srcPhone: string;
    /**
     * Номер, на который звонят.
     */
    dstPhone: string;
    /**
     * Направление звонка.
     */
    direction: VoipCallDirection;
    /**
     * Результат звонка.
     **/
    disposition: VoipCallDisposition;
    /**
     * Длительность звонка в секундах.
     */
    duration: number;
    /**
     * Любые данные, связанные со звонком (например, идентификатор звонка или ссылка на запись разговора).
     *
     * Данные из этого поля передаются в качестве аргумента в метод `VoipGetCallLink`, который используется для
     * получения ссылки на запись разговора.
     */
    call: any;
}
/**
 * # Результат парсинга сообщения с вебхука
 *
 * Данный интерфейс используется в качестве результата функции `VoipParseWebhookRequest` и определяет производимые
 * системой действия по результатам запроса на вебхук модуля телефонии.
 */
interface VoipWebhookParseResult {
    /**
     * Событие телефонии. Если это поле заполнено, то система отобразит уведомления о звонке связанным пользователям.
     *
     * ```typescript
     * async function VoipParseWebhookRequest(request: FetchRequest): Promise<VoipWebhookParseResult> {
     *    const data = JSON.parse(request.body);
     *    return {
     *        event: {
     *            event: VoipWebhookEvent.NotifyStart,
     *            direction: VoipCallDirection.In,
     *            dstPhone: data.dstPhone,
     *            srcPhone: data.srcPhone,
     *            disposition: VoipCallDisposition.Unknown,
     *        };
     *    };
     * }
     * ```
     */
    event?: VoipWebhookRequest;
    /**
     * Информация о записи звонка.
     *
     * Если это поле заполнено, то система сохранит запись звонка в ленту связанного элемента приложения.
     * Данные из этого поля используются системой для отображения виджета прослушивания записи звонка
     * в ленте элемента.
     *
     * ```typescript
     * async function VoipParseWebhookRequest(request: FetchRequest): Promise<VoipWebhookParseResult> {
     *     const data = JSON.parse(request.body);
     *     return {
     *          callRecord: {
     *              srcPhone: data.srcPhone,
     *              dstPhone: data.dstPhone,
     *              direction: VoipCallDirection.In,
     *              duration: data.duration,
     *              // Данные из этого поля будут доступны в функции VoipGetCallLink.
     *              call: {
     *                  link: data.callLink,
     *              },
     *              disposition: VoipCallDisposition.Answered,
     *          }
     *      };
     * }
     *
     * async function VoipGetCallLink(callData: any): Promise<string> {
     *     return callData.callLink; // Получаем данные, которые были сохранены в VoipParseWebhookRequest.
     * }
     * ```
     */
    callRecord?: VoipCallRecord;
    /**
     * Если поле заполнено, то клиенту, который выполняет запрос на вебхук, отправляется HTTP-ответ.
     *
     * ```typescript
     * async function VoipParseWebhookRequest(request: FetchRequest): Promise<VoipWebhookParseResult> {
     *     return {
     *         response: new HttpResponse()
     *             .status(400)
     *             .content('Hello, world!'),
     *     };
     * }
     * ```
     */
    response?: HttpResponse;
}
/**
 * # Результат тестирования соединения с телефонией
 *
 * Используется в качестве результата функции `VoipTestConnection` модуля интеграции, которая отображает пользователю
 * уведомление о результате проверки соединения с телефонией.
 */
interface VoipTestConnectionResult {
    /**
     * Результат тестирования соединения с телефонией.
     */
    success: boolean;
    /**
     * Сообщение с причиной ошибки соединения. Используется, только если значение поля `success` равно `false`.
     */
    failReason?: string;
}
/**
 * # Пользователь телефонии
 *
 * Представляет собой информацию о пользователе на стороне провайдера IP-телефонии. Данный интерфейс используется в
 * функции `VoipGetMembers`, которая возвращает список пользователей провайдера IP-телефонии.
 *
 * ```typescript
 * async function VoipGetMembers(): Promise<VoipMember[]> {
 *    // Получение пользователей провайдера IP-телефонии
 *    const response = await fetch('https://example.com/voip-users');
 *    interface VoipUser {
 *        name: string;
 *        ext: string;
 *    }
 *    const voipUsers = <VoipUser[]> (await response.json());
 *    return voipUsers.map(user => ({
 *        id: user.ext,
 *        label: user.name,
 *     }));
 * }
 * ```
 */
interface VoipMember {
    /**
     * ID пользователя (может быть внутренним номером или SIP ID).
     */
    id: string;
    /**
     * Отображаемое имя (логин).
     */
    label: string;
}
/**
 * @hidden
 * @packageDocumentation
 */
/** @hidden */
declare type CurrencyCode = 'AED' | 'AFN' | 'ALL' | 'AMD' | 'ANG' | 'AOA' | 'ARS' | 'AUD' | 'AWG' | 'AZN' | 'BAM' | 'BBD' | 'BDT' | 'BGN' | 'BHD' | 'BIF' | 'BMD' | 'BND' | 'BOB' | 'BOV' | 'BRL' | 'BSD' | 'BTN' | 'BWP' | 'BYN' | 'BZD' | 'CAD' | 'CDF' | 'CHE' | 'CHF' | 'CHW' | 'CLF' | 'CLP' | 'CNY' | 'COP' | 'COU' | 'CRC' | 'CUC' | 'CUP' | 'CVE' | 'CZK' | 'DJF' | 'DKK' | 'DOP' | 'DZD' | 'EGP' | 'ERN' | 'ETB' | 'EUR' | 'FJD' | 'FKP' | 'GBP' | 'GEL' | 'GHS' | 'GIP' | 'GMD' | 'GNF' | 'GTQ' | 'GYD' | 'HKD' | 'HNL' | 'HRK' | 'HTG' | 'HUF' | 'IDR' | 'ILS' | 'INR' | 'IQD' | 'IRR' | 'ISK' | 'JMD' | 'JOD' | 'JPY' | 'KES' | 'KGS' | 'KHR' | 'KMF' | 'KPW' | 'KRW' | 'KWD' | 'KYD' | 'KZT' | 'LAK' | 'LBP' | 'LKR' | 'LRD' | 'LSL' | 'LYD' | 'MAD' | 'MDL' | 'MGA' | 'MKD' | 'MMK' | 'MNT' | 'MOP' | 'MRU' | 'MUR' | 'MVR' | 'MWK' | 'MXN' | 'MXV' | 'MYR' | 'MZN' | 'NAD' | 'NGN' | 'NIO' | 'NOK' | 'NPR' | 'NZD' | 'OMR' | 'PAB' | 'PEN' | 'PGK' | 'PHP' | 'PKR' | 'PLN' | 'PYG' | 'QAR' | 'RON' | 'RSD' | 'RUB' | 'RWF' | 'SAR' | 'SBD' | 'SCR' | 'SDG' | 'SEK' | 'SGD' | 'SHP' | 'SLL' | 'SOS' | 'SRD' | 'SSP' | 'STN' | 'SVC' | 'SYP' | 'SZL' | 'THB' | 'TJS' | 'TMT' | 'TND' | 'TOP' | 'TRY' | 'TTD' | 'TWD' | 'TZS' | 'UAH' | 'UGX' | 'USD' | 'USN' | 'UYI' | 'UYU' | 'UYW' | 'UZS' | 'VES' | 'VND' | 'VUV' | 'WST' | 'XAF' | 'XAG' | 'XAU' | 'XBA' | 'XBB' | 'XBC' | 'XBD' | 'XCD' | 'XDR' | 'XOF' | 'XPD' | 'XPF' | 'XPT' | 'XSU' | 'XTS' | 'XUA' | 'XXX' | 'YER' | 'ZAR' | 'ZMW' | 'ZWL' | 'CYP' | 'ATS' | 'BEF' | 'DEM' | 'EEK' | 'ESP' | 'FIM' | 'FRF' | 'GRD' | 'IEP' | 'ITL' | 'LUF' | 'NLG' | 'PTE' | 'GHC' | 'GWP' | 'LVL' | 'LTL' | 'MTL' | 'MRO' | 'MZM' | 'ROL' | 'SAC' | 'SIT' | 'SDD' | 'TMM' | 'ZMK' | 'ZWD';
/**
 * @ignore
 * @packageDocumentation
 */
/**
 * # Часовые пояса
 */
declare type TimezoneNames = 'Africa/Abidjan' | 'Africa/Accra' | 'Africa/Addis_Ababa' | 'Africa/Algiers' | 'Africa/Asmara' | 'Africa/Asmera' | 'Africa/Bamako' | 'Africa/Bangui' | 'Africa/Banjul' | 'Africa/Bissau' | 'Africa/Blantyre' | 'Africa/Brazzaville' | 'Africa/Bujumbura' | 'Africa/Cairo' | 'Africa/Casablanca' | 'Africa/Ceuta' | 'Africa/Conakry' | 'Africa/Dakar' | 'Africa/Dar_es_Salaam' | 'Africa/Djibouti' | 'Africa/Douala' | 'Africa/El_Aaiun' | 'Africa/Freetown' | 'Africa/Gaborone' | 'Africa/Harare' | 'Africa/Johannesburg' | 'Africa/Juba' | 'Africa/Kampala' | 'Africa/Khartoum' | 'Africa/Kigali' | 'Africa/Kinshasa' | 'Africa/Lagos' | 'Africa/Libreville' | 'Africa/Lome' | 'Africa/Luanda' | 'Africa/Lubumbashi' | 'Africa/Lusaka' | 'Africa/Malabo' | 'Africa/Maputo' | 'Africa/Maseru' | 'Africa/Mbabane' | 'Africa/Mogadishu' | 'Africa/Monrovia' | 'Africa/Nairobi' | 'Africa/Ndjamena' | 'Africa/Niamey' | 'Africa/Nouakchott' | 'Africa/Ouagadougou' | 'Africa/Porto-Novo' | 'Africa/Sao_Tome' | 'Africa/Timbuktu' | 'Africa/Tripoli' | 'Africa/Tunis' | 'Africa/Windhoek' | 'America/Adak' | 'America/Anchorage' | 'America/Anguilla' | 'America/Antigua' | 'America/Araguaina' | 'America/Argentina/Buenos_Aires' | 'America/Argentina/Catamarca' | 'America/Argentina/ComodRivadavia' | 'America/Argentina/Cordoba' | 'America/Argentina/Jujuy' | 'America/Argentina/La_Rioja' | 'America/Argentina/Mendoza' | 'America/Argentina/Rio_Gallegos' | 'America/Argentina/Salta' | 'America/Argentina/San_Juan' | 'America/Argentina/San_Luis' | 'America/Argentina/Tucuman' | 'America/Argentina/Ushuaia' | 'America/Aruba' | 'America/Asuncion' | 'America/Atikokan' | 'America/Atka' | 'America/Bahia' | 'America/Bahia_Banderas' | 'America/Barbados' | 'America/Belem' | 'America/Belize' | 'America/Blanc-Sablon' | 'America/Boa_Vista' | 'America/Bogota' | 'America/Boise' | 'America/Buenos_Aires' | 'America/Cambridge_Bay' | 'America/Campo_Grande' | 'America/Cancun' | 'America/Caracas' | 'America/Catamarca' | 'America/Cayenne' | 'America/Cayman' | 'America/Chicago' | 'America/Chihuahua' | 'America/Coral_Harbour' | 'America/Cordoba' | 'America/Costa_Rica' | 'America/Creston' | 'America/Cuiaba' | 'America/Curacao' | 'America/Danmarkshavn' | 'America/Dawson' | 'America/Dawson_Creek' | 'America/Denver' | 'America/Detroit' | 'America/Dominica' | 'America/Edmonton' | 'America/Eirunepe' | 'America/El_Salvador' | 'America/Ensenada' | 'America/Fort_Nelson' | 'America/Fort_Wayne' | 'America/Fortaleza' | 'America/Glace_Bay' | 'America/Godthab' | 'America/Goose_Bay' | 'America/Grand_Turk' | 'America/Grenada' | 'America/Guadeloupe' | 'America/Guatemala' | 'America/Guayaquil' | 'America/Guyana' | 'America/Halifax' | 'America/Havana' | 'America/Hermosillo' | 'America/Indiana/Indianapolis' | 'America/Indiana/Knox' | 'America/Indiana/Marengo' | 'America/Indiana/Petersburg' | 'America/Indiana/Tell_City' | 'America/Indiana/Vevay' | 'America/Indiana/Vincennes' | 'America/Indiana/Winamac' | 'America/Indianapolis' | 'America/Inuvik' | 'America/Iqaluit' | 'America/Jamaica' | 'America/Jujuy' | 'America/Juneau' | 'America/Kentucky/Louisville' | 'America/Kentucky/Monticello' | 'America/Knox_IN' | 'America/Kralendijk' | 'America/La_Paz' | 'America/Lima' | 'America/Los_Angeles' | 'America/Louisville' | 'America/Lower_Princes' | 'America/Maceio' | 'America/Managua' | 'America/Manaus' | 'America/Marigot' | 'America/Martinique' | 'America/Matamoros' | 'America/Mazatlan' | 'America/Mendoza' | 'America/Menominee' | 'America/Merida' | 'America/Metlakatla' | 'America/Mexico_City' | 'America/Miquelon' | 'America/Moncton' | 'America/Monterrey' | 'America/Montevideo' | 'America/Montreal' | 'America/Montserrat' | 'America/Nassau' | 'America/New_York' | 'America/Nipigon' | 'America/Nome' | 'America/Noronha' | 'America/North_Dakota/Beulah' | 'America/North_Dakota/Center' | 'America/North_Dakota/New_Salem' | 'America/Nuuk' | 'America/Ojinaga' | 'America/Panama' | 'America/Pangnirtung' | 'America/Paramaribo' | 'America/Phoenix' | 'America/Port-au-Prince' | 'America/Port_of_Spain' | 'America/Porto_Acre' | 'America/Porto_Velho' | 'America/Puerto_Rico' | 'America/Punta_Arenas' | 'America/Rainy_River' | 'America/Rankin_Inlet' | 'America/Recife' | 'America/Regina' | 'America/Resolute' | 'America/Rio_Branco' | 'America/Rosario' | 'America/Santa_Isabel' | 'America/Santarem' | 'America/Santiago' | 'America/Santo_Domingo' | 'America/Sao_Paulo' | 'America/Scoresbysund' | 'America/Shiprock' | 'America/Sitka' | 'America/St_Barthelemy' | 'America/St_Johns' | 'America/St_Kitts' | 'America/St_Lucia' | 'America/St_Thomas' | 'America/St_Vincent' | 'America/Swift_Current' | 'America/Tegucigalpa' | 'America/Thule' | 'America/Thunder_Bay' | 'America/Tijuana' | 'America/Toronto' | 'America/Tortola' | 'America/Vancouver' | 'America/Virgin' | 'America/Whitehorse' | 'America/Winnipeg' | 'America/Yakutat' | 'America/Yellowknife' | 'Antarctica/Casey' | 'Antarctica/Davis' | 'Antarctica/DumontDUrville' | 'Antarctica/Macquarie' | 'Antarctica/Mawson' | 'Antarctica/McMurdo' | 'Antarctica/Palmer' | 'Antarctica/Rothera' | 'Antarctica/South_Pole' | 'Antarctica/Syowa' | 'Antarctica/Troll' | 'Antarctica/Vostok' | 'Arctic/Longyearbyen' | 'Asia/Aden' | 'Asia/Almaty' | 'Asia/Amman' | 'Asia/Anadyr' | 'Asia/Aqtau' | 'Asia/Aqtobe' | 'Asia/Ashgabat' | 'Asia/Ashkhabad' | 'Asia/Atyrau' | 'Asia/Baghdad' | 'Asia/Bahrain' | 'Asia/Baku' | 'Asia/Bangkok' | 'Asia/Barnaul' | 'Asia/Beirut' | 'Asia/Bishkek' | 'Asia/Brunei' | 'Asia/Calcutta' | 'Asia/Chita' | 'Asia/Choibalsan' | 'Asia/Chongqing' | 'Asia/Chungking' | 'Asia/Colombo' | 'Asia/Dacca' | 'Asia/Damascus' | 'Asia/Dhaka' | 'Asia/Dili' | 'Asia/Dubai' | 'Asia/Dushanbe' | 'Asia/Famagusta' | 'Asia/Gaza' | 'Asia/Harbin' | 'Asia/Hebron' | 'Asia/Ho_Chi_Minh' | 'Asia/Hong_Kong' | 'Asia/Hovd' | 'Asia/Irkutsk' | 'Asia/Istanbul' | 'Asia/Jakarta' | 'Asia/Jayapura' | 'Asia/Jerusalem' | 'Asia/Kabul' | 'Asia/Kamchatka' | 'Asia/Karachi' | 'Asia/Kashgar' | 'Asia/Kathmandu' | 'Asia/Katmandu' | 'Asia/Khandyga' | 'Asia/Kolkata' | 'Asia/Krasnoyarsk' | 'Asia/Kuala_Lumpur' | 'Asia/Kuching' | 'Asia/Kuwait' | 'Asia/Macao' | 'Asia/Macau' | 'Asia/Magadan' | 'Asia/Makassar' | 'Asia/Manila' | 'Asia/Muscat' | 'Asia/Nicosia' | 'Asia/Novokuznetsk' | 'Asia/Novosibirsk' | 'Asia/Omsk' | 'Asia/Oral' | 'Asia/Phnom_Penh' | 'Asia/Pontianak' | 'Asia/Pyongyang' | 'Asia/Qatar' | 'Asia/Qostanay' | 'Asia/Qyzylorda' | 'Asia/Rangoon' | 'Asia/Riyadh' | 'Asia/Saigon' | 'Asia/Sakhalin' | 'Asia/Samarkand' | 'Asia/Seoul' | 'Asia/Shanghai' | 'Asia/Singapore' | 'Asia/Srednekolymsk' | 'Asia/Taipei' | 'Asia/Tashkent' | 'Asia/Tbilisi' | 'Asia/Tehran' | 'Asia/Tel_Aviv' | 'Asia/Thimbu' | 'Asia/Thimphu' | 'Asia/Tokyo' | 'Asia/Tomsk' | 'Asia/Ujung_Pandang' | 'Asia/Ulaanbaatar' | 'Asia/Ulan_Bator' | 'Asia/Urumqi' | 'Asia/Ust-Nera' | 'Asia/Vientiane' | 'Asia/Vladivostok' | 'Asia/Yakutsk' | 'Asia/Yangon' | 'Asia/Yekaterinburg' | 'Asia/Yerevan' | 'Atlantic/Azores' | 'Atlantic/Bermuda' | 'Atlantic/Canary' | 'Atlantic/Cape_Verde' | 'Atlantic/Faeroe' | 'Atlantic/Faroe' | 'Atlantic/Jan_Mayen' | 'Atlantic/Madeira' | 'Atlantic/Reykjavik' | 'Atlantic/South_Georgia' | 'Atlantic/St_Helena' | 'Atlantic/Stanley' | 'Australia/ACT' | 'Australia/Adelaide' | 'Australia/Brisbane' | 'Australia/Broken_Hill' | 'Australia/Canberra' | 'Australia/Currie' | 'Australia/Darwin' | 'Australia/Eucla' | 'Australia/Hobart' | 'Australia/LHI' | 'Australia/Lindeman' | 'Australia/Lord_Howe' | 'Australia/Melbourne' | 'Australia/NSW' | 'Australia/North' | 'Australia/Perth' | 'Australia/Queensland' | 'Australia/South' | 'Australia/Sydney' | 'Australia/Tasmania' | 'Australia/Victoria' | 'Australia/West' | 'Australia/Yancowinna' | 'Brazil/Acre' | 'Brazil/DeNoronha' | 'Brazil/East' | 'Brazil/West' | 'CET' | 'CST6CDT' | 'Canada/Atlantic' | 'Canada/Central' | 'Canada/Eastern' | 'Canada/Mountain' | 'Canada/Newfoundland' | 'Canada/Pacific' | 'Canada/Saskatchewan' | 'Canada/Yukon' | 'Chile/Continental' | 'Chile/EasterIsland' | 'Cuba' | 'EET' | 'EST' | 'EST5EDT' | 'Egypt' | 'Eire' | 'Etc/GMT' | 'Etc/GMT+0' | 'Etc/GMT+1' | 'Etc/GMT+10' | 'Etc/GMT+11' | 'Etc/GMT+12' | 'Etc/GMT+2' | 'Etc/GMT+3' | 'Etc/GMT+4' | 'Etc/GMT+5' | 'Etc/GMT+6' | 'Etc/GMT+7' | 'Etc/GMT+8' | 'Etc/GMT+9' | 'Etc/GMT-0' | 'Etc/GMT-1' | 'Etc/GMT-10' | 'Etc/GMT-11' | 'Etc/GMT-12' | 'Etc/GMT-13' | 'Etc/GMT-14' | 'Etc/GMT-2' | 'Etc/GMT-3' | 'Etc/GMT-4' | 'Etc/GMT-5' | 'Etc/GMT-6' | 'Etc/GMT-7' | 'Etc/GMT-8' | 'Etc/GMT-9' | 'Etc/GMT0' | 'Etc/Greenwich' | 'Etc/UCT' | 'Etc/UTC' | 'Etc/Universal' | 'Etc/Zulu' | 'Europe/Amsterdam' | 'Europe/Andorra' | 'Europe/Astrakhan' | 'Europe/Athens' | 'Europe/Belfast' | 'Europe/Belgrade' | 'Europe/Berlin' | 'Europe/Bratislava' | 'Europe/Brussels' | 'Europe/Bucharest' | 'Europe/Budapest' | 'Europe/Busingen' | 'Europe/Chisinau' | 'Europe/Copenhagen' | 'Europe/Dublin' | 'Europe/Gibraltar' | 'Europe/Guernsey' | 'Europe/Helsinki' | 'Europe/Isle_of_Man' | 'Europe/Istanbul' | 'Europe/Jersey' | 'Europe/Kaliningrad' | 'Europe/Kiev' | 'Europe/Kirov' | 'Europe/Lisbon' | 'Europe/Ljubljana' | 'Europe/London' | 'Europe/Luxembourg' | 'Europe/Madrid' | 'Europe/Malta' | 'Europe/Mariehamn' | 'Europe/Minsk' | 'Europe/Monaco' | 'Europe/Moscow' | 'Europe/Nicosia' | 'Europe/Oslo' | 'Europe/Paris' | 'Europe/Podgorica' | 'Europe/Prague' | 'Europe/Riga' | 'Europe/Rome' | 'Europe/Samara' | 'Europe/San_Marino' | 'Europe/Sarajevo' | 'Europe/Saratov' | 'Europe/Simferopol' | 'Europe/Skopje' | 'Europe/Sofia' | 'Europe/Stockholm' | 'Europe/Tallinn' | 'Europe/Tirane' | 'Europe/Tiraspol' | 'Europe/Ulyanovsk' | 'Europe/Uzhgorod' | 'Europe/Vaduz' | 'Europe/Vatican' | 'Europe/Vienna' | 'Europe/Vilnius' | 'Europe/Volgograd' | 'Europe/Warsaw' | 'Europe/Zagreb' | 'Europe/Zaporozhye' | 'Europe/Zurich' | 'GB' | 'GB-Eire' | 'GMT' | 'GMT+0' | 'GMT-0' | 'GMT0' | 'Greenwich' | 'HST' | 'Hongkong' | 'Iceland' | 'Indian/Antananarivo' | 'Indian/Chagos' | 'Indian/Christmas' | 'Indian/Cocos' | 'Indian/Comoro' | 'Indian/Kerguelen' | 'Indian/Mahe' | 'Indian/Maldives' | 'Indian/Mauritius' | 'Indian/Mayotte' | 'Indian/Reunion' | 'Iran' | 'Israel' | 'Jamaica' | 'Japan' | 'Kwajalein' | 'Libya' | 'MET' | 'MST' | 'MST7MDT' | 'Mexico/BajaNorte' | 'Mexico/BajaSur' | 'Mexico/General' | 'NZ' | 'NZ-CHAT' | 'Navajo' | 'PRC' | 'PST8PDT' | 'Pacific/Apia' | 'Pacific/Auckland' | 'Pacific/Bougainville' | 'Pacific/Chatham' | 'Pacific/Chuuk' | 'Pacific/Easter' | 'Pacific/Efate' | 'Pacific/Enderbury' | 'Pacific/Fakaofo' | 'Pacific/Fiji' | 'Pacific/Funafuti' | 'Pacific/Galapagos' | 'Pacific/Gambier' | 'Pacific/Guadalcanal' | 'Pacific/Guam' | 'Pacific/Honolulu' | 'Pacific/Johnston' | 'Pacific/Kiritimati' | 'Pacific/Kosrae' | 'Pacific/Kwajalein' | 'Pacific/Majuro' | 'Pacific/Marquesas' | 'Pacific/Midway' | 'Pacific/Nauru' | 'Pacific/Niue' | 'Pacific/Norfolk' | 'Pacific/Noumea' | 'Pacific/Pago_Pago' | 'Pacific/Palau' | 'Pacific/Pitcairn' | 'Pacific/Pohnpei' | 'Pacific/Ponape' | 'Pacific/Port_Moresby' | 'Pacific/Rarotonga' | 'Pacific/Saipan' | 'Pacific/Samoa' | 'Pacific/Tahiti' | 'Pacific/Tarawa' | 'Pacific/Tongatapu' | 'Pacific/Truk' | 'Pacific/Wake' | 'Pacific/Wallis' | 'Pacific/Yap' | 'Poland' | 'Portugal' | 'ROC' | 'ROK' | 'Singapore' | 'Turkey' | 'UCT' | 'US/Alaska' | 'US/Aleutian' | 'US/Arizona' | 'US/Central' | 'US/East-Indiana' | 'US/Eastern' | 'US/Hawaii' | 'US/Indiana-Starke' | 'US/Michigan' | 'US/Mountain' | 'US/Pacific' | 'US/Pacific-New' | 'US/Samoa' | 'UTC' | 'Universal' | 'W-SU' | 'WET' | 'Zulu';
declare const TimezonesObj: Record<TimezoneNames, TimezoneNames>;

interface Application$ServiceDesk$appeal_type$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$appeal_type$Processes extends Processes {
}

interface Application$ServiceDesk$appeal_type extends Application<
        Application$ServiceDesk$appeal_type$Data,
        Application$ServiceDesk$appeal_type$Params,
        Application$ServiceDesk$appeal_type$Processes
    > {
}
type Application$ServiceDesk$appeal_type$Params = any;

type Enum$ServiceDesk$price_plan$supportSchedule = '8ch_5_2'|'24ch';

interface Application$ServiceDesk$price_plan$Data extends ItemData {
    "__name": TString;
    "clientLevel": TApplication<Application$ServiceDesk$client_level$Data, Application$ServiceDesk$client_level$Params, Application$ServiceDesk$client_level$Processes>;
    "services": TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>[];
    "supportSchedule": TEnum<Enum$ServiceDesk$price_plan$supportSchedule>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$price_plan$Processes extends Processes {
}

interface Application$ServiceDesk$price_plan extends Application<
        Application$ServiceDesk$price_plan$Data,
        Application$ServiceDesk$price_plan$Params,
        Application$ServiceDesk$price_plan$Processes
    > {
}
type Application$ServiceDesk$price_plan$Params = any;

interface Application$ServiceDesk$problem_classes$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$problem_classes$Processes extends Processes {
}

interface Application$ServiceDesk$problem_classes extends Application<
        Application$ServiceDesk$problem_classes$Data,
        Application$ServiceDesk$problem_classes$Params,
        Application$ServiceDesk$problem_classes$Processes
    > {
}
type Application$ServiceDesk$problem_classes$Params = any;

type Enum$ServiceDesk$problems$priority = 'high'|'middle'|'low';


interface StatusGroups$ServiceDesk$problems {
    readonly "__default": StatusItem$ServiceDesk$problems$__default;
}

type StatusItem$ServiceDesk$problems$__default = 'new' | 'on_review' | 'decided' | 'impossible_to_decide';

interface Application$ServiceDesk$problems$Data extends ItemData {
    "__name": TString;
    "problemCause": TString;
    "relatedAppeals": TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>[];
    "responsible": TUser;
    "eliminationPeriod": TDatetime;
    "priority": TEnum<Enum$ServiceDesk$problems$priority>;
    "relatedKnownMistake": TApplication<Application$ServiceDesk$known_mistakes$Data, Application$ServiceDesk$known_mistakes$Params, Application$ServiceDesk$known_mistakes$Processes>;
    "problemClass": TApplication<Application$ServiceDesk$problem_classes$Data, Application$ServiceDesk$problem_classes$Params, Application$ServiceDesk$problem_classes$Processes>;
    "relatedCmdb": TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "receivedDecision": TString;
    "associatedAppeals": TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>[];
    "associatedRFC": TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>[];
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$ServiceDesk$problems$__default, StatusGroups$ServiceDesk$problems>;
}

interface Application$ServiceDesk$problems$Processes extends Processes {
    /**
     * Регистрация проблемы
     */
    "problem_registering": Process$ServiceDesk$problems$problem_registering<ProcessContext$ServiceDesk$problems$problem_registering>;
    /**
     * Проблема решена
     */
    "decided_problem": Process$ServiceDesk$problems$decided_problem<ProcessContext$ServiceDesk$problems$decided_problem>;
}

interface Application$ServiceDesk$problems extends Application<
        Application$ServiceDesk$problems$Data,
        Application$ServiceDesk$problems$Params,
        Application$ServiceDesk$problems$Processes
    > {
}
type Application$ServiceDesk$problems$Params = any;

interface Application$ServiceDesk$client_level$Data extends ItemData {
    "__name": TString;
    "description": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$client_level$Processes extends Processes {
}

interface Application$ServiceDesk$client_level extends Application<
        Application$ServiceDesk$client_level$Data,
        Application$ServiceDesk$client_level$Params,
        Application$ServiceDesk$client_level$Processes
    > {
}
type Application$ServiceDesk$client_level$Params = any;

type Enum$ServiceDesk$rfc$priority = 'emergency'|'high'|'normal'|'low';

type Enum$ServiceDesk$rfc$impactDegree = 'low'|'serious'|'high';


interface StatusGroups$ServiceDesk$rfc {
    readonly "__default": StatusItem$ServiceDesk$rfc$__default;
}

type StatusItem$ServiceDesk$rfc$__default = 'new' | 'on_approve' | 'authorized' | 'planned' | 'completed_success' | 'completed_not_success' | 'rejected';

interface Application$ServiceDesk$rfc$Data extends ItemData {
    "__name": TString;
    "initiator": TUser;
    "changeDescription": TString;
    "expectedResult": TString;
    "risks": TString;
    "relatedServices": TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "responsible": TUser[];
    "priority": TEnum<Enum$ServiceDesk$rfc$priority>;
    "impactDegree": TEnum<Enum$ServiceDesk$rfc$impactDegree>;
    "laborIntensity": TFloat;
    "achievedResult": TString;
    "relatedRfc": TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>[];
    "relatedCMDB": TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "associatedProblems": TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>[];
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$ServiceDesk$rfc$__default, StatusGroups$ServiceDesk$rfc>;
}

interface Application$ServiceDesk$rfc$Processes extends Processes {
    /**
     * Зарегистрировать RFC
     */
    "register_rfc": Process$ServiceDesk$rfc$register_rfc<ProcessContext$ServiceDesk$rfc$register_rfc>;
    /**
     * Оценить
     */
    "estimate": Process$ServiceDesk$rfc$estimate<ProcessContext$ServiceDesk$rfc$estimate>;
    /**
     * Завершить
     */
    "complete": Process$ServiceDesk$rfc$complete<ProcessContext$ServiceDesk$rfc$complete>;
    /**
     * Добавить в календарь
     */
    "add_cal_RFC": Process$ServiceDesk$rfc$add_cal_RFC<ProcessContext$ServiceDesk$rfc$add_cal_RFC>;
}

interface Application$ServiceDesk$rfc extends Application<
        Application$ServiceDesk$rfc$Data,
        Application$ServiceDesk$rfc$Params,
        Application$ServiceDesk$rfc$Processes
    > {
}
type Application$ServiceDesk$rfc$Params = any;

interface Application$ServiceDesk$vid_uslugi$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$vid_uslugi$Processes extends Processes {
}

interface Application$ServiceDesk$vid_uslugi extends Application<
        Application$ServiceDesk$vid_uslugi$Data,
        Application$ServiceDesk$vid_uslugi$Params,
        Application$ServiceDesk$vid_uslugi$Processes
    > {
}
type Application$ServiceDesk$vid_uslugi$Params = any;

type Enum$ServiceDesk$support_level$operatorGroup = 'operator_sd'|'supervisor';

interface Application$ServiceDesk$support_level$Data extends ItemData {
    "__name": TString;
    "operatorGroup": TEnum<Enum$ServiceDesk$support_level$operatorGroup>[];
    "operators": TUser[];
    "supervisor": TUser[];
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$support_level$Processes extends Processes {
}

interface Application$ServiceDesk$support_level extends Application<
        Application$ServiceDesk$support_level$Data,
        Application$ServiceDesk$support_level$Params,
        Application$ServiceDesk$support_level$Processes
    > {
}
type Application$ServiceDesk$support_level$Params = any;

interface Application$ServiceDesk$tag$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$tag$Processes extends Processes {
}

interface Application$ServiceDesk$tag extends Application<
        Application$ServiceDesk$tag$Data,
        Application$ServiceDesk$tag$Params,
        Application$ServiceDesk$tag$Processes
    > {
}
type Application$ServiceDesk$tag$Params = any;

type Enum$ServiceDesk$cmdb$type = 'it_services'|'applied_architecture'|'physical_elements'|'licenses_and_software';

type Enum$ServiceDesk$cmdb$linksType = 'link'|'dependent';



interface Table$ServiceDesk$cmdb$financiallyResponsible$Row {
     "__count": TFloat;
     "__index": TFloat;
     "financiallyResponsible": TUser;
     "status": TString;
     "transmissionDate": TDatetime;
}

interface Table$ServiceDesk$cmdb$financiallyResponsible$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "financiallyResponsible": Readonly<TString>;
    readonly "status": Readonly<TString>;
    readonly "transmissionDate": Readonly<TString>;
}


type Enum$ServiceDesk$cmdb$productivityStatus = 'work'|'unavailable'|'not_work';


interface StatusGroups$ServiceDesk$cmdb {
    readonly "__default": StatusItem$ServiceDesk$cmdb$__default;
}

type StatusItem$ServiceDesk$cmdb$__default = 'new' | 'is_used' | 'cancellation' | 'keeping' | 'transferred_to_response';

interface Application$ServiceDesk$cmdb$Data extends ItemData {
    "id": TString;
    "__name": TString;
    "type": TEnum<Enum$ServiceDesk$cmdb$type>;
    "relatedService": TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>[];
    "technicalInformation": TString;
    "cost": TMoney<'RUB'>;
    "deliveryDate": TDate;
    "materialResponsible": TUser;
    "deliveryDetails": TString;
    "guaranteeResponsibility": TFile;
    "problems": TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>;
    "residualValue": TString;
    "linksType": TEnum<Enum$ServiceDesk$cmdb$linksType>;
    "financiallyResponsible": TTable<Table$ServiceDesk$cmdb$financiallyResponsible$Row, Table$ServiceDesk$cmdb$financiallyResponsible$Result>;
    "financiallyResponsibleVisible": TBoolean;
    "productivityStatus": TEnum<Enum$ServiceDesk$cmdb$productivityStatus>;
    "parentCI": TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>[];
    "childCI": TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>[];
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$ServiceDesk$cmdb$__default, StatusGroups$ServiceDesk$cmdb>;
}

interface Application$ServiceDesk$cmdb$Processes extends Processes {
    /**
     * Изменение статуса работоспособности
     */
    "changing_productivity_status": Process$ServiceDesk$cmdb$changing_productivity_status<ProcessContext$ServiceDesk$cmdb$changing_productivity_status>;
    /**
     * Добавление дочернего/родительского элемента
     */
    "add_child_parent_element": Process$ServiceDesk$cmdb$add_child_parent_element<ProcessContext$ServiceDesk$cmdb$add_child_parent_element>;
    /**
     * Зарегистрировать проблему
     */
    "register_problem": Process$ServiceDesk$cmdb$register_problem<ProcessContext$ServiceDesk$cmdb$register_problem>;
    /**
     * Редактирование актива
     */
    "editing_cmdb": Process$ServiceDesk$cmdb$editing_cmdb<ProcessContext$ServiceDesk$cmdb$editing_cmdb>;
    /**
     * Изменение материально ответственного лица
     */
    "change_financially_response": Process$ServiceDesk$cmdb$change_financially_response<ProcessContext$ServiceDesk$cmdb$change_financially_response>;
}

interface Application$ServiceDesk$cmdb extends Application<
        Application$ServiceDesk$cmdb$Data,
        Application$ServiceDesk$cmdb$Params,
        Application$ServiceDesk$cmdb$Processes
    > {
}
type Application$ServiceDesk$cmdb$Params = any;


interface StatusGroups$ServiceDesk$kalendar_rfc {
    readonly "__default": StatusItem$ServiceDesk$kalendar_rfc$__default;
}

type StatusItem$ServiceDesk$kalendar_rfc$__default = 'opened' | 'closed';

interface Application$ServiceDesk$kalendar_rfc$Data extends ItemData {
    "__name": TString;
    "__startAt": TDatetime;
    "__endAt": TDatetime;
    "__participants": TUser[];
    "rfc": TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$ServiceDesk$kalendar_rfc$__default, StatusGroups$ServiceDesk$kalendar_rfc>;
}

interface Application$ServiceDesk$kalendar_rfc$Processes extends Processes {
}

interface Application$ServiceDesk$kalendar_rfc extends Application<
        Application$ServiceDesk$kalendar_rfc$Data,
        Application$ServiceDesk$kalendar_rfc$Params,
        Application$ServiceDesk$kalendar_rfc$Processes
    > {
}
type Application$ServiceDesk$kalendar_rfc$Params = any;

interface Application$ServiceDesk$known_mistakes$Data extends ItemData {
    "__name": TString;
    "decisionRegulations": TFile;
    "evasionProcedure": TString;
    "temporaryDecision": TApplication<Application$ServiceDesk$decisions$Data, Application$ServiceDesk$decisions$Params, Application$ServiceDesk$decisions$Processes>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$known_mistakes$Processes extends Processes {
}

interface Application$ServiceDesk$known_mistakes extends Application<
        Application$ServiceDesk$known_mistakes$Data,
        Application$ServiceDesk$known_mistakes$Params,
        Application$ServiceDesk$known_mistakes$Processes
    > {
}
type Application$ServiceDesk$known_mistakes$Params = any;



interface Table$ServiceDesk$sla_level$keyMetrics$Row {
     "__count": TFloat;
     "__index": TFloat;
     "keyIndicator": TString;
     "acceptableValue": TString;
}

interface Table$ServiceDesk$sla_level$keyMetrics$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "keyIndicator": Readonly<TString>;
    readonly "acceptableValue": Readonly<TString>;
}


type Enum$ServiceDesk$sla_level$actionOnViolation = 'notification_to_manager'|'task_to_supervisor'|'task_to_manager';

interface Application$ServiceDesk$sla_level$Data extends ItemData {
    "__name": TString;
    "service": TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "clientLevel": TApplication<Application$ServiceDesk$client_level$Data, Application$ServiceDesk$client_level$Params, Application$ServiceDesk$client_level$Processes>;
    "reactionTime": TFloat;
    "normativeDecisionTime": TFloat;
    "acceptableDowntime": TFloat;
    "keyMetrics": TTable<Table$ServiceDesk$sla_level$keyMetrics$Row, Table$ServiceDesk$sla_level$keyMetrics$Result>;
    "actionOnViolation": TEnum<Enum$ServiceDesk$sla_level$actionOnViolation>;
    "createMore": TBoolean;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$sla_level$Processes extends Processes {
    /**
     * Создать еще Уровень SLA
     */
    "create_more_sla_level": Process$ServiceDesk$sla_level$create_more_sla_level<ProcessContext$ServiceDesk$sla_level$create_more_sla_level>;
}

interface Application$ServiceDesk$sla_level extends Application<
        Application$ServiceDesk$sla_level$Data,
        Application$ServiceDesk$sla_level$Params,
        Application$ServiceDesk$sla_level$Processes
    > {
}
type Application$ServiceDesk$sla_level$Params = any;

type Enum$ServiceDesk$services$servicePriority = 'low'|'middle'|'high'|'blocker';

interface Application$ServiceDesk$services$Data extends ItemData {
    "__name": TString;
    "description": TString;
    "responsible": TUser;
    "roditelskii_element": TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "servicePriority": TEnum<Enum$ServiceDesk$services$servicePriority>;
    "elementLevel": TFloat;
    "tags": TApplication<Application$ServiceDesk$tag$Data, Application$ServiceDesk$tag$Params, Application$ServiceDesk$tag$Processes>[];
    "supportLevel": TApplication<Application$ServiceDesk$support_level$Data, Application$ServiceDesk$support_level$Params, Application$ServiceDesk$support_level$Processes>;
    "relatedService": TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>[];
    "uslugi": TApplication<Application$ServiceDesk$vid_uslugi$Data, Application$ServiceDesk$vid_uslugi$Params, Application$ServiceDesk$vid_uslugi$Processes>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$services$Processes extends Processes {
    /**
     * Новый сервис
     */
    "create_new_service": Process$ServiceDesk$services$create_new_service<ProcessContext$ServiceDesk$services$create_new_service>;
}

interface Application$ServiceDesk$services extends Application<
        Application$ServiceDesk$services$Data,
        Application$ServiceDesk$services$Params,
        Application$ServiceDesk$services$Processes
    > {
}
type Application$ServiceDesk$services$Params = any;

interface Application$ServiceDesk$routing_types$Data extends ItemData {
    "__name": TString;
    "description": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$routing_types$Processes extends Processes {
}

interface Application$ServiceDesk$routing_types extends Application<
        Application$ServiceDesk$routing_types$Data,
        Application$ServiceDesk$routing_types$Params,
        Application$ServiceDesk$routing_types$Processes
    > {
}
type Application$ServiceDesk$routing_types$Params = any;

type Enum$ServiceDesk$appeals$priority = 'high'|'middle'|'low';


interface StatusGroups$ServiceDesk$appeals {
    readonly "__default": StatusItem$ServiceDesk$appeals$__default;
}

type StatusItem$ServiceDesk$appeals$__default = 'new' | 'accepted' | 'in_work' | 'in_waiting' | 'decided' | 'archive';

interface Application$ServiceDesk$appeals$Data extends ItemData {
    "responsible": TUser;
    "service": TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "client": TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "appealText": TString;
    "regulationTime": TDatetime;
    "actualTime": TDatetime;
    "decisionDescription": TString;
    "estimation": TFloat;
    "comment": TString;
    "observers": TUser[];
    "slaLevel": TApplication<Application$ServiceDesk$sla_level$Data, Application$ServiceDesk$sla_level$Params, Application$ServiceDesk$sla_level$Processes>;
    "priority": TEnum<Enum$ServiceDesk$appeals$priority>;
    "attachments": TFile[];
    "allAttachments": TFile[];
    "putOnHold": TBoolean;
    "sendMail": TBoolean;
    "author": TAccount<AccountType>[];
    "tariff": TApplication<Application$ServiceDesk$price_plan$Data, Application$ServiceDesk$price_plan$Params, Application$ServiceDesk$price_plan$Processes>;
    "clientLevel": TApplication<Application$ServiceDesk$client_level$Data, Application$ServiceDesk$client_level$Params, Application$ServiceDesk$client_level$Processes>;
    "reactionTime": TFloat;
    "clientComment": TString;
    "tags": TApplication<Application$ServiceDesk$tag$Data, Application$ServiceDesk$tag$Params, Application$ServiceDesk$tag$Processes>;
    "theme": TString;
    "problems": TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>[];
    "appealType": TApplication<Application$ServiceDesk$appeal_type$Data, Application$ServiceDesk$appeal_type$Params, Application$ServiceDesk$appeal_type$Processes>;
    "currentSupportLevel": TApplication<Application$ServiceDesk$support_level$Data, Application$ServiceDesk$support_level$Params, Application$ServiceDesk$support_level$Processes>;
    "externalUser": TApplication<Application$_system_catalogs$_user_profiles$Data, Application$_system_catalogs$_user_profiles$Params, Application$_system_catalogs$_user_profiles$Processes>;
    "remainingTime": TFloat;
    "changeStatusDate": TDatetime;
    "analysed": TBoolean;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$ServiceDesk$appeals$__default, StatusGroups$ServiceDesk$appeals>;
}

interface Application$ServiceDesk$appeals$Processes extends Processes {
    /**
     * Создать обращение
     */
    "create_appeal": Process$ServiceDesk$appeals$create_appeal<ProcessContext$ServiceDesk$appeals$create_appeal>;
    /**
     * Эскалация по SLA
     */
    "escalation_by_sla": Process$ServiceDesk$appeals$escalation_by_sla<ProcessContext$ServiceDesk$appeals$escalation_by_sla>;
    /**
     * Взять в работу
     */
    "take_appeal_to_work": Process$ServiceDesk$appeals$take_appeal_to_work<ProcessContext$ServiceDesk$appeals$take_appeal_to_work>;
    /**
     * Назначить ответственного
     */
    "appoint_responsible": Process$ServiceDesk$appeals$appoint_responsible<ProcessContext$ServiceDesk$appeals$appoint_responsible>;
    /**
     * Перевести на уровень
     */
    "transfer_to_level": Process$ServiceDesk$appeals$transfer_to_level<ProcessContext$ServiceDesk$appeals$transfer_to_level>;
    /**
     * Добавить решение
     */
    "add_solution": Process$ServiceDesk$appeals$add_solution<ProcessContext$ServiceDesk$appeals$add_solution>;
    /**
     * Перевести в ожидание
     */
    "put_appeal_on_hold": Process$ServiceDesk$appeals$put_appeal_on_hold<ProcessContext$ServiceDesk$appeals$put_appeal_on_hold>;
    /**
     * Снять ожидание
     */
    "remove_from_holding": Process$ServiceDesk$appeals$remove_from_holding<ProcessContext$ServiceDesk$appeals$remove_from_holding>;
    /**
     * Подписаться на обращение
     */
    "subscribe_to_appeal": Process$ServiceDesk$appeals$subscribe_to_appeal<ProcessContext$ServiceDesk$appeals$subscribe_to_appeal>;
    /**
     * Массовый перевод в ожидание
     */
    "mass_status_to_waiting": Process$ServiceDesk$appeals$mass_status_to_waiting<ProcessContext$ServiceDesk$appeals$mass_status_to_waiting>;
    /**
     * Создать обращение от внешнего пользователя
     */
    "create_appeal_from_external_user": Process$ServiceDesk$appeals$create_appeal_from_external_user<ProcessContext$ServiceDesk$appeals$create_appeal_from_external_user>;
    /**
     * Рассмотрение обращения менеджером
     */
    "consideration_request_by_manager": Process$ServiceDesk$appeals$consideration_request_by_manager<ProcessContext$ServiceDesk$appeals$consideration_request_by_manager>;
    /**
     * Массовая смена ответственного
     */
    "mass_change_responsible": Process$ServiceDesk$appeals$mass_change_responsible<ProcessContext$ServiceDesk$appeals$mass_change_responsible>;
    /**
     * Рассмотрение обращения супервизором
     */
    "consideration_appeal_by_supervisor": Process$ServiceDesk$appeals$consideration_appeal_by_supervisor<ProcessContext$ServiceDesk$appeals$consideration_appeal_by_supervisor>;
    /**
     * Массовое добавление решения
     */
    "mass_add_solution": Process$ServiceDesk$appeals$mass_add_solution<ProcessContext$ServiceDesk$appeals$mass_add_solution>;
}

interface Application$ServiceDesk$appeals extends Application<
        Application$ServiceDesk$appeals$Data,
        Application$ServiceDesk$appeals$Params,
        Application$ServiceDesk$appeals$Processes
    > {
}
type Application$ServiceDesk$appeals$Params = any;

interface Application$ServiceDesk$operator_weight$Data extends ItemData {
    "operator": TUser;
    "operatorWeight": TString;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$operator_weight$Processes extends Processes {
}

interface Application$ServiceDesk$operator_weight extends Application<
        Application$ServiceDesk$operator_weight$Data,
        Application$ServiceDesk$operator_weight$Params,
        Application$ServiceDesk$operator_weight$Processes
    > {
}
type Application$ServiceDesk$operator_weight$Params = any;

interface Application$ServiceDesk$response_template$Data extends ItemData {
    "__name": TString;
    "answerText": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$ServiceDesk$response_template$Processes extends Processes {
}

interface Application$ServiceDesk$response_template extends Application<
        Application$ServiceDesk$response_template$Data,
        Application$ServiceDesk$response_template$Params,
        Application$ServiceDesk$response_template$Processes
    > {
}
type Application$ServiceDesk$response_template$Params = any;


interface StatusGroups$ServiceDesk$decisions {
    readonly "__default": StatusItem$ServiceDesk$decisions$__default;
}

type StatusItem$ServiceDesk$decisions$__default = 'new' | 'valued' | 'approved';

interface Application$ServiceDesk$decisions$Data extends ItemData {
    "__name": TString;
    "decisionText": TString;
    "dateTime": TDatetime;
    "appeals": TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "responsible": TUser;
    "service": TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "tags": TApplication<Application$ServiceDesk$tag$Data, Application$ServiceDesk$tag$Params, Application$ServiceDesk$tag$Processes>[];
    "publicDecision": TBoolean;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$ServiceDesk$decisions$__default, StatusGroups$ServiceDesk$decisions>;
}

interface Application$ServiceDesk$decisions$Processes extends Processes {
}

interface Application$ServiceDesk$decisions extends Application<
        Application$ServiceDesk$decisions$Data,
        Application$ServiceDesk$decisions$Params,
        Application$ServiceDesk$decisions$Processes
    > {
}
type Application$ServiceDesk$decisions$Params = any;

interface Namespace$ServiceDesk extends NamespaceBase<Readonly<{
    "appeal_type": Application$ServiceDesk$appeal_type;
    "price_plan": Application$ServiceDesk$price_plan;
    "problem_classes": Application$ServiceDesk$problem_classes;
    "problems": Application$ServiceDesk$problems;
    "client_level": Application$ServiceDesk$client_level;
    "rfc": Application$ServiceDesk$rfc;
    "vid_uslugi": Application$ServiceDesk$vid_uslugi;
    "support_level": Application$ServiceDesk$support_level;
    "tag": Application$ServiceDesk$tag;
    "cmdb": Application$ServiceDesk$cmdb;
    "kalendar_rfc": Application$ServiceDesk$kalendar_rfc;
    "known_mistakes": Application$ServiceDesk$known_mistakes;
    "sla_level": Application$ServiceDesk$sla_level;
    "services": Application$ServiceDesk$services;
    "routing_types": Application$ServiceDesk$routing_types;
    "appeals": Application$ServiceDesk$appeals;
    "operator_weight": Application$ServiceDesk$operator_weight;
    "response_template": Application$ServiceDesk$response_template;
    "decisions": Application$ServiceDesk$decisions;
}>> {
}


interface StatusGroups$_cashflow$_transactions {
    readonly "__default": StatusItem$_cashflow$_transactions$__default;
}

type StatusItem$_cashflow$_transactions$__default = 'new' | 'on_distribution' | 'distributed';

interface Application$_cashflow$_transactions$Data extends ItemData {
    "_totalAmount": TFloat;
    "_paymentDate": TDatetime;
    "_companyData": TString;
    "_purpose": TString;
    "_company": TRefItem;
    "_planIncomes": TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>[];
    "_factIncomes": TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>[];
    "_undistribAmount": TFloat;
    "_attachments": TFile[];
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$_cashflow$_transactions$__default, StatusGroups$_cashflow$_transactions>;
}

interface Application$_cashflow$_transactions$Processes extends Processes {
}

interface Application$_cashflow$_transactions extends Application<
        Application$_cashflow$_transactions$Data,
        Application$_cashflow$_transactions$Params,
        Application$_cashflow$_transactions$Processes
    > {
}
type Application$_cashflow$_transactions$Params = any;

type Enum$_cashflow$_cash_flow_items$_category = 'receipt'|'payment'|'group';

type Enum$_cashflow$_cash_flow_items$_activities = 'operating'|'investing'|'financing';

interface Application$_cashflow$_cash_flow_items$Data extends ItemData {
    "_name": TString;
    "_description": TString;
    "_category": TEnum<Enum$_cashflow$_cash_flow_items$_category>;
    "_activities": TEnum<Enum$_cashflow$_cash_flow_items$_activities>;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_cashflow$_cash_flow_items$Processes extends Processes {
}

interface Application$_cashflow$_cash_flow_items extends Application<
        Application$_cashflow$_cash_flow_items$Data,
        Application$_cashflow$_cash_flow_items$Params,
        Application$_cashflow$_cash_flow_items$Processes
    > {
}
type Application$_cashflow$_cash_flow_items$Params = any;

type Enum$_cashflow$_expense$_planFact = 'plan'|'fact';


interface StatusGroups$_cashflow$_expense {
    readonly "__default": StatusItem$_cashflow$_expense$__default;
}

type StatusItem$_cashflow$_expense$__default = 'on_approvement' | 'approved' | 'put_to_plan' | 'paid' | 'rejected' | 'deducted' | 'duplicate';

interface Application$_cashflow$_expense$Data extends ItemData {
    "__name": TString;
    "_amount": TFloat;
    "_date": TDate;
    "_attachments": TFile[];
    "_linkedExpend": TApplication<Application$_cashflow$_expense$Data, Application$_cashflow$_expense$Params, Application$_cashflow$_expense$Processes>[];
    "_comment": TString;
    "_planFact": TEnum<Enum$_cashflow$_expense$_planFact>;
    "_cashFlowItem": TApplication<Application$_cashflow$_cash_flow_items$Data, Application$_cashflow$_cash_flow_items$Params, Application$_cashflow$_cash_flow_items$Processes>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$_cashflow$_expense$__default, StatusGroups$_cashflow$_expense>;
}

interface Application$_cashflow$_expense$Processes extends Processes {
}

interface Application$_cashflow$_expense extends Application<
        Application$_cashflow$_expense$Data,
        Application$_cashflow$_expense$Params,
        Application$_cashflow$_expense$Processes
    > {
}
type Application$_cashflow$_expense$Params = any;

type Enum$_cashflow$_income$_planFact = 'plan'|'fact';


interface StatusGroups$_cashflow$_income {
    readonly "__default": StatusItem$_cashflow$_income$__default;
}

type StatusItem$_cashflow$_income$__default = 'pending' | 'partly' | 'paid' | 'cancelled' | 'received';

interface Application$_cashflow$_income$Data extends ItemData {
    "_name": TString;
    "_responsible": TUser;
    "_cashFlowItem": TApplication<Application$_cashflow$_cash_flow_items$Data, Application$_cashflow$_cash_flow_items$Params, Application$_cashflow$_cash_flow_items$Processes>;
    "_amount": TFloat;
    "_description": TString;
    "_attachments": TFile[];
    "_paymentDate": TDatetime;
    "_factIncome": TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>[];
    "_app": TRefItem;
    "_actualReceipts": TFloat;
    "_planFact": TEnum<Enum$_cashflow$_income$_planFact>;
    "_company": TRefItem;
    "_latePaymentRisk": TBoolean;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$_cashflow$_income$__default, StatusGroups$_cashflow$_income>;
    "_responsibilityCenter": TApplication<Application$_cashflow$_responsibilityCenter$Data, Application$_cashflow$_responsibilityCenter$Params, Application$_cashflow$_responsibilityCenter$Processes>;
}

interface Application$_cashflow$_income$Processes extends Processes {
}

interface Application$_cashflow$_income extends Application<
        Application$_cashflow$_income$Data,
        Application$_cashflow$_income$Params,
        Application$_cashflow$_income$Processes
    > {
}
type Application$_cashflow$_income$Params = any;

interface Application$_cashflow$_responsibilityCenter$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "_manager": TUser;
    "_approver": TUser;
    "_finalApprover": TUser;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_cashflow$_responsibilityCenter$Processes extends Processes {
}

interface Application$_cashflow$_responsibilityCenter extends Application<
        Application$_cashflow$_responsibilityCenter$Data,
        Application$_cashflow$_responsibilityCenter$Params,
        Application$_cashflow$_responsibilityCenter$Processes
    > {
}
type Application$_cashflow$_responsibilityCenter$Params = any;

interface Processes$_cashflow extends Processes {
    /**
     * Добавить плановое поступление
     */
    "add_income_item": Process$_cashflow$add_income_item<ProcessContext$_cashflow$add_income_item>;
    /**
     * Редактирование поступления
     */
    "edit_income": Process$_cashflow$edit_income<ProcessContext$_cashflow$edit_income>;
    /**
     * Создать фактическое поступление
     */
    "create_income_fact": Process$_cashflow$create_income_fact<ProcessContext$_cashflow$create_income_fact>;
    /**
     * Распределение платежа
     */
    "fact_distribution": Process$_cashflow$fact_distribution<ProcessContext$_cashflow$fact_distribution>;
    /**
     * Уведомление о новом платеже
     */
    "new_fact_notification": Process$_cashflow$new_fact_notification<ProcessContext$_cashflow$new_fact_notification>;
}
interface Namespace$_cashflow extends NamespaceBase<Readonly<{
    "_transactions": Application$_cashflow$_transactions;
    "_cash_flow_items": Application$_cashflow$_cash_flow_items;
    "_expense": Application$_cashflow$_expense;
    "_income": Application$_cashflow$_income;
    "_responsibilityCenter": Application$_cashflow$_responsibilityCenter;
}>> {
    readonly processes: Processes$_cashflow;
}

interface Application$_clients$_sales_teams$Data extends ItemData {
    "__name": TString;
    "_responsible": TUser;
    "_teamEmployees": TUser[];
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_clients$_sales_teams$Processes extends Processes {
}

interface Application$_clients$_sales_teams extends Application<
        Application$_clients$_sales_teams$Data,
        Application$_clients$_sales_teams$Params,
        Application$_clients$_sales_teams$Processes
    > {
}
type Application$_clients$_sales_teams$Params = any;

interface Application$_clients$_lead_sources$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "_preferences": TApplication<Application$_marketing$_preferences$Data, Application$_marketing$_preferences$Params, Application$_marketing$_preferences$Processes>[];
}

interface Application$_clients$_lead_sources$Processes extends Processes {
}

interface Application$_clients$_lead_sources extends Application<
        Application$_clients$_lead_sources$Data,
        Application$_clients$_lead_sources$Params,
        Application$_clients$_lead_sources$Processes
    > {
}
type Application$_clients$_lead_sources$Params = any;

interface Application$_clients$_contacts$Data extends ItemData {
    "__name": TString;
    "_fullname": TFullName;
    "_position": TString;
    "_phone": TPhone<PhoneType>[];
    "_email": TEmail<EmailType.Work>;
    "_skype": TString;
    "_companies": TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "_leads": TApplication<Application$_clients$_leads$Data, Application$_clients$_leads$Params, Application$_clients$_leads$Processes>[];
    "_opportunities": TApplication<Application$_clients$_opportunities$Data, Application$_clients$_opportunities$Params, Application$_clients$_opportunities$Processes>[];
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "_account": TAccount<AccountType>[];
    "_preferences": TApplication<Application$_marketing$_preferences$Data, Application$_marketing$_preferences$Params, Application$_marketing$_preferences$Processes>[];
}

interface Application$_clients$_contacts$Processes extends Processes {
}

interface Application$_clients$_contacts extends Application<
        Application$_clients$_contacts$Data,
        Application$_clients$_contacts$Params,
        Application$_clients$_contacts$Processes
    > {
}
type Application$_clients$_contacts$Params = any;

interface Application$_clients$_industries$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_clients$_industries$Processes extends Processes {
}

interface Application$_clients$_industries extends Application<
        Application$_clients$_industries$Data,
        Application$_clients$_industries$Params,
        Application$_clients$_industries$Processes
    > {
}
type Application$_clients$_industries$Params = any;

interface Application$_clients$_products$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "_preferences": TApplication<Application$_marketing$_preferences$Data, Application$_marketing$_preferences$Params, Application$_marketing$_preferences$Processes>[];
}

interface Application$_clients$_products$Processes extends Processes {
}

interface Application$_clients$_products extends Application<
        Application$_clients$_products$Data,
        Application$_clients$_products$Params,
        Application$_clients$_products$Processes
    > {
}
type Application$_clients$_products$Params = any;

interface Application$_clients$_marketing_efforts$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "_goal": TString;
    "_responsible": TUser;
    "_start_date": TDatetime;
    "_due_date": TDatetime;
    "_budget": TMoney<'RUB'>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_clients$_marketing_efforts$Processes extends Processes {
}

interface Application$_clients$_marketing_efforts extends Application<
        Application$_clients$_marketing_efforts$Data,
        Application$_clients$_marketing_efforts$Params,
        Application$_clients$_marketing_efforts$Processes
    > {
}
type Application$_clients$_marketing_efforts$Params = any;

interface Application$_clients$postuplenie$Data extends ItemData {
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_clients$postuplenie$Processes extends Processes {
}

interface Application$_clients$postuplenie extends Application<
        Application$_clients$postuplenie$Data,
        Application$_clients$postuplenie$Params,
        Application$_clients$postuplenie$Processes
    > {
}
type Application$_clients$postuplenie$Params = any;

type Enum$_clients$_opportunities$_need_level = 'informed'|'interested'|'strong_need';

type Enum$_clients$_opportunities$_qualification_type = '_create_lead_and_company'|'_create_company';


interface StatusGroups$_clients$_opportunities {
    readonly "__default": StatusItem$_clients$_opportunities$__default;
}

type StatusItem$_clients$_opportunities$__default = 'new' | 'progress' | 'success' | 'rejected';

interface Application$_clients$_opportunities$Data extends ItemData {
    "__name": TString;
    "_owner": TUser;
    "_company": TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "_contacts": TApplication<Application$_clients$_contacts$Data, Application$_clients$_contacts$Params, Application$_clients$_contacts$Processes>[];
    "_products": TApplication<Application$_clients$_products$Data, Application$_clients$_products$Params, Application$_clients$_products$Processes>;
    "_lead": TApplication<Application$_clients$_leads$Data, Application$_clients$_leads$Params, Application$_clients$_leads$Processes>;
    "_warmup": TBoolean;
    "_marketing_efforts": TApplication<Application$_clients$_marketing_efforts$Data, Application$_clients$_marketing_efforts$Params, Application$_clients$_marketing_efforts$Processes>;
    "_lead_source": TApplication<Application$_clients$_lead_sources$Data, Application$_clients$_lead_sources$Params, Application$_clients$_lead_sources$Processes>;
    "_need_level": TEnum<Enum$_clients$_opportunities$_need_level>;
    "_qualification_type": TEnum<Enum$_clients$_opportunities$_qualification_type>;
    "__statusComment": TString;
    "utm_source": TString;
    "utm_medium": TString;
    "utm_campaign": TString;
    "nomer_uchastka": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$_clients$_opportunities$__default, StatusGroups$_clients$_opportunities>;
    "_lastActivity": TDatetime;
    "__statusChangedAt": TDatetime;
}

interface Application$_clients$_opportunities$Processes extends Processes {
    /**
     * Process for funnel "2f0e9c45-74a1-4205-b06e-77c8bb72f6e6" status "7" set
     */
    "on_status_set_7": Process$_clients$_opportunities$on_status_set_7<ProcessContext$_clients$_opportunities$on_status_set_7>;
    /**
     * Process for funnel "00000000-0000-0000-0000-000000000000" status "3" set
     */
    "on_status_set_3": Process$_clients$_opportunities$on_status_set_3<ProcessContext$_clients$_opportunities$on_status_set_3>;
}

interface Application$_clients$_opportunities extends Application<
        Application$_clients$_opportunities$Data,
        Application$_clients$_opportunities$Params,
        Application$_clients$_opportunities$Processes
    > {
}
type Application$_clients$_opportunities$Params = any;


interface StatusGroups$_clients$_leads {
    readonly "__default": StatusItem$_clients$_leads$__default;
}

type StatusItem$_clients$_leads$__default = 'new' | 'negotiation' | 'signing' | 'success' | 'rejected';

interface Application$_clients$_leads$Data extends ItemData {
    "__name": TString;
    "_owner": TUser;
    "_companies": TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "_contacts": TApplication<Application$_clients$_contacts$Data, Application$_clients$_contacts$Params, Application$_clients$_contacts$Processes>[];
    "_budget": TMoney<'RUB'>;
    "_address": TString;
    "_plannedDueDate": TDate;
    "__statusComment": TString;
    "utm_source": TString;
    "utm_medium": TString;
    "utm_campaign": TString;
    "_qualified": TBoolean;
    "_opportunity": TApplication<Application$_clients$_opportunities$Data, Application$_clients$_opportunities$Params, Application$_clients$_opportunities$Processes>;
    "zemelnyi_uchastok": TApplication<Application$realestate$land$Data, Application$realestate$land$Params, Application$realestate$land$Processes>;
    "dogovor_na_pokupku_nedvizhimosti": TApplication<Application$realestate$dogovor_na_pokupku_nedvizhimosti$Data, Application$realestate$dogovor_na_pokupku_nedvizhimosti$Params, Application$realestate$dogovor_na_pokupku_nedvizhimosti$Processes>[];
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$_clients$_leads$__default, StatusGroups$_clients$_leads>;
    "_lastActivity": TDatetime;
    "__statusChangedAt": TDatetime;
}

interface Application$_clients$_leads$Processes extends Processes {
    /**
     * Сделка по продаже недвижимости
     */
    "sdelka_po_prodazhe_nedvizhimosti": Process$_clients$_leads$sdelka_po_prodazhe_nedvizhimosti<ProcessContext$_clients$_leads$sdelka_po_prodazhe_nedvizhimosti>;
    /**
     * Звонок
     */
    "_call": Process$_clients$_leads$_call<ProcessContext$_clients$_leads$_call>;
    /**
     * Встреча
     */
    "_meeting": Process$_clients$_leads$_meeting<ProcessContext$_clients$_leads$_meeting>;
    /**
     * Вебинар
     */
    "_webinar": Process$_clients$_leads$_webinar<ProcessContext$_clients$_leads$_webinar>;
    /**
     * Письмо
     */
    "_letter": Process$_clients$_leads$_letter<ProcessContext$_clients$_leads$_letter>;
}

interface Application$_clients$_leads extends Application<
        Application$_clients$_leads$Data,
        Application$_clients$_leads$Params,
        Application$_clients$_leads$Processes
    > {
}
type Application$_clients$_leads$Params = any;

interface Application$_clients$_segments$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_clients$_segments$Processes extends Processes {
}

interface Application$_clients$_segments extends Application<
        Application$_clients$_segments$Data,
        Application$_clients$_segments$Params,
        Application$_clients$_segments$Processes
    > {
}
type Application$_clients$_segments$Params = any;

interface Application$_clients$_companies$Data extends ItemData {
    "__name": TString;
    "_phone": TPhone<PhoneType.Work>;
    "_email": TEmail<EmailType.Work>;
    "_website": TLink;
    "_address": TString;
    "_inn": TString;
    "_kpp": TString;
    "_leads": TApplication<Application$_clients$_leads$Data, Application$_clients$_leads$Params, Application$_clients$_leads$Processes>[];
    "_opportunities": TApplication<Application$_clients$_opportunities$Data, Application$_clients$_opportunities$Params, Application$_clients$_opportunities$Processes>[];
    "_contacts": TApplication<Application$_clients$_contacts$Data, Application$_clients$_contacts$Params, Application$_clients$_contacts$Processes>[];
    "_legalName": TString;
    "_ogrn": TString;
    "_legalAddress": TString;
    "_correspondenceAddress": TString;
    "_bank": TString;
    "_bik": TString;
    "_operatingAccount": TString;
    "_correspondentAccount": TString;
    "_superiorName": TFullName;
    "_industries": TApplication<Application$_clients$_industries$Data, Application$_clients$_industries$Params, Application$_clients$_industries$Processes>[];
    "_segment": TApplication<Application$_clients$_segments$Data, Application$_clients$_segments$Params, Application$_clients$_segments$Processes>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_clients$_companies$Processes extends Processes {
}

interface Application$_clients$_companies extends Application<
        Application$_clients$_companies$Data,
        Application$_clients$_companies$Params,
        Application$_clients$_companies$Processes
    > {
}
type Application$_clients$_companies$Params = any;

interface Processes$_clients extends Processes {
    /**
     * Квалификация лида
     */
    "_qualification": Process$_clients$_qualification<ProcessContext$_clients$_qualification>;
}
interface Namespace$_clients extends NamespaceBase<Readonly<{
    "_sales_teams": Application$_clients$_sales_teams;
    "_lead_sources": Application$_clients$_lead_sources;
    "_contacts": Application$_clients$_contacts;
    "_industries": Application$_clients$_industries;
    "_products": Application$_clients$_products;
    "_marketing_efforts": Application$_clients$_marketing_efforts;
    "postuplenie": Application$_clients$postuplenie;
    "_opportunities": Application$_clients$_opportunities;
    "_leads": Application$_clients$_leads;
    "_segments": Application$_clients$_segments;
    "_companies": Application$_clients$_companies;
}>> {
    readonly processes: Processes$_clients;
}

type Enum$_lines$_sessions$_state = 'wait_operator'|'assigned_to_operator'|'assigned_to_bot'|'closed'|'in_spam';

type Enum$_lines$_sessions$_priority = 'low'|'medium'|'high';

interface Application$_lines$_sessions$Data extends ItemData {
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "_line": TApplication<Application$_lines$_lines$Data, Application$_lines$_lines$Params, Application$_lines$_lines$Processes>;
    "_channel": TApplication<Application$_lines$_channels$Data, Application$_lines$_channels$Params, Application$_lines$_channels$Processes>;
    "_clients": TApplication<Application$_lines$_clients$Data, Application$_lines$_clients$Params, Application$_lines$_clients$Processes>[];
    "_state": TEnum<Enum$_lines$_sessions$_state>;
    "_externalChatName": TString;
    "_closedAt": TDatetime;
    "_acceptedAt": TDatetime;
    "_lastActivityAt": TDatetime;
    "_operatorReadAt": TDatetime;
    "_userId": TUser;
    "_userGroupId": TRole;
    "_apps": TRefItem[];
    "_priority": TEnum<Enum$_lines$_sessions$_priority>;
}

interface Application$_lines$_sessions$Processes extends Processes {
}

interface Application$_lines$_sessions extends Application<
        Application$_lines$_sessions$Data,
        Application$_lines$_sessions$Params,
        Application$_lines$_sessions$Processes
    > {
}
type Application$_lines$_sessions$Params = any;

interface Application$_lines$_channels$Data extends ItemData {
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "_login": TString;
    "_line": TApplication<Application$_lines$_lines$Data, Application$_lines$_lines$Params, Application$_lines$_lines$Processes>;
    "_type": TString;
    "_state": TFloat;
    "_messagesStartedAt": TDatetime;
    "_lastCrashTime": TDatetime;
}

interface Application$_lines$_channels$Processes extends Processes {
}

interface Application$_lines$_channels extends Application<
        Application$_lines$_channels$Data,
        Application$_lines$_channels$Params,
        Application$_lines$_channels$Processes
    > {
}
type Application$_lines$_channels$Params = any;

interface Application$_lines$_lines$Data extends ItemData {
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "_supervisors": TRole[];
    "_readers": TRole[];
    "_members": TRole[];
    "_operators": TRole[];
}

interface Application$_lines$_lines$Processes extends Processes {
}

interface Application$_lines$_lines extends Application<
        Application$_lines$_lines$Data,
        Application$_lines$_lines$Params,
        Application$_lines$_lines$Processes
    > {
}
type Application$_lines$_lines$Params = any;

interface Application$_lines$_clients$Data extends ItemData {
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "_channel": TApplication<Application$_lines$_channels$Data, Application$_lines$_channels$Params, Application$_lines$_channels$Processes>;
    "_externalId": TString;
    "_username": TString;
    "_phoneNumber": TString;
    "_avatar": TFile;
    "_applicationItem": TRefItem;
    "_user": TUser;
}

interface Application$_lines$_clients$Processes extends Processes {
}

interface Application$_lines$_clients extends Application<
        Application$_lines$_clients$Data,
        Application$_lines$_clients$Params,
        Application$_lines$_clients$Processes
    > {
}
type Application$_lines$_clients$Params = any;

interface Application$_lines$_templates$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "_template": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_lines$_templates$Processes extends Processes {
}

interface Application$_lines$_templates extends Application<
        Application$_lines$_templates$Data,
        Application$_lines$_templates$Params,
        Application$_lines$_templates$Processes
    > {
}
type Application$_lines$_templates$Params = any;

interface Application$_lines$_articles$Data extends ItemData {
    "__name": TString;
    "_template": TString;
    "_url": TLink;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_lines$_articles$Processes extends Processes {
}

interface Application$_lines$_articles extends Application<
        Application$_lines$_articles$Data,
        Application$_lines$_articles$Params,
        Application$_lines$_articles$Processes
    > {
}
type Application$_lines$_articles$Params = any;

interface Namespace$_lines extends NamespaceBase<Readonly<{
    "_sessions": Application$_lines$_sessions;
    "_channels": Application$_lines$_channels;
    "_lines": Application$_lines$_lines;
    "_clients": Application$_lines$_clients;
    "_templates": Application$_lines$_templates;
    "_articles": Application$_lines$_articles;
}>> {
}

interface Application$_marketing$_templates$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_marketing$_templates$Processes extends Processes {
}

interface Application$_marketing$_templates extends Application<
        Application$_marketing$_templates$Data,
        Application$_marketing$_templates$Params,
        Application$_marketing$_templates$Processes
    > {
}
type Application$_marketing$_templates$Params = any;

interface Application$_marketing$_preferences$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "_lead_sources": TApplication<Application$_clients$_lead_sources$Data, Application$_clients$_lead_sources$Params, Application$_clients$_lead_sources$Processes>[];
    "_products": TApplication<Application$_clients$_products$Data, Application$_clients$_products$Params, Application$_clients$_products$Processes>[];
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_marketing$_preferences$Processes extends Processes {
}

interface Application$_marketing$_preferences extends Application<
        Application$_marketing$_preferences$Data,
        Application$_marketing$_preferences$Params,
        Application$_marketing$_preferences$Processes
    > {
}
type Application$_marketing$_preferences$Params = any;

interface Application$_marketing$_mailing_lists$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "_parent": TApplication<Application$_marketing$_mailing_lists$Data, Application$_marketing$_mailing_lists$Params, Application$_marketing$_mailing_lists$Processes>;
}

interface Application$_marketing$_mailing_lists$Processes extends Processes {
}

interface Application$_marketing$_mailing_lists extends Application<
        Application$_marketing$_mailing_lists$Data,
        Application$_marketing$_mailing_lists$Params,
        Application$_marketing$_mailing_lists$Processes
    > {
}
type Application$_marketing$_mailing_lists$Params = any;

interface Application$_marketing$_campaigns$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "_subject": TString;
}

interface Application$_marketing$_campaigns$Processes extends Processes {
}

interface Application$_marketing$_campaigns extends Application<
        Application$_marketing$_campaigns$Data,
        Application$_marketing$_campaigns$Params,
        Application$_marketing$_campaigns$Processes
    > {
}
type Application$_marketing$_campaigns$Params = any;

interface Namespace$_marketing extends NamespaceBase<Readonly<{
    "_templates": Application$_marketing$_templates;
    "_preferences": Application$_marketing$_preferences;
    "_mailing_lists": Application$_marketing$_mailing_lists;
    "_campaigns": Application$_marketing$_campaigns;
}>> {
}

interface Namespace$_office extends NamespaceBase<Readonly<{
}>> {
}

interface Namespace$_postman extends NamespaceBase<Readonly<{
}>> {
}

interface Application$_project_management$_project_template$Data extends ItemData {
    "__name": TString;
    "_project_plan_template": TApplication<Application$_project_management$_project_plan$Data, Application$_project_management$_project_plan$Params, Application$_project_management$_project_plan$Processes>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_project_management$_project_template$Processes extends Processes {
}

interface Application$_project_management$_project_template extends Application<
        Application$_project_management$_project_template$Data,
        Application$_project_management$_project_template$Params,
        Application$_project_management$_project_template$Processes
    > {
}
type Application$_project_management$_project_template$Params = any;


interface StatusGroups$_project_management$_project {
    readonly "__default": StatusItem$_project_management$_project$__default;
}

type StatusItem$_project_management$_project$__default = 'draft' | 'in_progress' | 'completed';

interface Application$_project_management$_project$Data extends ProjectItemData {
    "__name": TString;
    "_start_date": TDate;
    "_end_date": TDate;
    "_description": TString;
    "_project_manager": TUser;
    "_supervisor": TUser;
    "_current_plan": TApplication<Application$_project_management$_project_plan$Data, Application$_project_management$_project_plan$Params, Application$_project_management$_project_plan$Processes>;
    "_archived_plans": TApplication<Application$_project_management$_project_plan$Data, Application$_project_management$_project_plan$Params, Application$_project_management$_project_plan$Processes>[];
    "_drafts": TApplication<Application$_project_management$_project_plan$Data, Application$_project_management$_project_plan$Params, Application$_project_management$_project_plan$Processes>[];
    "_planeditors": TUser[];
    "_participants": TUser[];
    "_is_template": TBoolean;
    "_template_project": TApplication<Application$_project_management$_project$Data, Application$_project_management$_project$Params, Application$_project_management$_project$Processes>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$_project_management$_project$__default, StatusGroups$_project_management$_project>;
    "_current_stage": TApplication<Application$_project_management$_project_stage$Data, Application$_project_management$_project_stage$Params, Application$_project_management$_project_stage$Processes>;
    "_use_work_calendar": TBoolean;
}

interface Application$_project_management$_project$Processes extends Processes {
    /**
     * Генерация по шаблону
     */
    "generate_by_template": Process$_project_management$_project$generate_by_template<ProcessContext$_project_management$_project$generate_by_template>;
}

interface Application$_project_management$_project extends Application<
        Application$_project_management$_project$Data,
        Application$_project_management$_project$Params,
        Application$_project_management$_project$Processes
    >,
	ApplicationProject<
		Application$_project_management$_project$Data,
		Application$_project_management$_project$Params
	> {
}
type Application$_project_management$_project$Params = any;


interface StatusGroups$_project_management$_project_plan {
    readonly "__default": StatusItem$_project_management$_project_plan$__default;
}

type StatusItem$_project_management$_project_plan$__default = '_draft' | '_current' | '_archived' | '_approval' | '_approved';

interface Application$_project_management$_project_plan$Data extends ItemData {
    "_version": TFloat;
    "_project": TApplication<Application$_project_management$_project$Data, Application$_project_management$_project$Params, Application$_project_management$_project$Processes>;
    "_autosheduling": TBoolean;
    "_backward_autosheduling": TBoolean;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$_project_management$_project_plan$__default, StatusGroups$_project_management$_project_plan>;
}

interface Application$_project_management$_project_plan$Processes extends Processes {
    /**
     * Согласование плана проекта
     */
    "_approval_of_project_plan": Process$_project_management$_project_plan$_approval_of_project_plan<ProcessContext$_project_management$_project_plan$_approval_of_project_plan>;
}

interface Application$_project_management$_project_plan extends Application<
        Application$_project_management$_project_plan$Data,
        Application$_project_management$_project_plan$Params,
        Application$_project_management$_project_plan$Processes
    > {
}
type Application$_project_management$_project_plan$Params = any;

interface Application$_project_management$_project_stage$Data extends ItemData {
    "__name": TString;
    "_type": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_project_management$_project_stage$Processes extends Processes {
}

interface Application$_project_management$_project_stage extends Application<
        Application$_project_management$_project_stage$Data,
        Application$_project_management$_project_stage$Params,
        Application$_project_management$_project_stage$Processes
    > {
}
type Application$_project_management$_project_stage$Params = any;


interface StatusGroups$_project_management$_project_task {
    readonly "__default": StatusItem$_project_management$_project_task$__default;
}

type StatusItem$_project_management$_project_task$__default = '_draft' | '_in_progress' | '_completed' | '_canceled' | '_archived';

interface Application$_project_management$_project_task$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "_start_date": TDate;
    "_end_date": TDate;
    "_responsible": TUser;
    "_project": TApplication<Application$_project_management$_project$Data, Application$_project_management$_project$Params, Application$_project_management$_project$Processes>;
    "_progress": TFloat;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$_project_management$_project_task$__default, StatusGroups$_project_management$_project_task>;
    "_type": TString;
}

interface Application$_project_management$_project_task$Processes extends Processes {
}

interface Application$_project_management$_project_task extends Application<
        Application$_project_management$_project_task$Data,
        Application$_project_management$_project_task$Params,
        Application$_project_management$_project_task$Processes
    > {
}
type Application$_project_management$_project_task$Params = any;

type Enum$_project_management$_project_plan_element$_element_type = 'task'|'milestone'|'process'|'project';

interface Application$_project_management$_project_plan_element$Data extends ItemData {
    "__name": TString;
    "_element_type": TEnum<Enum$_project_management$_project_plan_element$_element_type>;
    "_description": TString;
    "_start_date": TDate;
    "_end_date": TDate;
    "_duration": TFloat;
    "_responsible": TUser;
    "_project_plan": TApplication<Application$_project_management$_project_plan$Data, Application$_project_management$_project_plan$Params, Application$_project_management$_project_plan$Processes>;
    "_project_task": TApplication<Application$_project_management$_project_task$Data, Application$_project_management$_project_task$Params, Application$_project_management$_project_task$Processes>;
    "_additional_info": TString;
    "_parent": TString;
    "_type": TString;
    "_progress": TFloat;
    "_ganttElementId": TString;
    "_gantt_order": TFloat;
    "_binded_process": TJSON;
    "_constraint_type": TString;
    "_constraint_date": TDatetime;
    "_unscheduled": TBoolean;
    "_text": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_project_management$_project_plan_element$Processes extends Processes {
}

interface Application$_project_management$_project_plan_element extends Application<
        Application$_project_management$_project_plan_element$Data,
        Application$_project_management$_project_plan_element$Params,
        Application$_project_management$_project_plan_element$Processes
    > {
}
type Application$_project_management$_project_plan_element$Params = any;

interface Namespace$_project_management extends NamespaceBase<Readonly<{
    "_project_template": Application$_project_management$_project_template;
    "_project": Application$_project_management$_project;
    "_project_plan": Application$_project_management$_project_plan;
    "_project_stage": Application$_project_management$_project_stage;
    "_project_task": Application$_project_management$_project_task;
    "_project_plan_element": Application$_project_management$_project_plan_element;
}>> {
}

interface Application$_system_catalogs$_my_companies$Data extends ItemData {
    "__name": TString;
    "_full_legal_name": TString;
    "_legal_address": TString;
    "_actual_address": TString;
    "_inn": TString;
    "_kpp": TString;
    "_transactional_account": TString;
    "_correspondent_account": TString;
    "_bank": TString;
    "_bik": TString;
    "_phone": TPhone<PhoneType.Main>;
    "_email": TEmail<EmailType>[];
    "_ogrn": TString;
    "_director": TUser;
    "_company_card": TFile;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_system_catalogs$_my_companies$Processes extends Processes {
}

interface Application$_system_catalogs$_my_companies extends Application<
        Application$_system_catalogs$_my_companies$Data,
        Application$_system_catalogs$_my_companies$Params,
        Application$_system_catalogs$_my_companies$Processes
    > {
}
type Application$_system_catalogs$_my_companies$Params = any;

type Enum$_system_catalogs$_user_profiles$__user_status = 'not_registered'|'active'|'blocked';

interface Application$_system_catalogs$_user_profiles$Data extends UserProfileItemData {
    "__name": TString;
    "email": TString;
    "fullname": TFullName;
    "phone": TPhone<PhoneType>[];
    "avatar": TImage;
    "__user_status": TEnum<Enum$_system_catalogs$_user_profiles$__user_status>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_system_catalogs$_user_profiles$Processes extends Processes {
    /**
     * Заблокировать внешнего (портального) пользователя
     */
    "_block_user_profile": Process$_system_catalogs$_user_profiles$_block_user_profile<ProcessContext$_system_catalogs$_user_profiles$_block_user_profile>;
    /**
     * Разблокировать внешнего (портального) пользователя
     */
    "_unblock_user_profile": Process$_system_catalogs$_user_profiles$_unblock_user_profile<ProcessContext$_system_catalogs$_user_profiles$_unblock_user_profile>;
}

interface Application$_system_catalogs$_user_profiles extends Application<
        Application$_system_catalogs$_user_profiles$Data,
        Application$_system_catalogs$_user_profiles$Params,
        Application$_system_catalogs$_user_profiles$Processes
    >,
    ApplicationUserProfile<
	    Application$_system_catalogs$_user_profiles$Data,
        Application$_system_catalogs$_user_profiles$Params
	> {
}
type Application$_system_catalogs$_user_profiles$Params = any;

interface Namespace$_system_catalogs extends NamespaceBase<Readonly<{
    "_my_companies": Application$_system_catalogs$_my_companies;
    "_user_profiles": Application$_system_catalogs$_user_profiles;
}>> {
}


interface StatusGroups$_transactions$_outgoing_invoices {
    readonly "__default": StatusItem$_transactions$_outgoing_invoices$__default;
}

type StatusItem$_transactions$_outgoing_invoices$__default = 'new' | 'awaiting_payment' | 'paid';

type Enum$_transactions$_outgoing_invoices$_contractPaymentTerm = 'three_days'|'five_days'|'seven_days'|'thirty_days'|'forty_five_days'|'sixty_days'|'ninety_days';

interface Application$_transactions$_outgoing_invoices$Data extends ItemData {
    "__file": TFile;
    "_contractor": TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "_contractorLegalName": TString;
    readonly "__status": TStatus<StatusItem$_transactions$_outgoing_invoices$__default, StatusGroups$_transactions$_outgoing_invoices>;
    "_plannedIncome": TApplication<Application$_transactions$_income$Data, Application$_transactions$_income$Params, Application$_transactions$_income$Processes>;
    "_ourCompany": TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "_responsible": TUser;
    "_basisPayment": TString;
    "_amount": TFloat;
    "_date": TDate;
    "_currencyType": TApplication<Application$_transactions$_currencies$Data, Application$_transactions$_currencies$Params, Application$_transactions$_currencies$Processes>;
    "_actualIncome": TApplication<Application$_transactions$_income$Data, Application$_transactions$_income$Params, Application$_transactions$_income$Processes>;
    "_needAttachFile": TBoolean;
    "_basis": TApplication<Application$_transactions$_app$Data, Application$_transactions$_app$Params, Application$_transactions$_app$Processes>;
    "_createInPlan": TBoolean;
    "_contractPaymentTerm": TEnum<Enum$_transactions$_outgoing_invoices$_contractPaymentTerm>;
    "_scheduledInvoicePaymentDate": TDate;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_transactions$_outgoing_invoices$Processes extends Processes {
    /**
     * Добавление файла
     */
    "_addFile": Process$_transactions$_outgoing_invoices$_addFile<ProcessContext$_transactions$_outgoing_invoices$_addFile>;
    /**
     * Формирование счета
     */
    "_invoiceGeneration": Process$_transactions$_outgoing_invoices$_invoiceGeneration<ProcessContext$_transactions$_outgoing_invoices$_invoiceGeneration>;
}

interface Application$_transactions$_outgoing_invoices extends Application<
        Application$_transactions$_outgoing_invoices$Data,
        Application$_transactions$_outgoing_invoices$Params,
        Application$_transactions$_outgoing_invoices$Processes
    > {
}
type Application$_transactions$_outgoing_invoices$Params = any;

interface Application$_transactions$_frc$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "_manager": TUser;
    "_approver": TUser;
    "_finalApprover": TUser;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_transactions$_frc$Processes extends Processes {
}

interface Application$_transactions$_frc extends Application<
        Application$_transactions$_frc$Data,
        Application$_transactions$_frc$Params,
        Application$_transactions$_frc$Processes
    > {
}
type Application$_transactions$_frc$Params = any;

type Enum$_transactions$_income$_planFact = 'plan'|'fact';



interface Table$_transactions$_income$_incomeDistribution$Row {
     "__count": TFloat;
     "__index": TFloat;
     "_incomeItem": TApplication<Application$_transactions$_income_items$Data, Application$_transactions$_income_items$Params, Application$_transactions$_income_items$Processes>;
     "_frc": TApplication<Application$_transactions$_frc$Data, Application$_transactions$_frc$Params, Application$_transactions$_frc$Processes>;
     "_amount": TFloat;
}

interface Table$_transactions$_income$_incomeDistribution$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "_incomeItem": Readonly<TString>;
    readonly "_frc": Readonly<TString>;
    readonly "_amount": Readonly<TFloat>;
}


type Enum$_transactions$_income$_probability = '0'|'10'|'20'|'30'|'40'|'50'|'60'|'70'|'80'|'90'|'100';


interface StatusGroups$_transactions$_income {
    readonly "__default": StatusItem$_transactions$_income$__default;
}

type StatusItem$_transactions$_income$__default = 'pending' | 'partially_paid' | 'paid' | 'cancelled';

interface Application$_transactions$_income$Data extends ItemData {
    "_responsible": TUser;
    "_contractor": TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "_totalAmount": TFloat;
    "_plannedPaymentDate": TDate;
    "_actualPaymentDate": TDate;
    "_planFact": TEnum<Enum$_transactions$_income$_planFact>;
    "_actualReceipts": TFloat;
    "_factIncome": TApplication<Application$_transactions$_income$Data, Application$_transactions$_income$Params, Application$_transactions$_income$Processes>[];
    "_incomeDistribution": TTable<Table$_transactions$_income$_incomeDistribution$Row, Table$_transactions$_income$_incomeDistribution$Result>;
    "_outgoingInvoices": TApplication<Application$_transactions$_outgoing_invoices$Data, Application$_transactions$_outgoing_invoices$Params, Application$_transactions$_outgoing_invoices$Processes>[];
    "_currencyType": TApplication<Application$_transactions$_currencies$Data, Application$_transactions$_currencies$Params, Application$_transactions$_currencies$Processes>;
    "_distributedInvoice": TApplication<Application$_transactions$_outgoing_invoices$Data, Application$_transactions$_outgoing_invoices$Params, Application$_transactions$_outgoing_invoices$Processes>;
    "_incomeItemsUsed": TApplication<Application$_transactions$_income_items$Data, Application$_transactions$_income_items$Params, Application$_transactions$_income_items$Processes>[];
    "_frcUsed": TApplication<Application$_transactions$_frc$Data, Application$_transactions$_frc$Params, Application$_transactions$_frc$Processes>[];
    "_basis": TApplication<Application$_transactions$_app$Data, Application$_transactions$_app$Params, Application$_transactions$_app$Processes>;
    "_plan": TApplication<Application$_transactions$_income$Data, Application$_transactions$_income$Params, Application$_transactions$_income$Processes>;
    "_probability": TEnum<Enum$_transactions$_income$_probability>;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__createdBy": TUser;
    readonly "__status": TStatus<StatusItem$_transactions$_income$__default, StatusGroups$_transactions$_income>;
    "__deletedAt": TDatetime;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
}

interface Application$_transactions$_income$Processes extends Processes {
    /**
     * Планирование и получение поступлений
     */
    "_income_planning_and_receipt": Process$_transactions$_income$_income_planning_and_receipt<ProcessContext$_transactions$_income$_income_planning_and_receipt>;
}

interface Application$_transactions$_income extends Application<
        Application$_transactions$_income$Data,
        Application$_transactions$_income$Params,
        Application$_transactions$_income$Processes
    > {
}
type Application$_transactions$_income$Params = any;

interface Application$_transactions$_currencies$Data extends ItemData {
    "__name": TString;
    "_currencyCode": TString;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "_rate": TFloat;
    "__updatedAt": TDatetime;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
}

interface Application$_transactions$_currencies$Processes extends Processes {
}

interface Application$_transactions$_currencies extends Application<
        Application$_transactions$_currencies$Data,
        Application$_transactions$_currencies$Params,
        Application$_transactions$_currencies$Processes
    > {
}
type Application$_transactions$_currencies$Params = any;

interface Application$_transactions$_income_items$Data extends ItemData {
    "__name": TString;
    "_description": TString;
    "_responsible": TUser;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$_transactions$_income_items$Processes extends Processes {
}

interface Application$_transactions$_income_items extends Application<
        Application$_transactions$_income_items$Data,
        Application$_transactions$_income_items$Params,
        Application$_transactions$_income_items$Processes
    > {
}
type Application$_transactions$_income_items$Params = any;

type Enum$_transactions$_sales_goals$_type = 'personal'|'group'|'common';

type Enum$_transactions$_sales_goals$_period = 'year'|'quarter'|'month';

type Enum$_transactions$_sales_goals$_year = never;

type Enum$_transactions$_sales_goals$_month = 'january'|'february'|'march'|'april'|'may'|'june'|'july'|'august'|'september'|'october'|'november'|'december';

type Enum$_transactions$_sales_goals$_quarter = never;

interface Application$_transactions$_sales_goals$Data extends ItemData {
    "__name": TString;
    "_type": TEnum<Enum$_transactions$_sales_goals$_type>;
    "_responsible": TUser;
    "_periodBeginning": TDate;
    "_periodEnd": TDate;
    "_amount": TFloat;
    "_currencyType": TApplication<Application$_transactions$_currencies$Data, Application$_transactions$_currencies$Params, Application$_transactions$_currencies$Processes>;
    "_commonGoal": TApplication<Application$_transactions$_sales_goals$Data, Application$_transactions$_sales_goals$Params, Application$_transactions$_sales_goals$Processes>;
    "_teamGoal": TApplication<Application$_transactions$_sales_goals$Data, Application$_transactions$_sales_goals$Params, Application$_transactions$_sales_goals$Processes>;
    "_salesTeam": TApplication<Application$_clients$_sales_teams$Data, Application$_clients$_sales_teams$Params, Application$_clients$_sales_teams$Processes>;
    "_period": TEnum<Enum$_transactions$_sales_goals$_period>;
    "_year": TEnum<Enum$_transactions$_sales_goals$_year>;
    "_month": TEnum<Enum$_transactions$_sales_goals$_month>;
    "_quarter": TEnum<Enum$_transactions$_sales_goals$_quarter>;
    "__deletedAt": TDatetime;
    "__updatedBy": TUser;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
}

interface Application$_transactions$_sales_goals$Processes extends Processes {
}

interface Application$_transactions$_sales_goals extends Application<
        Application$_transactions$_sales_goals$Data,
        Application$_transactions$_sales_goals$Params,
        Application$_transactions$_sales_goals$Processes
    > {
}
type Application$_transactions$_sales_goals$Params = any;

interface Application$_transactions$_app$Data extends ItemData {
    "__id": TString;
    "__sourceRef": TRefItem;
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "__name": TString;
    "_responsible": TUser;
    "_contractor": TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
}

interface Application$_transactions$_app$Processes extends Processes {
}

interface Application$_transactions$_app extends Application<
        Application$_transactions$_app$Data,
        Application$_transactions$_app$Params,
        Application$_transactions$_app$Processes
    > {
}
type Application$_transactions$_app$Params = any;

interface Namespace$_transactions extends NamespaceBase<Readonly<{
    "_outgoing_invoices": Application$_transactions$_outgoing_invoices;
    "_frc": Application$_transactions$_frc;
    "_income": Application$_transactions$_income;
    "_currencies": Application$_transactions$_currencies;
    "_income_items": Application$_transactions$_income_items;
    "_sales_goals": Application$_transactions$_sales_goals;
    "_app": Application$_transactions$_app;
}>> {
}


interface StatusGroups$absences$vacation_orders {
    readonly "__default": StatusItem$absences$vacation_orders$__default;
}

type StatusItem$absences$vacation_orders$__default = 'new' | 'signing' | 'signed' | 'rejected';

interface Application$absences$vacation_orders$Data extends ItemData {
    "__file": TFile;
    "order_number": TString;
    "staff": TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "app_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$absences$vacation_orders$__default, StatusGroups$absences$vacation_orders>;
}

interface Application$absences$vacation_orders$Processes extends Processes {
    /**
     * Создание приказа
     */
    "creation_and_signing_order": Process$absences$vacation_orders$creation_and_signing_order<ProcessContext$absences$vacation_orders$creation_and_signing_order>;
    /**
     * Подписание приказа
     */
    "sign_order": Process$absences$vacation_orders$sign_order<ProcessContext$absences$vacation_orders$sign_order>;
}

interface Application$absences$vacation_orders extends Application<
        Application$absences$vacation_orders$Data,
        Application$absences$vacation_orders$Params,
        Application$absences$vacation_orders$Processes
    > {
}
type Application$absences$vacation_orders$Params = any;


interface StatusGroups$absences$vacation_docs {
    readonly "__default": StatusItem$absences$vacation_docs$__default;
}

type StatusItem$absences$vacation_docs$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'rejected' | 'correction';

interface Application$absences$vacation_docs$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "vacation": TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "app_name": TString;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$absences$vacation_docs$__default, StatusGroups$absences$vacation_docs>;
}

interface Application$absences$vacation_docs$Processes extends Processes {
    /**
     * Подписание заявления
     */
    "sign_document": Process$absences$vacation_docs$sign_document<ProcessContext$absences$vacation_docs$sign_document>;
    /**
     * Создание заявления
     */
    "create_and_sign_an_application": Process$absences$vacation_docs$create_and_sign_an_application<ProcessContext$absences$vacation_docs$create_and_sign_an_application>;
}

interface Application$absences$vacation_docs extends Application<
        Application$absences$vacation_docs$Data,
        Application$absences$vacation_docs$Params,
        Application$absences$vacation_docs$Processes
    > {
}
type Application$absences$vacation_docs$Params = any;

type Enum$absences$vacations$type_vacation = 'unpaid'|'sick_leave'|'basic'|'additional'|'pregnancy'|'child_care'|'study'|'scheduled';

type Enum$absences$vacations$type_of_additional_leave = 'educational'|'decretive'|'baby_care';



interface Table$absences$vacations$schedule_table$Row {
     "__count": TFloat;
     "__index": TFloat;
     "vacation": TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
     "start": TDate;
     "end": TDate;
     "chief_comment": TString;
}

interface Table$absences$vacations$schedule_table$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "vacation": Readonly<TString>;
    readonly "start": Readonly<TString>;
    readonly "end": Readonly<TString>;
    readonly "chief_comment": Readonly<TString>;
}



interface StatusGroups$absences$vacations {
    readonly "__default": StatusItem$absences$vacations$__default;
}

type StatusItem$absences$vacations$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'correction' | 'cancelled';

interface Application$absences$vacations$Data extends ItemData {
    "start": TDatetime;
    "end": TDatetime;
    "start_string": TString;
    "end_string": TString;
    "duration": TFloat;
    "days_amount": TFloat;
    "chief": TUser;
    "staff_user": TUser;
    "chief_comment": TString;
    "staff": TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "type_vacation": TEnum<Enum$absences$vacations$type_vacation>;
    "vacation_doc": TFile;
    "vacation_order": TFile;
    "sick_leave_payment": TFloat;
    "sick_leave_number": TString;
    "type_of_additional_leave": TEnum<Enum$absences$vacations$type_of_additional_leave>;
    "application": TString;
    "place_of_study": TString;
    "orders": TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>[];
    "statements": TApplication<Application$absences$vacation_docs$Data, Application$absences$vacation_docs$Params, Application$absences$vacation_docs$Processes>[];
    "replacement_needed": TBoolean;
    "base": TFile;
    "reason_for_unpaid": TString;
    "early_pregnancy": TBoolean;
    "vacation_pay": TFloat;
    "staff_comment": TString;
    "schedule_table": TTable<Table$absences$vacations$schedule_table$Row, Table$absences$vacations$schedule_table$Result>;
    "payment": TMoney<'RUB'>;
    "line_status": TString;
    "child_name": TString;
    "birth_certificate": TFile;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$absences$vacations$__default, StatusGroups$absences$vacations>;
}

interface Application$absences$vacations$Processes extends Processes {
    /**
     * Создание отпуска
     */
    "creation_and_approval_vacation": Process$absences$vacations$creation_and_approval_vacation<ProcessContext$absences$vacations$creation_and_approval_vacation>;
    /**
     * Создание замещения
     */
    "create_a_replacement": Process$absences$vacations$create_a_replacement<ProcessContext$absences$vacations$create_a_replacement>;
    /**
     * Перенос отпуска
     */
    "reschedule_vacation": Process$absences$vacations$reschedule_vacation<ProcessContext$absences$vacations$reschedule_vacation>;
    /**
     * Расчет и выплата отпускных
     */
    "vacation_pay": Process$absences$vacations$vacation_pay<ProcessContext$absences$vacations$vacation_pay>;
    /**
     * Создание больничного
     */
    "create_medical_leave": Process$absences$vacations$create_medical_leave<ProcessContext$absences$vacations$create_medical_leave>;
    /**
     * Корректировка отпуска
     */
    "vacation_correction": Process$absences$vacations$vacation_correction<ProcessContext$absences$vacations$vacation_correction>;
    /**
     * Уведомление о предстоящем отпуске
     */
    "notification": Process$absences$vacations$notification<ProcessContext$absences$vacations$notification>;
    /**
     * Отправка отпуска на корректировку
     */
    "send_to_correction": Process$absences$vacations$send_to_correction<ProcessContext$absences$vacations$send_to_correction>;
    /**
     * Отозвать из отпуска
     */
    "recall_from_vacation": Process$absences$vacations$recall_from_vacation<ProcessContext$absences$vacations$recall_from_vacation>;
    /**
     * Поиск отпусков для уведомления
     */
    "vacation_notification": Process$absences$vacations$vacation_notification<ProcessContext$absences$vacations$vacation_notification>;
}

interface Application$absences$vacations extends Application<
        Application$absences$vacations$Data,
        Application$absences$vacations$Params,
        Application$absences$vacations$Processes
    > {
}
type Application$absences$vacations$Params = any;



interface Table$absences$vacation_schedule$table$Row {
     "__count": TFloat;
     "__index": TFloat;
     "structal": TString;
     "position": TString;
     "number1C": TString;
     "duration": TFloat;
     "start": TDate;
     "actual_start": TDate;
     "transfer_base": TString;
     "transfer_start": TDate;
     "employee_full_name": TFullName;
}

interface Table$absences$vacation_schedule$table$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "structal": Readonly<TString>;
    readonly "position": Readonly<TString>;
    readonly "number1C": Readonly<TString>;
    readonly "duration": Readonly<TString>;
    readonly "start": Readonly<TString>;
    readonly "actual_start": Readonly<TString>;
    readonly "transfer_base": Readonly<TString>;
    readonly "transfer_start": Readonly<TString>;
    readonly "employee_full_name": Readonly<TString>;
}



interface StatusGroups$absences$vacation_schedule {
    readonly "__default": StatusItem$absences$vacation_schedule$__default;
}

type StatusItem$absences$vacation_schedule$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'cancelled';

interface Application$absences$vacation_schedule$Data extends ItemData {
    "__file": TFile;
    "vacations": TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "year": TFloat;
    "company": TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "table": TTable<Table$absences$vacation_schedule$table$Row, Table$absences$vacation_schedule$table$Result>;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$absences$vacation_schedule$__default, StatusGroups$absences$vacation_schedule>;
}

interface Application$absences$vacation_schedule$Processes extends Processes {
    /**
     * Изменение графика отпусков
     */
    "create_a_vacation_schedule_copy": Process$absences$vacation_schedule$create_a_vacation_schedule_copy<ProcessContext$absences$vacation_schedule$create_a_vacation_schedule_copy>;
    /**
     * Запланировать отпуск по графику
     */
    "create_planned_vacation_copy": Process$absences$vacation_schedule$create_planned_vacation_copy<ProcessContext$absences$vacation_schedule$create_planned_vacation_copy>;
    /**
     * Ежегодное планирование отпусков
     */
    "annual_vacation_planning_copy": Process$absences$vacation_schedule$annual_vacation_planning_copy<ProcessContext$absences$vacation_schedule$annual_vacation_planning_copy>;
    /**
     * Согласовать график отпусков
     */
    "approve_vacation_schedule_copy": Process$absences$vacation_schedule$approve_vacation_schedule_copy<ProcessContext$absences$vacation_schedule$approve_vacation_schedule_copy>;
    /**
     * Запуск ежегодного планирования
     */
    "launch_of_annual_planning_copy": Process$absences$vacation_schedule$launch_of_annual_planning_copy<ProcessContext$absences$vacation_schedule$launch_of_annual_planning_copy>;
}

interface Application$absences$vacation_schedule extends Application<
        Application$absences$vacation_schedule$Data,
        Application$absences$vacation_schedule$Params,
        Application$absences$vacation_schedule$Processes
    > {
}
type Application$absences$vacation_schedule$Params = any;

interface Application$absences$staff$Data extends ItemData {
    "__id": TString;
    "__sourceRef": TRefItem;
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "__name": TString;
    "ext_user": TUser;
    "entity": TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "is_a_unep_issue_required": TBoolean;
    "employed": TBoolean;
}

interface Application$absences$staff$Processes extends Processes {
}

interface Application$absences$staff extends Application<
        Application$absences$staff$Data,
        Application$absences$staff$Params,
        Application$absences$staff$Processes
    > {
}
type Application$absences$staff$Params = any;

interface Processes$absences extends Processes {
    /**
     * Оповещение
     */
    "notification": Process$absences$notification<ProcessContext$absences$notification>;
}
interface Namespace$absences extends NamespaceBase<Readonly<{
    "vacation_orders": Application$absences$vacation_orders;
    "vacation_docs": Application$absences$vacation_docs;
    "vacations": Application$absences$vacations;
    "vacation_schedule": Application$absences$vacation_schedule;
    "staff": Application$absences$staff;
}>> {
    readonly processes: Processes$absences;
}

interface Namespace$admin extends NamespaceBase<Readonly<{
}>> {
}

interface Application$business_trips$goroda$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$business_trips$goroda$Processes extends Processes {
}

interface Application$business_trips$goroda extends Application<
        Application$business_trips$goroda$Data,
        Application$business_trips$goroda$Params,
        Application$business_trips$goroda$Processes
    > {
}
type Application$business_trips$goroda$Params = any;


interface StatusGroups$business_trips$avansovyi_otchet {
    readonly "__default": StatusItem$business_trips$avansovyi_otchet$__default;
}

type StatusItem$business_trips$avansovyi_otchet$__default = 'new' | 'signing' | 'signed' | 'rejected';

interface Application$business_trips$avansovyi_otchet$Data extends ItemData {
    "__file": TFile;
    "businesstrip_requests": TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "staff": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$business_trips$avansovyi_otchet$__default, StatusGroups$business_trips$avansovyi_otchet>;
}

interface Application$business_trips$avansovyi_otchet$Processes extends Processes {
}

interface Application$business_trips$avansovyi_otchet extends Application<
        Application$business_trips$avansovyi_otchet$Data,
        Application$business_trips$avansovyi_otchet$Params,
        Application$business_trips$avansovyi_otchet$Processes
    > {
}
type Application$business_trips$avansovyi_otchet$Params = any;


interface StatusGroups$business_trips$order_for_a_business_trip {
    readonly "__default": StatusItem$business_trips$order_for_a_business_trip$__default;
}

type StatusItem$business_trips$order_for_a_business_trip$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'rejected';

interface Application$business_trips$order_for_a_business_trip$Data extends ItemData {
    "__file": TFile;
    "responsible_user": TUser;
    "responsible": TString;
    "line_status": TString;
    "line_file_name": TString;
    "staff": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "head_user": TUser;
    "business_trip": TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "number": TFloat;
    "order_number": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$business_trips$order_for_a_business_trip$__default, StatusGroups$business_trips$order_for_a_business_trip>;
}

interface Application$business_trips$order_for_a_business_trip$Processes extends Processes {
    /**
     * Создание приказа
     */
    "signing_the_order": Process$business_trips$order_for_a_business_trip$signing_the_order<ProcessContext$business_trips$order_for_a_business_trip$signing_the_order>;
    /**
     * Подписание приказа
     */
    "order_signing": Process$business_trips$order_for_a_business_trip$order_signing<ProcessContext$business_trips$order_for_a_business_trip$order_signing>;
}

interface Application$business_trips$order_for_a_business_trip extends Application<
        Application$business_trips$order_for_a_business_trip$Data,
        Application$business_trips$order_for_a_business_trip$Params,
        Application$business_trips$order_for_a_business_trip$Processes
    > {
}
type Application$business_trips$order_for_a_business_trip$Params = any;


interface StatusGroups$business_trips$trip_requests {
    readonly "__default": StatusItem$business_trips$trip_requests$__default;
}

type StatusItem$business_trips$trip_requests$__default = 'new' | 'signing' | 'signed' | 'rejected';

interface Application$business_trips$trip_requests$Data extends ItemData {
    "__file": TFile;
    "line_status": TString;
    "staff": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "head_user": TUser;
    "responsible_user": TUser;
    "responsible": TString;
    "line_file_name": TString;
    "businesstrip_requests": TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$business_trips$trip_requests$__default, StatusGroups$business_trips$trip_requests>;
}

interface Application$business_trips$trip_requests$Processes extends Processes {
    /**
     * Генерация и подписание служебной записки
     */
    "signing_the_application": Process$business_trips$trip_requests$signing_the_application<ProcessContext$business_trips$trip_requests$signing_the_application>;
}

interface Application$business_trips$trip_requests extends Application<
        Application$business_trips$trip_requests$Data,
        Application$business_trips$trip_requests$Params,
        Application$business_trips$trip_requests$Processes
    > {
}
type Application$business_trips$trip_requests$Params = any;

interface Application$business_trips$transport_type$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$business_trips$transport_type$Processes extends Processes {
}

interface Application$business_trips$transport_type extends Application<
        Application$business_trips$transport_type$Data,
        Application$business_trips$transport_type$Params,
        Application$business_trips$transport_type$Processes
    > {
}
type Application$business_trips$transport_type$Params = any;



interface Table$business_trips$businesstrip_requests$requested_expenses$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum_money": TMoney<'RUB'>;
     "money_requester": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
     "comment": TString;
     "traveler_s_comment": TString;
}

interface Table$business_trips$businesstrip_requests$requested_expenses$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum_money": Readonly<TString>;
    readonly "money_requester": Readonly<TString>;
    readonly "comment": Readonly<TString>;
    readonly "traveler_s_comment": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$route$Row {
     "__count": TFloat;
     "__index": TFloat;
     "departure_city": TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
     "departure_date": TDatetime;
     "arrival_city": TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
     "tip_transporta": TApplication<Application$business_trips$transport_type$Data, Application$business_trips$transport_type$Params, Application$business_trips$transport_type$Processes>;
     "ticket_files": TFile[];
}

interface Table$business_trips$businesstrip_requests$route$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "departure_city": Readonly<TString>;
    readonly "departure_date": Readonly<TString>;
    readonly "arrival_city": Readonly<TString>;
    readonly "tip_transporta": Readonly<TString>;
    readonly "ticket_files": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$finance_report$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum_money": TMoney<'RUB'>;
     "report_file": TFile[];
     "additional_documents": TFile[];
}

interface Table$business_trips$businesstrip_requests$finance_report$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum_money": Readonly<TString>;
    readonly "report_file": Readonly<TString>;
    readonly "additional_documents": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$hotels$Row {
     "__count": TFloat;
     "__index": TFloat;
     "city": TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
     "start_date_of_stay": TDate;
     "end_date_of_residence": TDate;
     "comment": TString;
     "booking_files": TFile[];
}

interface Table$business_trips$businesstrip_requests$hotels$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "city": Readonly<TString>;
    readonly "start_date_of_stay": Readonly<TString>;
    readonly "end_date_of_residence": Readonly<TString>;
    readonly "comment": Readonly<TString>;
    readonly "booking_files": Readonly<TString>;
}



interface StatusGroups$business_trips$businesstrip_requests {
    readonly "__default": StatusItem$business_trips$businesstrip_requests$__default;
}

type StatusItem$business_trips$businesstrip_requests$__default = 'in-prepare' | 'agrement' | 'signed' | 'asking-money' | 'reciving-money' | 'money-is-recived' | 'in-progress' | 'report' | 'completed' | 'canceled';

interface Application$business_trips$businesstrip_requests$Data extends ItemData {
    "organisation": TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "responsible_user": TUser;
    "posted_employees": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>[];
    "head_user": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "other_approvals": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "mission_trip": TString;
    "tasks_trip": TString;
    "start_date": TDatetime;
    "result_trip": TString;
    "end_date": TDatetime;
    "trip_report": TFile;
    "is_money_request": TBoolean;
    "requested_expenses": TTable<Table$business_trips$businesstrip_requests$requested_expenses$Row, Table$business_trips$businesstrip_requests$requested_expenses$Result>;
    "route": TTable<Table$business_trips$businesstrip_requests$route$Row, Table$business_trips$businesstrip_requests$route$Result>;
    "city": TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
    "money_reciving_date": TDatetime;
    "destination_city": TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
    "finance_report": TTable<Table$business_trips$businesstrip_requests$finance_report$Row, Table$business_trips$businesstrip_requests$finance_report$Result>;
    "responsible": TString;
    "line_status": TString;
    "line_file_name": TString;
    "order": TApplication<Application$business_trips$order_for_a_business_trip$Data, Application$business_trips$order_for_a_business_trip$Params, Application$business_trips$order_for_a_business_trip$Processes>[];
    "statement": TApplication<Application$business_trips$trip_requests$Data, Application$business_trips$trip_requests$Params, Application$business_trips$trip_requests$Processes>;
    "need_a_ticket": TBoolean;
    "hotels": TTable<Table$business_trips$businesstrip_requests$hotels$Row, Table$business_trips$businesstrip_requests$hotels$Result>;
    "need_a_hotel": TBoolean;
    "travel_allowance": TMoney<'RUB'>;
    "duration": TFloat;
    "service_assignments": TApplication<Application$business_trips$service_assignments$Data, Application$business_trips$service_assignments$Params, Application$business_trips$service_assignments$Processes>[];
    "finance_report_app": TApplication<Application$business_trips$avansovyi_otchet$Data, Application$business_trips$avansovyi_otchet$Params, Application$business_trips$avansovyi_otchet$Processes>;
    "users": TUser[];
    "start_line": TString;
    "end_line": TString;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$business_trips$businesstrip_requests$__default, StatusGroups$business_trips$businesstrip_requests>;
}

interface Application$business_trips$businesstrip_requests$Processes extends Processes {
    /**
     * Продление командировки
     */
    "businesstrip_prolongation": Process$business_trips$businesstrip_requests$businesstrip_prolongation<ProcessContext$business_trips$businesstrip_requests$businesstrip_prolongation>;
    /**
     * Получение денежных средств
     */
    "money_processing": Process$business_trips$businesstrip_requests$money_processing<ProcessContext$business_trips$businesstrip_requests$money_processing>;
    /**
     * Оформление командировки
     */
    "business_trip_registration": Process$business_trips$businesstrip_requests$business_trip_registration<ProcessContext$business_trips$businesstrip_requests$business_trip_registration>;
    /**
     * Создание служебного задания
     */
    "create_service_order": Process$business_trips$businesstrip_requests$create_service_order<ProcessContext$business_trips$businesstrip_requests$create_service_order>;
    /**
     * Подписание служебного задания
     */
    "signing_service_order": Process$business_trips$businesstrip_requests$signing_service_order<ProcessContext$business_trips$businesstrip_requests$signing_service_order>;
}

interface Application$business_trips$businesstrip_requests extends Application<
        Application$business_trips$businesstrip_requests$Data,
        Application$business_trips$businesstrip_requests$Params,
        Application$business_trips$businesstrip_requests$Processes
    > {
}
type Application$business_trips$businesstrip_requests$Params = any;


interface StatusGroups$business_trips$service_assignments {
    readonly "__default": StatusItem$business_trips$service_assignments$__default;
}

type StatusItem$business_trips$service_assignments$__default = 'new' | 'signing' | 'signed' | 'rejected';

interface Application$business_trips$service_assignments$Data extends ItemData {
    "__file": TFile;
    "businesstrip_requests": TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "staff": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "number": TString;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$business_trips$service_assignments$__default, StatusGroups$business_trips$service_assignments>;
}

interface Application$business_trips$service_assignments$Processes extends Processes {
}

interface Application$business_trips$service_assignments extends Application<
        Application$business_trips$service_assignments$Data,
        Application$business_trips$service_assignments$Params,
        Application$business_trips$service_assignments$Processes
    > {
}
type Application$business_trips$service_assignments$Params = any;

interface Application$business_trips$types_of_funds$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$business_trips$types_of_funds$Processes extends Processes {
}

interface Application$business_trips$types_of_funds extends Application<
        Application$business_trips$types_of_funds$Data,
        Application$business_trips$types_of_funds$Params,
        Application$business_trips$types_of_funds$Processes
    > {
}
type Application$business_trips$types_of_funds$Params = any;

interface Application$business_trips$monetary_policy_handbook$Data extends ItemData {
    "__name": TString;
    "directory_of_cities": TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
    "daily_allowance": TMoney<'RUB'>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$business_trips$monetary_policy_handbook$Processes extends Processes {
}

interface Application$business_trips$monetary_policy_handbook extends Application<
        Application$business_trips$monetary_policy_handbook$Data,
        Application$business_trips$monetary_policy_handbook$Params,
        Application$business_trips$monetary_policy_handbook$Processes
    > {
}
type Application$business_trips$monetary_policy_handbook$Params = any;

interface Application$business_trips$staff$Data extends ItemData {
    "__id": TString;
    "__sourceRef": TRefItem;
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "__name": TString;
    "ext_user": TUser;
    "entity": TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "is_employed": TBoolean;
    "full_name": TFullName;
    "personal_number": TString;
}

interface Application$business_trips$staff$Processes extends Processes {
}

interface Application$business_trips$staff extends Application<
        Application$business_trips$staff$Data,
        Application$business_trips$staff$Params,
        Application$business_trips$staff$Processes
    > {
}
type Application$business_trips$staff$Params = any;

interface Processes$business_trips extends Processes {
    /**
     * Оповещение
     */
    "signing_process": Process$business_trips$signing_process<ProcessContext$business_trips$signing_process>;
}
interface Namespace$business_trips extends NamespaceBase<Readonly<{
    "goroda": Application$business_trips$goroda;
    "avansovyi_otchet": Application$business_trips$avansovyi_otchet;
    "order_for_a_business_trip": Application$business_trips$order_for_a_business_trip;
    "trip_requests": Application$business_trips$trip_requests;
    "transport_type": Application$business_trips$transport_type;
    "businesstrip_requests": Application$business_trips$businesstrip_requests;
    "service_assignments": Application$business_trips$service_assignments;
    "types_of_funds": Application$business_trips$types_of_funds;
    "monetary_policy_handbook": Application$business_trips$monetary_policy_handbook;
    "staff": Application$business_trips$staff;
}>> {
    readonly processes: Processes$business_trips;
}

interface Application$cb_requirements$kategorii_trebovanii$Data extends ItemData {
    "__name": TString;
    "trebovaniya": TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>[];
    "dochernie_kategorii": TApplication<Application$cb_requirements$kategorii_trebovanii$Data, Application$cb_requirements$kategorii_trebovanii$Params, Application$cb_requirements$kategorii_trebovanii$Processes>[];
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$cb_requirements$kategorii_trebovanii$Processes extends Processes {
}

interface Application$cb_requirements$kategorii_trebovanii extends Application<
        Application$cb_requirements$kategorii_trebovanii$Data,
        Application$cb_requirements$kategorii_trebovanii$Params,
        Application$cb_requirements$kategorii_trebovanii$Processes
    > {
}
type Application$cb_requirements$kategorii_trebovanii$Params = any;

type Enum$cb_requirements$trebovaniya$tip_trebovaniya = 'funkcionalnoe'|'nefunkcionalnoe';



interface Table$cb_requirements$trebovaniya$versii_trebovaniya$Row {
     "__count": TFloat;
     "__index": TFloat;
     "nomer_versii": TFloat;
     "tekst": TString;
}

interface Table$cb_requirements$trebovaniya$versii_trebovaniya$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "nomer_versii": Readonly<TString>;
    readonly "tekst": Readonly<TString>;
}



interface StatusGroups$cb_requirements$trebovaniya {
    readonly "__default": StatusItem$cb_requirements$trebovaniya$__default;
}

type StatusItem$cb_requirements$trebovaniya$__default = 'na-soglasovanii' | 'soglasovano' | 'realizovano';

interface Application$cb_requirements$trebovaniya$Data extends ItemData {
    "__name": TString;
    "tip_trebovaniya": TEnum<Enum$cb_requirements$trebovaniya$tip_trebovaniya>;
    "tekst_trebovaniya": TString;
    "versii_trebovaniya": TTable<Table$cb_requirements$trebovaniya$versii_trebovaniya$Row, Table$cb_requirements$trebovaniya$versii_trebovaniya$Result>;
    "dochernie_trebovaniya": TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$cb_requirements$trebovaniya$__default, StatusGroups$cb_requirements$trebovaniya>;
}

interface Application$cb_requirements$trebovaniya$Processes extends Processes {
    /**
     * Согласовать
     */
    "soglasovat": Process$cb_requirements$trebovaniya$soglasovat<ProcessContext$cb_requirements$trebovaniya$soglasovat>;
    /**
     * Массово согласовать
     */
    "massovo_soglasovat": Process$cb_requirements$trebovaniya$massovo_soglasovat<ProcessContext$cb_requirements$trebovaniya$massovo_soglasovat>;
    /**
     * Добавить новую версию
     */
    "dobavit_novuyu_versiyu": Process$cb_requirements$trebovaniya$dobavit_novuyu_versiyu<ProcessContext$cb_requirements$trebovaniya$dobavit_novuyu_versiyu>;
    /**
     * Добавить первую версию
     */
    "dobavit_pervuyu_versiyu": Process$cb_requirements$trebovaniya$dobavit_pervuyu_versiyu<ProcessContext$cb_requirements$trebovaniya$dobavit_pervuyu_versiyu>;
}

interface Application$cb_requirements$trebovaniya extends Application<
        Application$cb_requirements$trebovaniya$Data,
        Application$cb_requirements$trebovaniya$Params,
        Application$cb_requirements$trebovaniya$Processes
    > {
}
type Application$cb_requirements$trebovaniya$Params = any;



interface Table$cb_requirements$dokumenty$trebovaniya$Row {
     "__count": TFloat;
     "__index": TFloat;
     "nazvanie_razdela": TString;
     "nomer_trebovaniya": TFloat;
     "trebovanie": TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>;
     "tekst": TString;
     "versiya": TFloat;
     "nomer_razdela": TFloat;
     "status_req": TString;
}

interface Table$cb_requirements$dokumenty$trebovaniya$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "nazvanie_razdela": Readonly<TString>;
    readonly "nomer_trebovaniya": Readonly<TString>;
    readonly "trebovanie": Readonly<TString>;
    readonly "tekst": Readonly<TString>;
    readonly "versiya": Readonly<TString>;
    readonly "nomer_razdela": Readonly<TString>;
    readonly "status_req": Readonly<TString>;
}




interface Table$cb_requirements$dokumenty$razdely$Row {
     "__count": TFloat;
     "__index": TFloat;
     "nomer_razdela": TFloat;
     "nazvanie_razdela": TString;
}

interface Table$cb_requirements$dokumenty$razdely$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "nomer_razdela": Readonly<TString>;
    readonly "nazvanie_razdela": Readonly<TString>;
}


interface Application$cb_requirements$dokumenty$Data extends ItemData {
    "naimenovanie_dokumenta": TString;
    "__file": TFile;
    "trebovaniya": TTable<Table$cb_requirements$dokumenty$trebovaniya$Row, Table$cb_requirements$dokumenty$trebovaniya$Result>;
    "razdely": TTable<Table$cb_requirements$dokumenty$razdely$Row, Table$cb_requirements$dokumenty$razdely$Result>;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$cb_requirements$dokumenty$Processes extends Processes {
    /**
     * Генерация
     */
    "generaciya": Process$cb_requirements$dokumenty$generaciya<ProcessContext$cb_requirements$dokumenty$generaciya>;
}

interface Application$cb_requirements$dokumenty extends Application<
        Application$cb_requirements$dokumenty$Data,
        Application$cb_requirements$dokumenty$Params,
        Application$cb_requirements$dokumenty$Processes
    > {
}
type Application$cb_requirements$dokumenty$Params = any;

interface Namespace$cb_requirements extends NamespaceBase<Readonly<{
    "kategorii_trebovanii": Application$cb_requirements$kategorii_trebovanii;
    "trebovaniya": Application$cb_requirements$trebovaniya;
    "dokumenty": Application$cb_requirements$dokumenty;
}>> {
}

interface Namespace$company extends NamespaceBase<Readonly<{
}>> {
}

interface Application$dokumenty_1$contract$Data extends ItemData {
    "__file": TFile;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$dokumenty_1$contract$Processes extends Processes {
}

interface Application$dokumenty_1$contract extends Application<
        Application$dokumenty_1$contract$Data,
        Application$dokumenty_1$contract$Params,
        Application$dokumenty_1$contract$Processes
    > {
}
type Application$dokumenty_1$contract$Params = any;

interface Application$dokumenty_1$tip_dokumenta_1$Data extends ItemData {
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "__file": TFile;
}

interface Application$dokumenty_1$tip_dokumenta_1$Processes extends Processes {
}

interface Application$dokumenty_1$tip_dokumenta_1 extends Application<
        Application$dokumenty_1$tip_dokumenta_1$Data,
        Application$dokumenty_1$tip_dokumenta_1$Params,
        Application$dokumenty_1$tip_dokumenta_1$Processes
    > {
}
type Application$dokumenty_1$tip_dokumenta_1$Params = any;

interface Namespace$dokumenty_1 extends NamespaceBase<Readonly<{
    "contract": Application$dokumenty_1$contract;
    "tip_dokumenta_1": Application$dokumenty_1$tip_dokumenta_1;
}>> {
}

interface Namespace$ext_9e324a78U002Dc635U002D4f21U002D883cU002D05c34feea2c9 extends NamespaceBase<Readonly<{
}>> {
}

interface Namespace$files extends NamespaceBase<Readonly<{
}>> {
}

type Enum$gurtovtest$test1$type = '1'|'2';

interface Application$gurtovtest$test1$Data extends ItemData {
    "__name": TString;
    "type": TEnum<Enum$gurtovtest$test1$type>;
    "first_txt": TString;
    "second_txt": TString;
    "ishidden1": TBoolean;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$gurtovtest$test1$Processes extends Processes {
}

interface Application$gurtovtest$test1 extends Application<
        Application$gurtovtest$test1$Data,
        Application$gurtovtest$test1$Params,
        Application$gurtovtest$test1$Processes
    > {
}
type Application$gurtovtest$test1$Params = any;

interface Namespace$gurtovtest extends NamespaceBase<Readonly<{
    "test1": Application$gurtovtest$test1;
}>> {
}


interface StatusGroups$kedo$labor_contract {
    readonly "__default": StatusItem$kedo$labor_contract$__default;
}

type StatusItem$kedo$labor_contract$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$kedo$labor_contract$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$labor_contract$__default, StatusGroups$kedo$labor_contract>;
}

interface Application$kedo$labor_contract$Processes extends Processes {
}

interface Application$kedo$labor_contract extends Application<
        Application$kedo$labor_contract$Data,
        Application$kedo$labor_contract$Params,
        Application$kedo$labor_contract$Processes
    > {
}
type Application$kedo$labor_contract$Params = any;

interface Application$kedo$structural_subdivision$Data extends ItemData {
    "__name": TString;
    "organization": TApplication<Application$kedo$organization$Data, Application$kedo$organization$Params, Application$kedo$organization$Processes>;
    "subdivision": TApplication<Application$kedo$structural_subdivision$Data, Application$kedo$structural_subdivision$Params, Application$kedo$structural_subdivision$Processes>;
    "ref_key": TString;
    "owner_key": TString;
    "parent_key": TString;
    "position_key": TString;
    "position": TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$kedo$structural_subdivision$Processes extends Processes {
}

interface Application$kedo$structural_subdivision extends Application<
        Application$kedo$structural_subdivision$Data,
        Application$kedo$structural_subdivision$Params,
        Application$kedo$structural_subdivision$Processes
    > {
}
type Application$kedo$structural_subdivision$Params = any;


interface StatusGroups$kedo$letter_of_resignation {
    readonly "__default": StatusItem$kedo$letter_of_resignation$__default;
}

type StatusItem$kedo$letter_of_resignation$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$kedo$letter_of_resignation$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "date_of_dismissal": TDate;
    "reason_for_leaving": TString;
    "linked_order": TApplication<Application$kedo$dismissal_order$Data, Application$kedo$dismissal_order$Params, Application$kedo$dismissal_order$Processes>;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$letter_of_resignation$__default, StatusGroups$kedo$letter_of_resignation>;
}

interface Application$kedo$letter_of_resignation$Processes extends Processes {
}

interface Application$kedo$letter_of_resignation extends Application<
        Application$kedo$letter_of_resignation$Data,
        Application$kedo$letter_of_resignation$Params,
        Application$kedo$letter_of_resignation$Processes
    > {
}
type Application$kedo$letter_of_resignation$Params = any;

interface Application$kedo$directory_of_regions$Data extends ItemData {
    "__name": TString;
    "the_code": TFloat;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$kedo$directory_of_regions$Processes extends Processes {
}

interface Application$kedo$directory_of_regions extends Application<
        Application$kedo$directory_of_regions$Data,
        Application$kedo$directory_of_regions$Params,
        Application$kedo$directory_of_regions$Processes
    > {
}
type Application$kedo$directory_of_regions$Params = any;


interface StatusGroups$kedo$job_application {
    readonly "__default": StatusItem$kedo$job_application$__default;
}

type StatusItem$kedo$job_application$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$kedo$job_application$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_file_name": TString;
    "line_status": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$job_application$__default, StatusGroups$kedo$job_application>;
}

interface Application$kedo$job_application$Processes extends Processes {
}

interface Application$kedo$job_application extends Application<
        Application$kedo$job_application$Data,
        Application$kedo$job_application$Params,
        Application$kedo$job_application$Processes
    > {
}
type Application$kedo$job_application$Params = any;

type Enum$kedo$staff$notification = 'email'|'sms'|'email_and_sms'|'without_notifications';

type Enum$kedo$staff$invalid_fields = 'main'|'location'|'documents'|'document_scans'|'photo';


interface StatusGroups$kedo$staff {
    readonly "__default": StatusItem$kedo$staff$__default;
}

type StatusItem$kedo$staff$__default = 'invited' | 'filling_pnd' | 'input_data' | 'editing_pnd' | 'acquaintance_with_the_agreement' | 'conclude_an_agreement' | 'signing_documents' | 'signed_documents' | 'rejected' | 'waiting_for_document_editing' | 'UNEP_release_confirmation' | 'dismissed';

interface Application$kedo$staff$Data extends ItemData {
    "full_name": TFullName;
    "email": TEmail<EmailType.Work>;
    "sex": TBoolean;
    "marriage": TBoolean;
    "date_of_birth": TDate;
    "city": TString;
    "street": TString;
    "home": TString;
    "passport_series": TString;
    "passport_number": TString;
    "apartment": TString;
    "housing": TString;
    "passport_department_code": TString;
    "date_of_issue": TDate;
    "issued_by": TString;
    "snils": TString;
    "inn": TString;
    "phone": TPhone<PhoneType.Work>;
    "passport_page_with_photo_and_data": TFile;
    "the_passport_page_with_current_registration": TFile;
    "snils_file": TFile;
    "photo_with_unfolded_passport": TFile;
    "inn_file": TFile;
    "entity": TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "structural_subdivision": TApplication<Application$kedo$structural_subdivision$Data, Application$kedo$structural_subdivision$Params, Application$kedo$structural_subdivision$Processes>;
    "is_employed": TBoolean;
    "position": TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "notification": TEnum<Enum$kedo$staff$notification>;
    "external_user": TApplication<Application$_system_catalogs$_user_profiles$Data, Application$_system_catalogs$_user_profiles$Params, Application$_system_catalogs$_user_profiles$Processes>[];
    "personal_number": TString;
    "ext_user": TUser;
    "staff_access": TBoolean;
    "invalid_fields": TEnum<Enum$kedo$staff$invalid_fields>[];
    "disclaimer_comment": TString;
    "staff_comment": TString;
    "region": TString;
    "address": TString;
    "scan_soev": TFile;
    "staff_member": TUser;
    "support_fields": TString;
    "documents_employment": TApplication<Application$kedo$documents_for_employment$Data, Application$kedo$documents_for_employment$Params, Application$kedo$documents_for_employment$Processes>[];
    "personnel_documents": TApplication<Application$personnel_documents$personnel_documents$Data, Application$personnel_documents$personnel_documents$Params, Application$personnel_documents$personnel_documents$Processes>[];
    "organization": TApplication<Application$kedo$organization$Data, Application$kedo$organization$Params, Application$kedo$organization$Processes>;
    "accepted_agreement": TBoolean;
    "time_acceptance_agreement": TDatetime;
    "id_1c": TString;
    "directory_of_regions": TApplication<Application$kedo$directory_of_regions$Data, Application$kedo$directory_of_regions$Params, Application$kedo$directory_of_regions$Processes>;
    "unep_issue_required": TBoolean;
    "group": TRole[];
    "individual_id_1c": TString;
    "passport_saved_in_1s": TBoolean;
    "remaining_vacation_days": TFloat;
    "date_receipt_signing_certificate": TDate;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$staff$__default, StatusGroups$kedo$staff>;
}

interface Application$kedo$staff$Processes extends Processes {
    /**
     * Процесс увольнения
     */
    "the_dismissal_process": Process$kedo$staff$the_dismissal_process<ProcessContext$kedo$staff$the_dismissal_process>;
    /**
     * Создание/обновление сотрудника в 1с
     */
    "create_or_update_1c_employee": Process$kedo$staff$create_or_update_1c_employee<ProcessContext$kedo$staff$create_or_update_1c_employee>;
    /**
     * Генерация приказа
     */
    "order_generation": Process$kedo$staff$order_generation<ProcessContext$kedo$staff$order_generation>;
    /**
     * Процесс перевода
     */
    "transfer_process": Process$kedo$staff$transfer_process<ProcessContext$kedo$staff$transfer_process>;
    /**
     * Активация на портале КЭДО
     */
    "Employment": Process$kedo$staff$Employment<ProcessContext$kedo$staff$Employment>;
    /**
     * Генерация документов для трудоустройства
     */
    "toolbar_button": Process$kedo$staff$toolbar_button<ProcessContext$kedo$staff$toolbar_button>;
    /**
     * Подпроцесс выпуска sign.me
     */
    "signme_release": Process$kedo$staff$signme_release<ProcessContext$kedo$staff$signme_release>;
    /**
     * Генерация Соглашения об ЭВ
     */
    "agreement_generation": Process$kedo$staff$agreement_generation<ProcessContext$kedo$staff$agreement_generation>;
    /**
     * Приглашение пользователя
     */
    "user_prompt": Process$kedo$staff$user_prompt<ProcessContext$kedo$staff$user_prompt>;
    /**
     * Получение ссылки на портал
     */
    "get_link": Process$kedo$staff$get_link<ProcessContext$kedo$staff$get_link>;
    /**
     * Процесс перевыпуска сертификатов sign.me
     */
    "sign_me_certificate_reissuance": Process$kedo$staff$sign_me_certificate_reissuance<ProcessContext$kedo$staff$sign_me_certificate_reissuance>;
    /**
     * Загрузить сотрудников из 1С
     */
    "load_employee_list": Process$kedo$staff$load_employee_list<ProcessContext$kedo$staff$load_employee_list>;
}

interface Application$kedo$staff extends Application<
        Application$kedo$staff$Data,
        Application$kedo$staff$Params,
        Application$kedo$staff$Processes
    > {
}
type Application$kedo$staff$Params = any;


interface StatusGroups$kedo$electronic_interaction_agreement {
    readonly "__default": StatusItem$kedo$electronic_interaction_agreement$__default;
}

type StatusItem$kedo$electronic_interaction_agreement$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$kedo$electronic_interaction_agreement$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$electronic_interaction_agreement$__default, StatusGroups$kedo$electronic_interaction_agreement>;
}

interface Application$kedo$electronic_interaction_agreement$Processes extends Processes {
}

interface Application$kedo$electronic_interaction_agreement extends Application<
        Application$kedo$electronic_interaction_agreement$Data,
        Application$kedo$electronic_interaction_agreement$Params,
        Application$kedo$electronic_interaction_agreement$Processes
    > {
}
type Application$kedo$electronic_interaction_agreement$Params = any;

interface Application$kedo$organization$Data extends ItemData {
    "entity": TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "ref_key": TString;
    "owner_key": TString;
    "parent_key": TString;
    "position_key": TString;
    "agreement_processing_personal_data": TFile;
    "confidentiality_policy": TFile;
    "subdivision": TApplication<Application$kedo$structural_subdivision$Data, Application$kedo$structural_subdivision$Params, Application$kedo$structural_subdivision$Processes>[];
    "position_head": TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "signatory_position": TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$kedo$organization$Processes extends Processes {
}

interface Application$kedo$organization extends Application<
        Application$kedo$organization$Data,
        Application$kedo$organization$Params,
        Application$kedo$organization$Processes
    > {
}
type Application$kedo$organization$Params = any;

interface Application$kedo$position$Data extends ItemData {
    "__name": TString;
    "salary": TMoney<'RUB'>;
    "approval_date": TDate;
    "quantity": TFloat;
    "organization": TApplication<Application$kedo$organization$Data, Application$kedo$organization$Params, Application$kedo$organization$Processes>;
    "subdivision": TApplication<Application$kedo$structural_subdivision$Data, Application$kedo$structural_subdivision$Params, Application$kedo$structural_subdivision$Processes>;
    "ref_key": TString;
    "owner_key": TString;
    "parent_key": TString;
    "position_key": TString;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>[];
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$kedo$position$Processes extends Processes {
}

interface Application$kedo$position extends Application<
        Application$kedo$position$Data,
        Application$kedo$position$Params,
        Application$kedo$position$Processes
    > {
}
type Application$kedo$position$Params = any;


interface StatusGroups$kedo$information_about_labor_activity {
    readonly "__default": StatusItem$kedo$information_about_labor_activity$__default;
}

type StatusItem$kedo$information_about_labor_activity$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$kedo$information_about_labor_activity$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$information_about_labor_activity$__default, StatusGroups$kedo$information_about_labor_activity>;
}

interface Application$kedo$information_about_labor_activity$Processes extends Processes {
}

interface Application$kedo$information_about_labor_activity extends Application<
        Application$kedo$information_about_labor_activity$Data,
        Application$kedo$information_about_labor_activity$Params,
        Application$kedo$information_about_labor_activity$Processes
    > {
}
type Application$kedo$information_about_labor_activity$Params = any;


interface StatusGroups$kedo$additional_agreement_to_the_contract {
    readonly "__default": StatusItem$kedo$additional_agreement_to_the_contract$__default;
}

type StatusItem$kedo$additional_agreement_to_the_contract$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$kedo$additional_agreement_to_the_contract$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_file_name": TString;
    "line_status": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$additional_agreement_to_the_contract$__default, StatusGroups$kedo$additional_agreement_to_the_contract>;
}

interface Application$kedo$additional_agreement_to_the_contract$Processes extends Processes {
}

interface Application$kedo$additional_agreement_to_the_contract extends Application<
        Application$kedo$additional_agreement_to_the_contract$Data,
        Application$kedo$additional_agreement_to_the_contract$Params,
        Application$kedo$additional_agreement_to_the_contract$Processes
    > {
}
type Application$kedo$additional_agreement_to_the_contract$Params = any;


interface StatusGroups$kedo$transfer_application {
    readonly "__default": StatusItem$kedo$transfer_application$__default;
}

type StatusItem$kedo$transfer_application$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$kedo$transfer_application$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "old_postion": TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "new_position": TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "transfer_date": TDate;
    "date_of_creation": TDate;
    "linked_order": TApplication<Application$kedo$order_for_transfer$Data, Application$kedo$order_for_transfer$Params, Application$kedo$order_for_transfer$Processes>;
    "current_date": TDate;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$transfer_application$__default, StatusGroups$kedo$transfer_application>;
}

interface Application$kedo$transfer_application$Processes extends Processes {
}

interface Application$kedo$transfer_application extends Application<
        Application$kedo$transfer_application$Data,
        Application$kedo$transfer_application$Params,
        Application$kedo$transfer_application$Processes
    > {
}
type Application$kedo$transfer_application$Params = any;


interface StatusGroups$kedo$admission_order {
    readonly "__default": StatusItem$kedo$admission_order$__default;
}

type StatusItem$kedo$admission_order$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$kedo$admission_order$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_officer": TUser;
    "line_file_name": TString;
    "line_status": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$admission_order$__default, StatusGroups$kedo$admission_order>;
    "__register_name": TString;
}

interface Application$kedo$admission_order$Processes extends Processes {
}

interface Application$kedo$admission_order extends Application<
        Application$kedo$admission_order$Data,
        Application$kedo$admission_order$Params,
        Application$kedo$admission_order$Processes
    > {
}
type Application$kedo$admission_order$Params = any;

interface Application$kedo$staffing_data$Data extends ItemData {
    "json_staffing_data": TString;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$kedo$staffing_data$Processes extends Processes {
    /**
     * Интеграция Штатного расписания с 1С
     */
    "staffing_integration_with_1s": Process$kedo$staffing_data$staffing_integration_with_1s<ProcessContext$kedo$staffing_data$staffing_integration_with_1s>;
    /**
     * Обновить объект JSON
     */
    "update_json_object": Process$kedo$staffing_data$update_json_object<ProcessContext$kedo$staffing_data$update_json_object>;
}

interface Application$kedo$staffing_data extends Application<
        Application$kedo$staffing_data$Data,
        Application$kedo$staffing_data$Params,
        Application$kedo$staffing_data$Processes
    > {
}
type Application$kedo$staffing_data$Params = any;


interface StatusGroups$kedo$order_for_transfer {
    readonly "__default": StatusItem$kedo$order_for_transfer$__default;
}

type StatusItem$kedo$order_for_transfer$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$kedo$order_for_transfer$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible_user": TUser;
    "responsible": TString;
    "line_file_name": TString;
    "line_status": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$order_for_transfer$__default, StatusGroups$kedo$order_for_transfer>;
    "__register_name": TString;
}

interface Application$kedo$order_for_transfer$Processes extends Processes {
}

interface Application$kedo$order_for_transfer extends Application<
        Application$kedo$order_for_transfer$Data,
        Application$kedo$order_for_transfer$Params,
        Application$kedo$order_for_transfer$Processes
    > {
}
type Application$kedo$order_for_transfer$Params = any;


interface StatusGroups$kedo$dismissal_order {
    readonly "__default": StatusItem$kedo$dismissal_order$__default;
}

type StatusItem$kedo$dismissal_order$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$kedo$dismissal_order$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "resignation_letter": TApplication<Application$kedo$letter_of_resignation$Data, Application$kedo$letter_of_resignation$Params, Application$kedo$letter_of_resignation$Processes>;
    "responsible": TUser;
    "responsible_string": TString;
    "line_file_name": TString;
    "line_status": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$kedo$dismissal_order$__default, StatusGroups$kedo$dismissal_order>;
    "__register_name": TString;
}

interface Application$kedo$dismissal_order$Processes extends Processes {
}

interface Application$kedo$dismissal_order extends Application<
        Application$kedo$dismissal_order$Data,
        Application$kedo$dismissal_order$Params,
        Application$kedo$dismissal_order$Processes
    > {
}
type Application$kedo$dismissal_order$Params = any;

interface Application$kedo$documents_for_employment$Data extends ItemData {
    "__id": TString;
    "__sourceRef": TRefItem;
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "__name": TString;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
}

interface Application$kedo$documents_for_employment$Processes extends Processes {
}

interface Application$kedo$documents_for_employment extends Application<
        Application$kedo$documents_for_employment$Data,
        Application$kedo$documents_for_employment$Params,
        Application$kedo$documents_for_employment$Processes
    > {
}
type Application$kedo$documents_for_employment$Params = any;

type Enum$kedo$holidays$type_of = never;

interface Application$kedo$holidays$Data extends ItemData {
    "__id": TString;
    "__sourceRef": TRefItem;
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "__name": TString;
    "start": TDate;
    "end": TDate;
    "status": TString;
    "amount_of_days": TFloat;
    "type_of": TEnum<Enum$kedo$holidays$type_of>;
    "staff_user": TUser;
}

interface Application$kedo$holidays$Processes extends Processes {
}

interface Application$kedo$holidays extends Application<
        Application$kedo$holidays$Data,
        Application$kedo$holidays$Params,
        Application$kedo$holidays$Processes
    > {
}
type Application$kedo$holidays$Params = any;

interface Application$kedo$business_trips$Data extends ItemData {
    "__id": TString;
    "__sourceRef": TRefItem;
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "__name": TString;
    "start_date": TDatetime;
    "end_date": TDatetime;
    "status": TString;
    "traveling_users": TUser[];
}

interface Application$kedo$business_trips$Processes extends Processes {
}

interface Application$kedo$business_trips extends Application<
        Application$kedo$business_trips$Data,
        Application$kedo$business_trips$Params,
        Application$kedo$business_trips$Processes
    > {
}
type Application$kedo$business_trips$Params = any;

interface Processes$kedo extends Processes {
    /**
     * Процесс для кнопки "найдена ошибка"
     */
    "error_found_button": Process$kedo$error_found_button<ProcessContext$kedo$error_found_button>;
}
interface Namespace$kedo extends NamespaceBase<Readonly<{
    "labor_contract": Application$kedo$labor_contract;
    "structural_subdivision": Application$kedo$structural_subdivision;
    "letter_of_resignation": Application$kedo$letter_of_resignation;
    "directory_of_regions": Application$kedo$directory_of_regions;
    "job_application": Application$kedo$job_application;
    "staff": Application$kedo$staff;
    "electronic_interaction_agreement": Application$kedo$electronic_interaction_agreement;
    "organization": Application$kedo$organization;
    "position": Application$kedo$position;
    "information_about_labor_activity": Application$kedo$information_about_labor_activity;
    "additional_agreement_to_the_contract": Application$kedo$additional_agreement_to_the_contract;
    "transfer_application": Application$kedo$transfer_application;
    "admission_order": Application$kedo$admission_order;
    "staffing_data": Application$kedo$staffing_data;
    "order_for_transfer": Application$kedo$order_for_transfer;
    "dismissal_order": Application$kedo$dismissal_order;
    "documents_for_employment": Application$kedo$documents_for_employment;
    "holidays": Application$kedo$holidays;
    "business_trips": Application$kedo$business_trips;
}>> {
    readonly processes: Processes$kedo;
}

interface Application$kp$kp_forma_1$Data extends ItemData {
    "data_formirovaniya": TDatetime;
    "srochnoe": TBoolean;
    "iskhodyashii_nomer": TString;
    "data_iskhodyashaya": TDate;
    "summa_kp": TMoney<'RUB'>;
    "__file": TFile;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$kp$kp_forma_1$Processes extends Processes {
    /**
     * Согласование КП (Тест1)
     */
    "soglasovanie_kp_test1": Process$kp$kp_forma_1$soglasovanie_kp_test1<ProcessContext$kp$kp_forma_1$soglasovanie_kp_test1>;
}

interface Application$kp$kp_forma_1 extends Application<
        Application$kp$kp_forma_1$Data,
        Application$kp$kp_forma_1$Params,
        Application$kp$kp_forma_1$Processes
    > {
}
type Application$kp$kp_forma_1$Params = any;

type Enum$kp$tovary_dlya_kp$kategoriya = '1'|'2'|'3';

interface Application$kp$tovary_dlya_kp$Data extends ItemData {
    "__name": TString;
    "data_vremya": TDatetime;
    "kategoriya": TEnum<Enum$kp$tovary_dlya_kp$kategoriya>;
    "vlozhit_skan_kvitancii": TFile;
    "sdelat_obyazatelnym_vlozhenie": TBoolean;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$kp$tovary_dlya_kp$Processes extends Processes {
    /**
     * Подготовка КП (Коваленко)
     */
    "podgotovka_kp_kovalenko": Process$kp$tovary_dlya_kp$podgotovka_kp_kovalenko<ProcessContext$kp$tovary_dlya_kp$podgotovka_kp_kovalenko>;
}

interface Application$kp$tovary_dlya_kp extends Application<
        Application$kp$tovary_dlya_kp$Data,
        Application$kp$tovary_dlya_kp$Params,
        Application$kp$tovary_dlya_kp$Processes
    > {
}
type Application$kp$tovary_dlya_kp$Params = any;

interface Namespace$kp extends NamespaceBase<Readonly<{
    "kp_forma_1": Application$kp$kp_forma_1;
    "tovary_dlya_kp": Application$kp$tovary_dlya_kp;
}>> {
}

interface Namespace$messages extends NamespaceBase<Readonly<{
}>> {
}

interface Application$oco$service$Data extends ItemData {
    "__name": TString;
    "service_owner": TUser;
    "service_coordinator": TUser;
    "sla": TFloat;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$oco$service$Processes extends Processes {
}

interface Application$oco$service extends Application<
        Application$oco$service$Data,
        Application$oco$service$Params,
        Application$oco$service$Processes
    > {
}
type Application$oco$service$Params = any;

interface Application$oco$appeals$Data extends ItemData {
    "autor": TUser;
    "choose_service": TApplication<Application$oco$service$Data, Application$oco$service$Params, Application$oco$service$Processes>;
    "data_start": TDatetime;
    "dedline": TDatetime;
    "date_completed": TDatetime;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$oco$appeals$Processes extends Processes {
}

interface Application$oco$appeals extends Application<
        Application$oco$appeals$Data,
        Application$oco$appeals$Params,
        Application$oco$appeals$Processes
    > {
}
type Application$oco$appeals$Params = any;

interface Application$oco$tasks_oco$Data extends ItemData {
    "standard_tasks": TApplication<Application$oco$sla$Data, Application$oco$sla$Params, Application$oco$sla$Processes>;
    "request": TApplication<Application$oco$appeals$Data, Application$oco$appeals$Params, Application$oco$appeals$Processes>;
    "link_process": TRefItem;
    "guid_process": TString;
    "data_start": TDatetime;
    "data_completed": TDatetime;
    "norm": TFloat;
    "service_name": TString;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$oco$tasks_oco$Processes extends Processes {
}

interface Application$oco$tasks_oco extends Application<
        Application$oco$tasks_oco$Data,
        Application$oco$tasks_oco$Params,
        Application$oco$tasks_oco$Processes
    > {
}
type Application$oco$tasks_oco$Params = any;

interface Application$oco$employee$Data extends ItemData {
    "user": TUser;
    "entity_oco": TApplication<Application$oco$sdc_units$Data, Application$oco$sdc_units$Params, Application$oco$sdc_units$Processes>;
    "grade_oco": TApplication<Application$oco$sdc_posts$Data, Application$oco$sdc_posts$Params, Application$oco$sdc_posts$Processes>;
    "date_include": TDate;
    "cost_hours": TMoney<'RUB'>;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$oco$employee$Processes extends Processes {
}

interface Application$oco$employee extends Application<
        Application$oco$employee$Data,
        Application$oco$employee$Params,
        Application$oco$employee$Processes
    > {
}
type Application$oco$employee$Params = any;

interface Application$oco$sla$Data extends ItemData {
    "__name": TString;
    "servis": TApplication<Application$oco$service$Data, Application$oco$service$Params, Application$oco$service$Processes>;
    "task_standart": TFloat;
    "sla": TFloat;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$oco$sla$Processes extends Processes {
}

interface Application$oco$sla extends Application<
        Application$oco$sla$Data,
        Application$oco$sla$Params,
        Application$oco$sla$Processes
    > {
}
type Application$oco$sla$Params = any;

interface Application$oco$sdc_posts$Data extends ItemData {
    "__name": TString;
    "sdc_unit": TApplication<Application$oco$sdc_units$Data, Application$oco$sdc_units$Params, Application$oco$sdc_units$Processes>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$oco$sdc_posts$Processes extends Processes {
}

interface Application$oco$sdc_posts extends Application<
        Application$oco$sdc_posts$Data,
        Application$oco$sdc_posts$Params,
        Application$oco$sdc_posts$Processes
    > {
}
type Application$oco$sdc_posts$Params = any;


interface StatusGroups$oco$application_registrarion_employee {
    readonly "__default": StatusItem$oco$application_registrarion_employee$__default;
}

type StatusItem$oco$application_registrarion_employee$__default = 'draft' | 'new' | 'in-work' | 'done';

interface Application$oco$application_registrarion_employee$Data extends ItemData {
    "appeal": TApplication<Application$oco$appeals$Data, Application$oco$appeals$Params, Application$oco$appeals$Processes>;
    "fio_sotrudnika": TFullName;
    "entity": TString;
    "grade": TString;
    "coast": TMoney<'RUB'>;
    "unit": TApplication<Application$oco$sdc_units$Data, Application$oco$sdc_units$Params, Application$oco$sdc_units$Processes>;
    "post": TApplication<Application$oco$sdc_posts$Data, Application$oco$sdc_posts$Params, Application$oco$sdc_posts$Processes>;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$oco$application_registrarion_employee$__default, StatusGroups$oco$application_registrarion_employee>;
}

interface Application$oco$application_registrarion_employee$Processes extends Processes {
    /**
     * Заявка на оформление сотрудника
     */
    "application_registrarion_employee": Process$oco$application_registrarion_employee$application_registrarion_employee<ProcessContext$oco$application_registrarion_employee$application_registrarion_employee>;
}

interface Application$oco$application_registrarion_employee extends Application<
        Application$oco$application_registrarion_employee$Data,
        Application$oco$application_registrarion_employee$Params,
        Application$oco$application_registrarion_employee$Processes
    > {
}
type Application$oco$application_registrarion_employee$Params = any;

interface Application$oco$sdc_units$Data extends ItemData {
    "__name": TString;
    "chief": TUser;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$oco$sdc_units$Processes extends Processes {
}

interface Application$oco$sdc_units extends Application<
        Application$oco$sdc_units$Data,
        Application$oco$sdc_units$Params,
        Application$oco$sdc_units$Processes
    > {
}
type Application$oco$sdc_units$Params = any;

interface Application$oco$records_cost$Data extends ItemData {
    "tasks_oco": TApplication<Application$oco$tasks_oco$Data, Application$oco$tasks_oco$Params, Application$oco$tasks_oco$Processes>;
    "employee": TUser;
    "labor_costs": TFloat;
    "description": TString;
    "sdc_employee": TApplication<Application$oco$employee$Data, Application$oco$employee$Params, Application$oco$employee$Processes>;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$oco$records_cost$Processes extends Processes {
}

interface Application$oco$records_cost extends Application<
        Application$oco$records_cost$Data,
        Application$oco$records_cost$Params,
        Application$oco$records_cost$Processes
    > {
}
type Application$oco$records_cost$Params = any;

interface Namespace$oco extends NamespaceBase<Readonly<{
    "service": Application$oco$service;
    "appeals": Application$oco$appeals;
    "tasks_oco": Application$oco$tasks_oco;
    "employee": Application$oco$employee;
    "sla": Application$oco$sla;
    "sdc_posts": Application$oco$sdc_posts;
    "application_registrarion_employee": Application$oco$application_registrarion_employee;
    "sdc_units": Application$oco$sdc_units;
    "records_cost": Application$oco$records_cost;
}>> {
}



interface Table$payment$daily_payment$payment_request_table$Row {
     "__count": TFloat;
     "daily_payment_request": TApplication<Application$payment$payment_request$Data, Application$payment$payment_request$Params, Application$payment$payment_request$Processes>;
     "payment_request_initiator": TUser;
     "payment_desired_date": TDate;
     "payment_type": TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
     "payment_amount": TMoney<'RUB'>;
     "payment_request_comment": TString;
}

interface Table$payment$daily_payment$payment_request_table$Result {
    readonly "__count": Readonly<TString>;
    readonly "daily_payment_request": Readonly<TString>;
    readonly "payment_request_initiator": Readonly<TString>;
    readonly "payment_desired_date": Readonly<TString>;
    readonly "payment_type": Readonly<TString>;
    readonly "payment_amount": Readonly<TMoney<'RUB'>>;
    readonly "payment_request_comment": Readonly<TString>;
}




interface Table$payment$daily_payment$cash_request_table$Row {
     "__count": TFloat;
     "daily_payment_request": TApplication<Application$payment$payment_request$Data, Application$payment$payment_request$Params, Application$payment$payment_request$Processes>;
     "payment_request_initiator": TUser;
     "payment_desired_date": TDate;
     "payment_type": TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
     "payment_amount": TMoney<'RUB'>;
     "payment_request_comment": TString;
}

interface Table$payment$daily_payment$cash_request_table$Result {
    readonly "__count": Readonly<TString>;
    readonly "daily_payment_request": Readonly<TString>;
    readonly "payment_request_initiator": Readonly<TString>;
    readonly "payment_desired_date": Readonly<TString>;
    readonly "payment_type": Readonly<TString>;
    readonly "payment_amount": Readonly<TMoney<'RUB'>>;
    readonly "payment_request_comment": Readonly<TString>;
}



interface StatusGroups$payment$daily_payment {
    readonly "__default": StatusItem$payment$daily_payment$__default;
}

type StatusItem$payment$daily_payment$__default = 'opened' | 'closed' | 'approved' | 'payed';

interface Application$payment$daily_payment$Data extends ItemData {
    "__startAt": TDatetime;
    "__endAt": TDatetime;
    "__participants": TUser[];
    "payment_request_table": TTable<Table$payment$daily_payment$payment_request_table$Row, Table$payment$daily_payment$payment_request_table$Result>;
    "cash_request_table": TTable<Table$payment$daily_payment$cash_request_table$Row, Table$payment$daily_payment$cash_request_table$Result>;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$payment$daily_payment$__default, StatusGroups$payment$daily_payment>;
}

interface Application$payment$daily_payment$Processes extends Processes {
}

interface Application$payment$daily_payment extends Application<
        Application$payment$daily_payment$Data,
        Application$payment$daily_payment$Params,
        Application$payment$daily_payment$Processes
    > {
}
type Application$payment$daily_payment$Params = any;

interface Application$payment$payment_aim$Data extends ItemData {
    "__name": TString;
    "payee_type": TBoolean;
    "paymet_reason_type": TBoolean;
    "id_required": TBoolean;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$payment$payment_aim$Processes extends Processes {
}

interface Application$payment$payment_aim extends Application<
        Application$payment$payment_aim$Data,
        Application$payment$payment_aim$Params,
        Application$payment$payment_aim$Processes
    > {
}
type Application$payment$payment_aim$Params = any;

interface Application$payment$payment_type$Data extends ItemData {
    "__name": TString;
    "bank_or_cash": TBoolean;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$payment$payment_type$Processes extends Processes {
}

interface Application$payment$payment_type extends Application<
        Application$payment$payment_type$Data,
        Application$payment$payment_type$Params,
        Application$payment$payment_type$Processes
    > {
}
type Application$payment$payment_type$Params = any;



interface Table$payment$payment_request$payment_reason_table$Row {
     "__count": TFloat;
     "name": TString;
     "amount": TFloat;
     "unit_sum": TMoney<'RUB'>;
     readonly "sum": Readonly<TMoney<'RUB'>>;
}

interface Table$payment$payment_request$payment_reason_table$Result {
    readonly "__count": Readonly<TString>;
    readonly "name": Readonly<TString>;
    readonly "amount": Readonly<TString>;
    readonly "unit_sum": Readonly<TString>;
    readonly "sum": Readonly<TMoney<'RUB'>>;
}



interface StatusGroups$payment$payment_request {
    readonly "__default": StatusItem$payment$payment_request$__default;
}

type StatusItem$payment$payment_request$__default = 'on_approval' | 'on_editing' | 'agreed' | 'payment_approved' | 'canceled' | 'payment_refused' | 'paid';

interface Application$payment$payment_request$Data extends ItemData {
    "payment_aim": TApplication<Application$payment$payment_aim$Data, Application$payment$payment_aim$Params, Application$payment$payment_aim$Processes>;
    "payment_type": TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
    "payee_partner": TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "payee_employee": TUser;
    "payment_request_date": TDatetime;
    "payment_desired_date": TDate;
    "approver": TUser;
    "invoice_id": TString;
    "invoice_date": TDate;
    "invoice_date_string": TString;
    "payment_amount": TMoney<'RUB'>;
    "payment_reason_file": TFile;
    "payment_reason_table": TTable<Table$payment$payment_request$payment_reason_table$Row, Table$payment$payment_request$payment_reason_table$Result>;
    "payment_request_comment": TString;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$payment$payment_request$__default, StatusGroups$payment$payment_request>;
}

interface Application$payment$payment_request$Processes extends Processes {
    /**
     * Согласование расходования денежных средств
     */
    "payment_reconciliation": Process$payment$payment_request$payment_reconciliation<ProcessContext$payment$payment_request$payment_reconciliation>;
    /**
     * Рассмотрение и оплата заявок на расходование денежных средств
     */
    "payment_approval": Process$payment$payment_request$payment_approval<ProcessContext$payment$payment_request$payment_approval>;
}

interface Application$payment$payment_request extends Application<
        Application$payment$payment_request$Data,
        Application$payment$payment_request$Params,
        Application$payment$payment_request$Processes
    > {
}
type Application$payment$payment_request$Params = any;

interface Namespace$payment extends NamespaceBase<Readonly<{
    "daily_payment": Application$payment$daily_payment;
    "payment_aim": Application$payment$payment_aim;
    "payment_type": Application$payment$payment_type;
    "payment_request": Application$payment$payment_request;
}>> {
}

interface Application$personnel_documents$handbook_of_certificates$Data extends ItemData {
    "__name": TString;
    "responsible": TRole[];
    "list_of_required_documents": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$personnel_documents$handbook_of_certificates$Processes extends Processes {
}

interface Application$personnel_documents$handbook_of_certificates extends Application<
        Application$personnel_documents$handbook_of_certificates$Data,
        Application$personnel_documents$handbook_of_certificates$Params,
        Application$personnel_documents$handbook_of_certificates$Processes
    > {
}
type Application$personnel_documents$handbook_of_certificates$Params = any;


interface StatusGroups$personnel_documents$application_for_financial_assistance {
    readonly "__default": StatusItem$personnel_documents$application_for_financial_assistance$__default;
}

type StatusItem$personnel_documents$application_for_financial_assistance$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$personnel_documents$application_for_financial_assistance$Data extends ItemData {
    "__file": TFile;
    "type_of_financial_assistance": TApplication<Application$personnel_documents$directory_of_types_of_material_assistance$Data, Application$personnel_documents$directory_of_types_of_material_assistance$Params, Application$personnel_documents$directory_of_types_of_material_assistance$Processes>;
    "reason": TString;
    "required_files": TFile[];
    "responsible": TString;
    "responsible_user": TUser;
    "linked_order": TApplication<Application$personnel_documents$order_financial_assistance$Data, Application$personnel_documents$order_financial_assistance$Params, Application$personnel_documents$order_financial_assistance$Processes>;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$application_for_financial_assistance$__default, StatusGroups$personnel_documents$application_for_financial_assistance>;
}

interface Application$personnel_documents$application_for_financial_assistance$Processes extends Processes {
}

interface Application$personnel_documents$application_for_financial_assistance extends Application<
        Application$personnel_documents$application_for_financial_assistance$Data,
        Application$personnel_documents$application_for_financial_assistance$Params,
        Application$personnel_documents$application_for_financial_assistance$Processes
    > {
}
type Application$personnel_documents$application_for_financial_assistance$Params = any;


interface StatusGroups$personnel_documents$paid_leave_order {
    readonly "__default": StatusItem$personnel_documents$paid_leave_order$__default;
}

type StatusItem$personnel_documents$paid_leave_order$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'rejected';

interface Application$personnel_documents$paid_leave_order$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "organization": TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "personnel_number": TString;
    "start_date": TDatetime;
    "end_date": TDatetime;
    "duration": TFloat;
    "working_period_from": TDate;
    "period_of_work_for": TDate;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$paid_leave_order$__default, StatusGroups$personnel_documents$paid_leave_order>;
}

interface Application$personnel_documents$paid_leave_order$Processes extends Processes {
}

interface Application$personnel_documents$paid_leave_order extends Application<
        Application$personnel_documents$paid_leave_order$Data,
        Application$personnel_documents$paid_leave_order$Params,
        Application$personnel_documents$paid_leave_order$Processes
    > {
}
type Application$personnel_documents$paid_leave_order$Params = any;


interface StatusGroups$personnel_documents$certificate {
    readonly "__default": StatusItem$personnel_documents$certificate$__default;
}

type StatusItem$personnel_documents$certificate$__default = 'in_preparation' | 'on_signing' | 'on_correction' | 'done';

interface Application$personnel_documents$certificate$Data extends ItemData {
    "__file": TFile;
    "certificate_type": TApplication<Application$personnel_documents$handbook_of_certificates$Data, Application$personnel_documents$handbook_of_certificates$Params, Application$personnel_documents$handbook_of_certificates$Processes>;
    "responsible": TUser;
    "requester_comment": TString;
    "supplementary_files": TFile[];
    "requested_issuance_date": TDate;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "line_status": TString;
    "line_file_name": TString;
    "responsible_string": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$certificate$__default, StatusGroups$personnel_documents$certificate>;
}

interface Application$personnel_documents$certificate$Processes extends Processes {
    /**
     * Выдача справки
     */
    "certificate_issuance": Process$personnel_documents$certificate$certificate_issuance<ProcessContext$personnel_documents$certificate$certificate_issuance>;
}

interface Application$personnel_documents$certificate extends Application<
        Application$personnel_documents$certificate$Data,
        Application$personnel_documents$certificate$Params,
        Application$personnel_documents$certificate$Processes
    > {
}
type Application$personnel_documents$certificate$Params = any;


interface StatusGroups$personnel_documents$setlement_sheet {
    readonly "__default": StatusItem$personnel_documents$setlement_sheet$__default;
}

type StatusItem$personnel_documents$setlement_sheet$__default = 'new' | 'agrement' | 'signed';

interface Application$personnel_documents$setlement_sheet$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$setlement_sheet$__default, StatusGroups$personnel_documents$setlement_sheet>;
}

interface Application$personnel_documents$setlement_sheet$Processes extends Processes {
    /**
     * Ознакомление сотрудника с расчетным листом
     */
    "introduction_to_payroll": Process$personnel_documents$setlement_sheet$introduction_to_payroll<ProcessContext$personnel_documents$setlement_sheet$introduction_to_payroll>;
}

interface Application$personnel_documents$setlement_sheet extends Application<
        Application$personnel_documents$setlement_sheet$Data,
        Application$personnel_documents$setlement_sheet$Params,
        Application$personnel_documents$setlement_sheet$Processes
    > {
}
type Application$personnel_documents$setlement_sheet$Params = any;


interface StatusGroups$personnel_documents$benefit_application {
    readonly "__default": StatusItem$personnel_documents$benefit_application$__default;
}

type StatusItem$personnel_documents$benefit_application$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$personnel_documents$benefit_application$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "type_of_allowance": TApplication<Application$personnel_documents$handbook_of_benefits$Data, Application$personnel_documents$handbook_of_benefits$Params, Application$personnel_documents$handbook_of_benefits$Processes>;
    "required_files": TFile;
    "start_date": TDate;
    "expiration_date": TDate;
    "childs_name": TFullName;
    "date_of_birth": TDate;
    "name_of_the_deceased": TFullName;
    "date_of_accident": TDatetime;
    "entity": TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "investigators": TUser[];
    "general_work_experience": TString;
    "entity_service": TString;
    "conducted_briefing": TBoolean;
    "conducted_an_internship": TBoolean;
    "start_internship": TDate;
    "end_internship": TDate;
    "labor_protection_training": TBoolean;
    "education_start": TDate;
    "education_end": TDate;
    "description_place": TString;
    "circumstances_of_the_accident": TString;
    "type_of_incident": TString;
    "nature_damage_received": TString;
    "eyewitnesses_accident": TString;
    "causes_of_the_accident": TString;
    "persons_who_violated": TString;
    "measures_eliminate_accident": TString;
    "employee_comment": TString;
    "benefit_application": TApplication<Application$personnel_documents$benefit_application$Data, Application$personnel_documents$benefit_application$Params, Application$personnel_documents$benefit_application$Processes>;
    "line_file_name": TString;
    "line_status": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$benefit_application$__default, StatusGroups$personnel_documents$benefit_application>;
}

interface Application$personnel_documents$benefit_application$Processes extends Processes {
    /**
     * Оформление пособия
     */
    "benefit_processing": Process$personnel_documents$benefit_application$benefit_processing<ProcessContext$personnel_documents$benefit_application$benefit_processing>;
}

interface Application$personnel_documents$benefit_application extends Application<
        Application$personnel_documents$benefit_application$Data,
        Application$personnel_documents$benefit_application$Params,
        Application$personnel_documents$benefit_application$Processes
    > {
}
type Application$personnel_documents$benefit_application$Params = any;


interface StatusGroups$personnel_documents$order_financial_assistance {
    readonly "__default": StatusItem$personnel_documents$order_financial_assistance$__default;
}

type StatusItem$personnel_documents$order_financial_assistance$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'rejected';

interface Application$personnel_documents$order_financial_assistance$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_file_name": TString;
    "line_status": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$order_financial_assistance$__default, StatusGroups$personnel_documents$order_financial_assistance>;
}

interface Application$personnel_documents$order_financial_assistance$Processes extends Processes {
}

interface Application$personnel_documents$order_financial_assistance extends Application<
        Application$personnel_documents$order_financial_assistance$Data,
        Application$personnel_documents$order_financial_assistance$Params,
        Application$personnel_documents$order_financial_assistance$Processes
    > {
}
type Application$personnel_documents$order_financial_assistance$Params = any;


interface StatusGroups$personnel_documents$paid_leave {
    readonly "__default": StatusItem$personnel_documents$paid_leave$__default;
}

type StatusItem$personnel_documents$paid_leave$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$personnel_documents$paid_leave$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "linked_order": TApplication<Application$personnel_documents$paid_leave_order$Data, Application$personnel_documents$paid_leave_order$Params, Application$personnel_documents$paid_leave_order$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "start_date": TDate;
    "end_date": TDate;
    "duration": TFloat;
    "working_period_from": TDate;
    "working_period_of_work_for": TDate;
    "line_file_name": TString;
    "line_status": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$paid_leave$__default, StatusGroups$personnel_documents$paid_leave>;
}

interface Application$personnel_documents$paid_leave$Processes extends Processes {
}

interface Application$personnel_documents$paid_leave extends Application<
        Application$personnel_documents$paid_leave$Data,
        Application$personnel_documents$paid_leave$Params,
        Application$personnel_documents$paid_leave$Processes
    > {
}
type Application$personnel_documents$paid_leave$Params = any;

interface Application$personnel_documents$directory_of_types_of_material_assistance$Data extends ItemData {
    "__name": TString;
    "list_of_required_documents": TString;
    "sum": TMoney<'RUB'>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$personnel_documents$directory_of_types_of_material_assistance$Processes extends Processes {
}

interface Application$personnel_documents$directory_of_types_of_material_assistance extends Application<
        Application$personnel_documents$directory_of_types_of_material_assistance$Data,
        Application$personnel_documents$directory_of_types_of_material_assistance$Params,
        Application$personnel_documents$directory_of_types_of_material_assistance$Processes
    > {
}
type Application$personnel_documents$directory_of_types_of_material_assistance$Params = any;


interface StatusGroups$personnel_documents$application_for_leave_without_pay {
    readonly "__default": StatusItem$personnel_documents$application_for_leave_without_pay$__default;
}

type StatusItem$personnel_documents$application_for_leave_without_pay$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'rejected';

interface Application$personnel_documents$application_for_leave_without_pay$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "entity": TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "start_date": TDatetime;
    "end_date": TDatetime;
    "linked_order": TApplication<Application$personnel_documents$leave_without_pay$Data, Application$personnel_documents$leave_without_pay$Params, Application$personnel_documents$leave_without_pay$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "organizaion": TApplication<Application$kedo$organization$Data, Application$kedo$organization$Params, Application$kedo$organization$Processes>;
    "brief_comment": TString;
    "duration": TFloat;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$application_for_leave_without_pay$__default, StatusGroups$personnel_documents$application_for_leave_without_pay>;
}

interface Application$personnel_documents$application_for_leave_without_pay$Processes extends Processes {
}

interface Application$personnel_documents$application_for_leave_without_pay extends Application<
        Application$personnel_documents$application_for_leave_without_pay$Data,
        Application$personnel_documents$application_for_leave_without_pay$Params,
        Application$personnel_documents$application_for_leave_without_pay$Processes
    > {
}
type Application$personnel_documents$application_for_leave_without_pay$Params = any;


interface StatusGroups$personnel_documents$leave_without_pay {
    readonly "__default": StatusItem$personnel_documents$leave_without_pay$__default;
}

type StatusItem$personnel_documents$leave_without_pay$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'rejected';

interface Application$personnel_documents$leave_without_pay$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "entity": TApplication<Application$kedo$organization$Data, Application$kedo$organization$Params, Application$kedo$organization$Processes>;
    "personnel_number": TString;
    "start_date": TDatetime;
    "end_date": TDatetime;
    "duration": TFloat;
    "reason": TString;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$leave_without_pay$__default, StatusGroups$personnel_documents$leave_without_pay>;
}

interface Application$personnel_documents$leave_without_pay$Processes extends Processes {
}

interface Application$personnel_documents$leave_without_pay extends Application<
        Application$personnel_documents$leave_without_pay$Data,
        Application$personnel_documents$leave_without_pay$Params,
        Application$personnel_documents$leave_without_pay$Processes
    > {
}
type Application$personnel_documents$leave_without_pay$Params = any;


interface StatusGroups$personnel_documents$order_for_business_trip {
    readonly "__default": StatusItem$personnel_documents$order_for_business_trip$__default;
}

type StatusItem$personnel_documents$order_for_business_trip$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'rejected';

interface Application$personnel_documents$order_for_business_trip$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$order_for_business_trip$__default, StatusGroups$personnel_documents$order_for_business_trip>;
}

interface Application$personnel_documents$order_for_business_trip$Processes extends Processes {
}

interface Application$personnel_documents$order_for_business_trip extends Application<
        Application$personnel_documents$order_for_business_trip$Data,
        Application$personnel_documents$order_for_business_trip$Params,
        Application$personnel_documents$order_for_business_trip$Processes
    > {
}
type Application$personnel_documents$order_for_business_trip$Params = any;

type Enum$personnel_documents$handbook_of_benefits$initiators = 'staff'|'personnel_staff';

interface Application$personnel_documents$handbook_of_benefits$Data extends ItemData {
    "__name": TString;
    "initiators": TEnum<Enum$personnel_documents$handbook_of_benefits$initiators>[];
    "list_of_required_documents": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$personnel_documents$handbook_of_benefits$Processes extends Processes {
}

interface Application$personnel_documents$handbook_of_benefits extends Application<
        Application$personnel_documents$handbook_of_benefits$Data,
        Application$personnel_documents$handbook_of_benefits$Params,
        Application$personnel_documents$handbook_of_benefits$Processes
    > {
}
type Application$personnel_documents$handbook_of_benefits$Params = any;


interface StatusGroups$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account {
    readonly "__default": StatusItem$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$__default;
}

type StatusItem$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Data extends ItemData {
    "__file": TFile;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "personal_account": TString;
    "bank": TString;
    "correspondent_account": TString;
    "bik": TString;
    "inn": TString;
    "kpp": TString;
    "responsible": TString;
    "responsible_user": TUser;
    "line_file_name": TString;
    "line_status": TString;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$__default, StatusGroups$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account>;
}

interface Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Processes extends Processes {
    /**
     * Изменение расчётного счета для зп
     */
    "change_current_account_for_salary": Process$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$change_current_account_for_salary<ProcessContext$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$change_current_account_for_salary>;
}

interface Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account extends Application<
        Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Data,
        Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Params,
        Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Processes
    > {
}
type Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Params = any;


interface StatusGroups$personnel_documents$memo_business_trip {
    readonly "__default": StatusItem$personnel_documents$memo_business_trip$__default;
}

type StatusItem$personnel_documents$memo_business_trip$__default = 'new' | 'agrement' | 'signing' | 'signed' | 'removed';

interface Application$personnel_documents$memo_business_trip$Data extends ItemData {
    "__file": TFile;
    "responsible_user": TUser;
    "mission_trip": TString;
    "tasks_trip": TString;
    "start_date": TDate;
    "end_date": TDate;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "duration": TFloat;
    "linked_order": TApplication<Application$personnel_documents$order_for_business_trip$Data, Application$personnel_documents$order_for_business_trip$Params, Application$personnel_documents$order_for_business_trip$Processes>;
    "responsible": TString;
    "place_of_business_trip": TString;
    "line_status": TString;
    "line_file_name": TString;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$personnel_documents$memo_business_trip$__default, StatusGroups$personnel_documents$memo_business_trip>;
}

interface Application$personnel_documents$memo_business_trip$Processes extends Processes {
}

interface Application$personnel_documents$memo_business_trip extends Application<
        Application$personnel_documents$memo_business_trip$Data,
        Application$personnel_documents$memo_business_trip$Params,
        Application$personnel_documents$memo_business_trip$Processes
    > {
}
type Application$personnel_documents$memo_business_trip$Params = any;

interface Application$personnel_documents$personnel_documents$Data extends ItemData {
    "__id": TString;
    "__sourceRef": TRefItem;
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    "__name": TString;
    "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible": TString;
    "responsible_user": TUser;
    "line_status": TString;
    "line_file_name": TString;
}

interface Application$personnel_documents$personnel_documents$Processes extends Processes {
}

interface Application$personnel_documents$personnel_documents extends Application<
        Application$personnel_documents$personnel_documents$Data,
        Application$personnel_documents$personnel_documents$Params,
        Application$personnel_documents$personnel_documents$Processes
    > {
}
type Application$personnel_documents$personnel_documents$Params = any;

interface Processes$personnel_documents extends Processes {
    /**
     * Оповещение
     */
    "notification": Process$personnel_documents$notification<ProcessContext$personnel_documents$notification>;
    /**
     * Типовой бизнес-процесс(заявления)
     */
    "typical_business_process": Process$personnel_documents$typical_business_process<ProcessContext$personnel_documents$typical_business_process>;
    /**
     * Типовой бизнес-процесс(приказы)
     */
    "typical_business_process_orders": Process$personnel_documents$typical_business_process_orders<ProcessContext$personnel_documents$typical_business_process_orders>;
}
interface Namespace$personnel_documents extends NamespaceBase<Readonly<{
    "handbook_of_certificates": Application$personnel_documents$handbook_of_certificates;
    "application_for_financial_assistance": Application$personnel_documents$application_for_financial_assistance;
    "paid_leave_order": Application$personnel_documents$paid_leave_order;
    "certificate": Application$personnel_documents$certificate;
    "setlement_sheet": Application$personnel_documents$setlement_sheet;
    "benefit_application": Application$personnel_documents$benefit_application;
    "order_financial_assistance": Application$personnel_documents$order_financial_assistance;
    "paid_leave": Application$personnel_documents$paid_leave;
    "directory_of_types_of_material_assistance": Application$personnel_documents$directory_of_types_of_material_assistance;
    "application_for_leave_without_pay": Application$personnel_documents$application_for_leave_without_pay;
    "leave_without_pay": Application$personnel_documents$leave_without_pay;
    "order_for_business_trip": Application$personnel_documents$order_for_business_trip;
    "handbook_of_benefits": Application$personnel_documents$handbook_of_benefits;
    "application_for_the_transfer_of_salary_to_the_current_account": Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account;
    "memo_business_trip": Application$personnel_documents$memo_business_trip;
    "personnel_documents": Application$personnel_documents$personnel_documents;
}>> {
    readonly processes: Processes$personnel_documents;
}

interface Namespace$razdel_dlya_testov extends NamespaceBase<Readonly<{
}>> {
}


interface StatusGroups$realestate$land {
    readonly "__default": StatusItem$realestate$land$__default;
}

type StatusItem$realestate$land$__default = 'svoboden' | 'zabronirovan' | 'prodan';

interface Application$realestate$land$Data extends ItemData {
    "nomer": TString;
    "fail": TFile;
    "ploshad": TFloat;
    "adres": TString;
    "sdelki": TApplication<Application$_clients$_leads$Data, Application$_clients$_leads$Params, Application$_clients$_leads$Processes>[];
    "stoimost": TMoney<'RUB'>;
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
    readonly "__status": TStatus<StatusItem$realestate$land$__default, StatusGroups$realestate$land>;
}

interface Application$realestate$land$Processes extends Processes {
}

interface Application$realestate$land extends Application<
        Application$realestate$land$Data,
        Application$realestate$land$Params,
        Application$realestate$land$Processes
    > {
}
type Application$realestate$land$Params = any;

interface Application$realestate$dogovor_na_pokupku_nedvizhimosti$Data extends ItemData {
    "__file": TFile;
    "__id": TString;
    "__name": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$realestate$dogovor_na_pokupku_nedvizhimosti$Processes extends Processes {
}

interface Application$realestate$dogovor_na_pokupku_nedvizhimosti extends Application<
        Application$realestate$dogovor_na_pokupku_nedvizhimosti$Data,
        Application$realestate$dogovor_na_pokupku_nedvizhimosti$Params,
        Application$realestate$dogovor_na_pokupku_nedvizhimosti$Processes
    > {
}
type Application$realestate$dogovor_na_pokupku_nedvizhimosti$Params = any;

interface Namespace$realestate extends NamespaceBase<Readonly<{
    "land": Application$realestate$land;
    "dogovor_na_pokupku_nedvizhimosti": Application$realestate$dogovor_na_pokupku_nedvizhimosti;
}>> {
}

interface Namespace$schedule extends NamespaceBase<Readonly<{
}>> {
}

interface Namespace$support extends NamespaceBase<Readonly<{
}>> {
}

interface Namespace$tasks extends NamespaceBase<Readonly<{
}>> {
}

interface Application$umbrella_corp$Products$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$umbrella_corp$Products$Processes extends Processes {
}

interface Application$umbrella_corp$Products extends Application<
        Application$umbrella_corp$Products$Data,
        Application$umbrella_corp$Products$Params,
        Application$umbrella_corp$Products$Processes
    > {
}
type Application$umbrella_corp$Products$Params = any;

interface Application$umbrella_corp$Mansions$Data extends ItemData {
    "__name": TString;
    "DateOfStartMission": TDatetime;
    "DateOfDestruction": TDatetime;
    "Description": TString;
    "Address": TString;
    "Fraction": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$umbrella_corp$Mansions$Processes extends Processes {
}

interface Application$umbrella_corp$Mansions extends Application<
        Application$umbrella_corp$Mansions$Data,
        Application$umbrella_corp$Mansions$Params,
        Application$umbrella_corp$Mansions$Processes
    > {
}
type Application$umbrella_corp$Mansions$Params = any;

interface Namespace$umbrella_corp extends NamespaceBase<Readonly<{
    "Products": Application$umbrella_corp$Products;
    "Mansions": Application$umbrella_corp$Mansions;
}>> {
}

interface Application$upravlenie_trebovaniyami$obekty$Data extends ItemData {
    "__name": TString;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$upravlenie_trebovaniyami$obekty$Processes extends Processes {
}

interface Application$upravlenie_trebovaniyami$obekty extends Application<
        Application$upravlenie_trebovaniyami$obekty$Data,
        Application$upravlenie_trebovaniyami$obekty$Params,
        Application$upravlenie_trebovaniyami$obekty$Processes
    > {
}
type Application$upravlenie_trebovaniyami$obekty$Params = any;



interface Table$upravlenie_trebovaniyami$trebovaniya$tablica_obektov$Row {
     "__count": TFloat;
     "__index": TFloat;
     "naimenovanie": TString;
     "identifikator": TString;
}

interface Table$upravlenie_trebovaniyami$trebovaniya$tablica_obektov$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "naimenovanie": Readonly<TString>;
    readonly "identifikator": Readonly<TString>;
}


interface Application$upravlenie_trebovaniyami$trebovaniya$Data extends ItemData {
    "__name": TString;
    "opisanie": TString;
    "data_vremya": TDatetime;
    "uchetnaya_zapis": TAccount<AccountType>[];
    "faily": TFile;
    "tablica_obektov": TTable<Table$upravlenie_trebovaniyami$trebovaniya$tablica_obektov$Row, Table$upravlenie_trebovaniyami$trebovaniya$tablica_obektov$Result>;
    "__id": TString;
    "__index": TFloat;
    "__tasks_earliest_duedate": TDatetime;
    "__tasks_performers": TUser[];
    "__createdAt": TDatetime;
    "__createdBy": TUser;
    "__updatedAt": TDatetime;
    "__updatedBy": TUser;
    "__deletedAt": TDatetime;
}

interface Application$upravlenie_trebovaniyami$trebovaniya$Processes extends Processes {
}

interface Application$upravlenie_trebovaniyami$trebovaniya extends Application<
        Application$upravlenie_trebovaniyami$trebovaniya$Data,
        Application$upravlenie_trebovaniyami$trebovaniya$Params,
        Application$upravlenie_trebovaniyami$trebovaniya$Processes
    > {
}
type Application$upravlenie_trebovaniyami$trebovaniya$Params = any;

interface Namespace$upravlenie_trebovaniyami extends NamespaceBase<Readonly<{
    "obekty": Application$upravlenie_trebovaniyami$obekty;
    "trebovaniya": Application$upravlenie_trebovaniyami$trebovaniya;
}>> {
}

interface Namespace$vneshnii_portal extends NamespaceBase<Readonly<{
}>> {
}

interface Process$payment$payment_request$payment_reconciliation<ProcessContext$payment$payment_request$payment_reconciliation extends ProcessContext> extends Process<ProcessContext$payment$payment_request$payment_reconciliation> {
    "context": ProcessContext$payment$payment_request$payment_reconciliation;
    run(context: Process$payment$payment_request$payment_reconciliation$Context$$Data): Promise<TString>;
}

interface ProcessContext$payment$payment_request$payment_reconciliation extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "payment_request"?: TApplication<Application$payment$payment_request$Data, Application$payment$payment_request$Params, Application$payment$payment_request$Processes>;
    "payment_amount"?: TMoney<'RUB'>;
    "invoice_date_string"?: TString;
    "payment_desired_date"?: TDate;
    "payee_partner"?: TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "payment_request_date"?: TDate;
    "payment_request_comment"?: TString;
    "payment_type"?: TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
    "hide_payment_reason_table"?: TBoolean;
    "hide_payee_employee"?: TBoolean;
    "hide_file_preview"?: TBoolean;
    "empty_date"?: TDate;
    "approver"?: TUser;
    "approver_comment"?: TString;
    "hide_payment_reason_file"?: TBoolean;
    "payment_aim"?: TApplication<Application$payment$payment_aim$Data, Application$payment$payment_aim$Params, Application$payment$payment_aim$Processes>;
    "payment_reason_file"?: TFile;
    "invoice_id"?: TString;
    "payment_reason_table"?: TTable<Table$payment$payment_request$payment_reconciliation$payment_reason_table$Row, Table$payment$payment_request$payment_reconciliation$payment_reason_table$Result>;
    "additional_approver_comment"?: TString;
    "invoice_date"?: TDate;
    "hide_payee_partner"?: TBoolean;
    "payee_employee"?: TUser;
    "hide_invoice_id"?: TBoolean;
    "hide_invoice_date"?: TBoolean;
    "additional_approver"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$payment$payment_request$payment_reconciliation$payment_reason_table$Row {
     "__count": TFloat;
     "name": TString;
     "amount": TFloat;
     "unit_sum": TMoney<'RUB'>;
     readonly "sum": Readonly<TMoney<'RUB'>>;
}

interface Table$payment$payment_request$payment_reconciliation$payment_reason_table$Result {
    readonly "__count": Readonly<TString>;
    readonly "name": Readonly<TString>;
    readonly "amount": Readonly<TString>;
    readonly "unit_sum": Readonly<TString>;
    readonly "sum": Readonly<TMoney<'RUB'>>;
}


interface Process$payment$payment_request$payment_reconciliation$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "payment_request"?: TApplication<Application$payment$payment_request$Data, Application$payment$payment_request$Params, Application$payment$payment_request$Processes>;
    "payment_amount"?: TMoney<'RUB'>;
    "invoice_date_string"?: TString;
    "payment_desired_date"?: TDate;
    "payee_partner"?: TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "payment_request_date"?: TDate;
    "payment_request_comment"?: TString;
    "payment_type"?: TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
    "hide_payment_reason_table"?: TBoolean;
    "hide_payee_employee"?: TBoolean;
    "hide_file_preview"?: TBoolean;
    "empty_date"?: TDate;
    "approver"?: TUser;
    "approver_comment"?: TString;
    "hide_payment_reason_file"?: TBoolean;
    "payment_aim"?: TApplication<Application$payment$payment_aim$Data, Application$payment$payment_aim$Params, Application$payment$payment_aim$Processes>;
    "payment_reason_file"?: TFile;
    "invoice_id"?: TString;
    "payment_reason_table"?: TTable<Table$payment$payment_request$payment_reconciliation$payment_reason_table$Row, Table$payment$payment_request$payment_reconciliation$payment_reason_table$Result>;
    "additional_approver_comment"?: TString;
    "invoice_date"?: TDate;
    "hide_payee_partner"?: TBoolean;
    "payee_employee"?: TUser;
    "hide_invoice_id"?: TBoolean;
    "hide_invoice_date"?: TBoolean;
    "additional_approver"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$business_trips$businesstrip_requests$businesstrip_prolongation<ProcessContext$business_trips$businesstrip_requests$businesstrip_prolongation extends ProcessContext> extends Process<ProcessContext$business_trips$businesstrip_requests$businesstrip_prolongation> {
    "context": ProcessContext$business_trips$businesstrip_requests$businesstrip_prolongation;
    run(context: Process$business_trips$businesstrip_requests$businesstrip_prolongation$Context$$Data): Promise<TString>;
}

interface ProcessContext$business_trips$businesstrip_requests$businesstrip_prolongation extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "reason_prolongation"?: TString;
    "head_user"?: TUser;
    "is_money_required"?: TBoolean;
    "additional_money"?: TMoney<'RUB'>;
    "businesstrip_requests"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "seconded"?: TUser;
    "comment_cancel"?: TString;
    "rejection_reason"?: TString;
    "new_money_request"?: TTable<Table$business_trips$businesstrip_requests$businesstrip_prolongation$new_money_request$Row, Table$business_trips$businesstrip_requests$businesstrip_prolongation$new_money_request$Result>;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "end_date"?: TDatetime;
    "monetary_policy_handbook"?: TApplication<Application$business_trips$monetary_policy_handbook$Data, Application$business_trips$monetary_policy_handbook$Params, Application$business_trips$monetary_policy_handbook$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$business_trips$businesstrip_requests$businesstrip_prolongation$new_money_request$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum_money": TMoney<'RUB'>;
     "requester": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
     "traveler_s_comment": TString;
}

interface Table$business_trips$businesstrip_requests$businesstrip_prolongation$new_money_request$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum_money": Readonly<TString>;
    readonly "requester": Readonly<TString>;
    readonly "traveler_s_comment": Readonly<TString>;
}


interface Process$business_trips$businesstrip_requests$businesstrip_prolongation$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "reason_prolongation"?: TString;
    "head_user"?: TUser;
    "is_money_required"?: TBoolean;
    "additional_money"?: TMoney<'RUB'>;
    "businesstrip_requests"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "seconded"?: TUser;
    "comment_cancel"?: TString;
    "rejection_reason"?: TString;
    "new_money_request"?: TTable<Table$business_trips$businesstrip_requests$businesstrip_prolongation$new_money_request$Row, Table$business_trips$businesstrip_requests$businesstrip_prolongation$new_money_request$Result>;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "end_date"?: TDatetime;
    "monetary_policy_handbook"?: TApplication<Application$business_trips$monetary_policy_handbook$Data, Application$business_trips$monetary_policy_handbook$Params, Application$business_trips$monetary_policy_handbook$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_clients$_opportunities$on_status_set_7<ProcessContext$_clients$_opportunities$on_status_set_7 extends ProcessContext> extends Process<ProcessContext$_clients$_opportunities$on_status_set_7> {
    "context": ProcessContext$_clients$_opportunities$on_status_set_7;
    run(context: Process$_clients$_opportunities$on_status_set_7$Context$$Data): Promise<TString>;
}

interface ProcessContext$_clients$_opportunities$on_status_set_7 extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "item"?: TApplication<Application$_clients$_opportunities$Data, Application$_clients$_opportunities$Params, Application$_clients$_opportunities$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_clients$_opportunities$on_status_set_7$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "item"?: TApplication<Application$_clients$_opportunities$Data, Application$_clients$_opportunities$Params, Application$_clients$_opportunities$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$payment$payment_request$payment_approval<ProcessContext$payment$payment_request$payment_approval extends ProcessContext> extends Process<ProcessContext$payment$payment_request$payment_approval> {
    "context": ProcessContext$payment$payment_request$payment_approval;
    run(context: Process$payment$payment_request$payment_approval$Context$$Data): Promise<TString>;
}

interface ProcessContext$payment$payment_request$payment_approval extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "payment_request_table_accountant"?: TTable<Table$payment$payment_request$payment_approval$payment_request_table_accountant$Row, Table$payment$payment_request$payment_approval$payment_request_table_accountant$Result>;
    "payment_request_table"?: TTable<Table$payment$payment_request$payment_approval$payment_request_table$Row, Table$payment$payment_request$payment_approval$payment_request_table$Result>;
    "daily_payment_users"?: TUser[];
    "cash_request_table"?: TTable<Table$payment$payment_request$payment_approval$cash_request_table$Row, Table$payment$payment_request$payment_approval$cash_request_table$Result>;
    "daily_payment"?: TApplication<Application$payment$daily_payment$Data, Application$payment$daily_payment$Params, Application$payment$daily_payment$Processes>;
    "paid_request_users"?: TUser[];
    "daily_payment_end"?: TDatetime;
    "daily_payment_start"?: TDatetime;
    "cash_request_table_accountant"?: TTable<Table$payment$payment_request$payment_approval$cash_request_table_accountant$Row, Table$payment$payment_request$payment_approval$cash_request_table_accountant$Result>;
    "payment_request_table_approver"?: TTable<Table$payment$payment_request$payment_approval$payment_request_table_approver$Row, Table$payment$payment_request$payment_approval$payment_request_table_approver$Result>;
    "refused_request_users"?: TUser[];
    "cash_request_table_approver"?: TTable<Table$payment$payment_request$payment_approval$cash_request_table_approver$Row, Table$payment$payment_request$payment_approval$cash_request_table_approver$Result>;
    "approved_request_users"?: TUser[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$payment$payment_request$payment_approval$payment_request_table_accountant$Row {
     "__count": TFloat;
     "daily_payment_request": TApplication<Application$payment$payment_request$Data, Application$payment$payment_request$Params, Application$payment$payment_request$Processes>;
     "payment_request_initiator": TUser;
     "payment_type": TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
     "payment_desired_date": TDate;
     "payment_amount": TMoney<'RUB'>;
     "payment_request_comment": TString;
     "paid": TBoolean;
}

interface Table$payment$payment_request$payment_approval$payment_request_table_accountant$Result {
    readonly "__count": Readonly<TString>;
    readonly "daily_payment_request": Readonly<TString>;
    readonly "payment_request_initiator": Readonly<TString>;
    readonly "payment_type": Readonly<TString>;
    readonly "payment_desired_date": Readonly<TString>;
    readonly "payment_amount": Readonly<TMoney<'RUB'>>;
    readonly "payment_request_comment": Readonly<TString>;
    readonly "paid": Readonly<TString>;
}




interface Table$payment$payment_request$payment_approval$payment_request_table$Row {
     "__count": TFloat;
     "daily_payment_request": TApplication<Application$payment$payment_request$Data, Application$payment$payment_request$Params, Application$payment$payment_request$Processes>;
     "payment_request_initiator": TUser;
     "payment_type": TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
     "payment_desired_date": TDate;
     "payment_amount": TMoney<'RUB'>;
     "payment_request_comment": TString;
}

interface Table$payment$payment_request$payment_approval$payment_request_table$Result {
    readonly "__count": Readonly<TString>;
    readonly "daily_payment_request": Readonly<TString>;
    readonly "payment_request_initiator": Readonly<TString>;
    readonly "payment_type": Readonly<TString>;
    readonly "payment_desired_date": Readonly<TString>;
    readonly "payment_amount": Readonly<TMoney<'RUB'>>;
    readonly "payment_request_comment": Readonly<TString>;
}




interface Table$payment$payment_request$payment_approval$cash_request_table$Row {
     "__count": TFloat;
     "daily_payment_request": TApplication<Application$payment$payment_request$Data, Application$payment$payment_request$Params, Application$payment$payment_request$Processes>;
     "payment_request_initiator": TUser;
     "payment_type": TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
     "payment_desired_date": TDate;
     "payment_amount": TMoney<'RUB'>;
     "payment_request_comment": TString;
}

interface Table$payment$payment_request$payment_approval$cash_request_table$Result {
    readonly "__count": Readonly<TString>;
    readonly "daily_payment_request": Readonly<TString>;
    readonly "payment_request_initiator": Readonly<TString>;
    readonly "payment_type": Readonly<TString>;
    readonly "payment_desired_date": Readonly<TString>;
    readonly "payment_amount": Readonly<TMoney<'RUB'>>;
    readonly "payment_request_comment": Readonly<TString>;
}




interface Table$payment$payment_request$payment_approval$cash_request_table_accountant$Row {
     "__count": TFloat;
     "daily_payment_request": TApplication<Application$payment$payment_request$Data, Application$payment$payment_request$Params, Application$payment$payment_request$Processes>;
     "payment_request_initiator": TUser;
     "payment_type": TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
     "payment_desired_date": TDate;
     "payment_amount": TMoney<'RUB'>;
     "payment_request_comment": TString;
     "paid": TBoolean;
}

interface Table$payment$payment_request$payment_approval$cash_request_table_accountant$Result {
    readonly "__count": Readonly<TString>;
    readonly "daily_payment_request": Readonly<TString>;
    readonly "payment_request_initiator": Readonly<TString>;
    readonly "payment_type": Readonly<TString>;
    readonly "payment_desired_date": Readonly<TString>;
    readonly "payment_amount": Readonly<TMoney<'RUB'>>;
    readonly "payment_request_comment": Readonly<TString>;
    readonly "paid": Readonly<TString>;
}




interface Table$payment$payment_request$payment_approval$payment_request_table_approver$Row {
     "__count": TFloat;
     "daily_payment_request": TApplication<Application$payment$payment_request$Data, Application$payment$payment_request$Params, Application$payment$payment_request$Processes>;
     "payment_request_initiator": TUser;
     "payment_type": TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
     "payment_desired_date": TDate;
     "payment_amount": TMoney<'RUB'>;
     "payment_request_comment": TString;
     "approve": TBoolean;
}

interface Table$payment$payment_request$payment_approval$payment_request_table_approver$Result {
    readonly "__count": Readonly<TString>;
    readonly "daily_payment_request": Readonly<TString>;
    readonly "payment_request_initiator": Readonly<TString>;
    readonly "payment_type": Readonly<TString>;
    readonly "payment_desired_date": Readonly<TString>;
    readonly "payment_amount": Readonly<TMoney<'RUB'>>;
    readonly "payment_request_comment": Readonly<TString>;
    readonly "approve": Readonly<TString>;
}




interface Table$payment$payment_request$payment_approval$cash_request_table_approver$Row {
     "__count": TFloat;
     "daily_payment_request": TApplication<Application$payment$payment_request$Data, Application$payment$payment_request$Params, Application$payment$payment_request$Processes>;
     "payment_request_initiator": TUser;
     "payment_type": TApplication<Application$payment$payment_type$Data, Application$payment$payment_type$Params, Application$payment$payment_type$Processes>;
     "payment_desired_date": TDate;
     "payment_amount": TMoney<'RUB'>;
     "payment_request_comment": TString;
     "approve": TBoolean;
}

interface Table$payment$payment_request$payment_approval$cash_request_table_approver$Result {
    readonly "__count": Readonly<TString>;
    readonly "daily_payment_request": Readonly<TString>;
    readonly "payment_request_initiator": Readonly<TString>;
    readonly "payment_type": Readonly<TString>;
    readonly "payment_desired_date": Readonly<TString>;
    readonly "payment_amount": Readonly<TMoney<'RUB'>>;
    readonly "payment_request_comment": Readonly<TString>;
    readonly "approve": Readonly<TString>;
}


interface Process$payment$payment_request$payment_approval$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "payment_request_table_accountant"?: TTable<Table$payment$payment_request$payment_approval$payment_request_table_accountant$Row, Table$payment$payment_request$payment_approval$payment_request_table_accountant$Result>;
    "payment_request_table"?: TTable<Table$payment$payment_request$payment_approval$payment_request_table$Row, Table$payment$payment_request$payment_approval$payment_request_table$Result>;
    "daily_payment_users"?: TUser[];
    "cash_request_table"?: TTable<Table$payment$payment_request$payment_approval$cash_request_table$Row, Table$payment$payment_request$payment_approval$cash_request_table$Result>;
    "daily_payment"?: TApplication<Application$payment$daily_payment$Data, Application$payment$daily_payment$Params, Application$payment$daily_payment$Processes>;
    "paid_request_users"?: TUser[];
    "daily_payment_end"?: TDatetime;
    "daily_payment_start"?: TDatetime;
    "cash_request_table_accountant"?: TTable<Table$payment$payment_request$payment_approval$cash_request_table_accountant$Row, Table$payment$payment_request$payment_approval$cash_request_table_accountant$Result>;
    "payment_request_table_approver"?: TTable<Table$payment$payment_request$payment_approval$payment_request_table_approver$Row, Table$payment$payment_request$payment_approval$payment_request_table_approver$Result>;
    "refused_request_users"?: TUser[];
    "cash_request_table_approver"?: TTable<Table$payment$payment_request$payment_approval$cash_request_table_approver$Row, Table$payment$payment_request$payment_approval$cash_request_table_approver$Result>;
    "approved_request_users"?: TUser[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kp$tovary_dlya_kp$podgotovka_kp_kovalenko<ProcessContext$kp$tovary_dlya_kp$podgotovka_kp_kovalenko extends ProcessContext> extends Process<ProcessContext$kp$tovary_dlya_kp$podgotovka_kp_kovalenko> {
    "context": ProcessContext$kp$tovary_dlya_kp$podgotovka_kp_kovalenko;
    run(context: Process$kp$tovary_dlya_kp$podgotovka_kp_kovalenko$Context$$Data): Promise<TString>;
}

interface ProcessContext$kp$tovary_dlya_kp$podgotovka_kp_kovalenko extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "tovary_dlya_kp"?: TApplication<Application$kp$tovary_dlya_kp$Data, Application$kp$tovary_dlya_kp$Params, Application$kp$tovary_dlya_kp$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kp$tovary_dlya_kp$podgotovka_kp_kovalenko$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "tovary_dlya_kp"?: TApplication<Application$kp$tovary_dlya_kp$Data, Application$kp$tovary_dlya_kp$Params, Application$kp$tovary_dlya_kp$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_clients$_leads$sdelka_po_prodazhe_nedvizhimosti<ProcessContext$_clients$_leads$sdelka_po_prodazhe_nedvizhimosti extends ProcessContext> extends Process<ProcessContext$_clients$_leads$sdelka_po_prodazhe_nedvizhimosti> {
    "context": ProcessContext$_clients$_leads$sdelka_po_prodazhe_nedvizhimosti;
    run(context: Process$_clients$_leads$sdelka_po_prodazhe_nedvizhimosti$Context$$Data): Promise<TString>;
}

interface ProcessContext$_clients$_leads$sdelka_po_prodazhe_nedvizhimosti extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_leads"?: TApplication<Application$_clients$_leads$Data, Application$_clients$_leads$Params, Application$_clients$_leads$Processes>;
    "manager"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_clients$_leads$sdelka_po_prodazhe_nedvizhimosti$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_leads"?: TApplication<Application$_clients$_leads$Data, Application$_clients$_leads$Params, Application$_clients$_leads$Processes>;
    "manager"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$create_appeal<ProcessContext$ServiceDesk$appeals$create_appeal extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$create_appeal> {
    "context": ProcessContext$ServiceDesk$appeals$create_appeal;
    run(context: Process$ServiceDesk$appeals$create_appeal$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$create_appeal extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "slaLevel"?: TApplication<Application$ServiceDesk$sla_level$Data, Application$ServiceDesk$sla_level$Params, Application$ServiceDesk$sla_level$Processes>;
    "planDecisionTime"?: TDatetime;
    "appealName"?: TString;
    "operatorGroup"?: TUser[];
    "executor"?: TUser;
    "service"?: TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "author"?: TUser;
    "routing"?: TApplication<Application$ServiceDesk$routing_types$Data, Application$ServiceDesk$routing_types$Params, Application$ServiceDesk$routing_types$Processes>;
    "autoRoute"?: TBoolean;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$create_appeal$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "slaLevel"?: TApplication<Application$ServiceDesk$sla_level$Data, Application$ServiceDesk$sla_level$Params, Application$ServiceDesk$sla_level$Processes>;
    "planDecisionTime"?: TDatetime;
    "appealName"?: TString;
    "operatorGroup"?: TUser[];
    "executor"?: TUser;
    "service"?: TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "author"?: TUser;
    "routing"?: TApplication<Application$ServiceDesk$routing_types$Data, Application$ServiceDesk$routing_types$Params, Application$ServiceDesk$routing_types$Processes>;
    "autoRoute"?: TBoolean;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$dokumenty$generaciya<ProcessContext$requirements_management$dokumenty$generaciya extends ProcessContext> extends Process<ProcessContext$requirements_management$dokumenty$generaciya> {
    "context": ProcessContext$requirements_management$dokumenty$generaciya;
    run(context: Process$requirements_management$dokumenty$generaciya$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$dokumenty$generaciya extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "tekst"?: TString;
    "file"?: TFile;
    "scope"?: TTable<Table$requirements_management$dokumenty$generaciya$scope$Row, Table$requirements_management$dokumenty$generaciya$scope$Result>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$requirements_management$dokumenty$generaciya$scope$Row {
     "__count": TFloat;
     "__index": TFloat;
     "nazvanie_razdela": TString;
     "trebovanie": TString;
}

interface Table$requirements_management$dokumenty$generaciya$scope$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "nazvanie_razdela": Readonly<TString>;
    readonly "trebovanie": Readonly<TString>;
}


interface Process$requirements_management$dokumenty$generaciya$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "tekst"?: TString;
    "file"?: TFile;
    "scope"?: TTable<Table$requirements_management$dokumenty$generaciya$scope$Row, Table$requirements_management$dokumenty$generaciya$scope$Result>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$business_trips$businesstrip_requests$money_processing<ProcessContext$business_trips$businesstrip_requests$money_processing extends ProcessContext> extends Process<ProcessContext$business_trips$businesstrip_requests$money_processing> {
    "context": ProcessContext$business_trips$businesstrip_requests$money_processing;
    run(context: Process$business_trips$businesstrip_requests$money_processing$Context$$Data): Promise<TString>;
}

interface ProcessContext$business_trips$businesstrip_requests$money_processing extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "post_employees"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>[];
    "need_cash"?: TBoolean;
    "new_money_request"?: TTable<Table$business_trips$businesstrip_requests$money_processing$new_money_request$Row, Table$business_trips$businesstrip_requests$money_processing$new_money_request$Result>;
    "money_recieving_date"?: TDatetime;
    "requested_expenses"?: TTable<Table$business_trips$businesstrip_requests$money_processing$requested_expenses$Row, Table$business_trips$businesstrip_requests$money_processing$requested_expenses$Result>;
    "office_manager"?: TUser;
    "additional_amount_request_office_manager"?: TTable<Table$business_trips$businesstrip_requests$money_processing$additional_amount_request_office_manager$Row, Table$business_trips$businesstrip_requests$money_processing$additional_amount_request_office_manager$Result>;
    "additional_money"?: TMoney<'RUB'>;
    "initial_receipt_funds"?: TBoolean;
    "businesstrip_requests"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "additional_request_for_funds"?: TTable<Table$business_trips$businesstrip_requests$money_processing$additional_request_for_funds$Row, Table$business_trips$businesstrip_requests$money_processing$additional_request_for_funds$Result>;
    "seconded"?: TUser[];
    "reason_cancel"?: TString;
    "travel_allowance"?: TMoney<'RUB'>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$business_trips$businesstrip_requests$money_processing$new_money_request$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum_money": TMoney<'RUB'>;
     "requester": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
     "comment": TString;
     "traveler_s_comment": TString;
     "index": TFloat;
}

interface Table$business_trips$businesstrip_requests$money_processing$new_money_request$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum_money": Readonly<TString>;
    readonly "requester": Readonly<TString>;
    readonly "comment": Readonly<TString>;
    readonly "traveler_s_comment": Readonly<TString>;
    readonly "index": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$money_processing$requested_expenses$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum_money": TMoney<'RUB'>;
     "money_requester": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
     "traveler_s_comment": TString;
     "comment": TString;
}

interface Table$business_trips$businesstrip_requests$money_processing$requested_expenses$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum_money": Readonly<TString>;
    readonly "money_requester": Readonly<TString>;
    readonly "traveler_s_comment": Readonly<TString>;
    readonly "comment": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$money_processing$additional_amount_request_office_manager$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum": TMoney<'RUB'>;
     "index": TFloat;
     "requester": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
     "comment": TString;
     "traveler_s_comment": TString;
}

interface Table$business_trips$businesstrip_requests$money_processing$additional_amount_request_office_manager$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum": Readonly<TString>;
    readonly "index": Readonly<TString>;
    readonly "requester": Readonly<TString>;
    readonly "comment": Readonly<TString>;
    readonly "traveler_s_comment": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$money_processing$additional_request_for_funds$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum": TMoney<'RUB'>;
     "requester": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
     "comment": TString;
     "traveler_s_comment": TString;
}

interface Table$business_trips$businesstrip_requests$money_processing$additional_request_for_funds$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum": Readonly<TString>;
    readonly "requester": Readonly<TString>;
    readonly "comment": Readonly<TString>;
    readonly "traveler_s_comment": Readonly<TString>;
}


interface Process$business_trips$businesstrip_requests$money_processing$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "post_employees"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>[];
    "need_cash"?: TBoolean;
    "new_money_request"?: TTable<Table$business_trips$businesstrip_requests$money_processing$new_money_request$Row, Table$business_trips$businesstrip_requests$money_processing$new_money_request$Result>;
    "money_recieving_date"?: TDatetime;
    "requested_expenses"?: TTable<Table$business_trips$businesstrip_requests$money_processing$requested_expenses$Row, Table$business_trips$businesstrip_requests$money_processing$requested_expenses$Result>;
    "office_manager"?: TUser;
    "additional_amount_request_office_manager"?: TTable<Table$business_trips$businesstrip_requests$money_processing$additional_amount_request_office_manager$Row, Table$business_trips$businesstrip_requests$money_processing$additional_amount_request_office_manager$Result>;
    "additional_money"?: TMoney<'RUB'>;
    "initial_receipt_funds"?: TBoolean;
    "businesstrip_requests"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "additional_request_for_funds"?: TTable<Table$business_trips$businesstrip_requests$money_processing$additional_request_for_funds$Row, Table$business_trips$businesstrip_requests$money_processing$additional_request_for_funds$Result>;
    "seconded"?: TUser[];
    "reason_cancel"?: TString;
    "travel_allowance"?: TMoney<'RUB'>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$business_trips$signing_process<ProcessContext$business_trips$signing_process extends ProcessContext> extends Process<ProcessContext$business_trips$signing_process> {
    "context": ProcessContext$business_trips$signing_process;
    run(context: Process$business_trips$signing_process$Context$$Data): Promise<TString>;
}

interface ProcessContext$business_trips$signing_process extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "notification"?: TEnum<Enum$business_trips$signing_process$notification>;
    "notification_text_for_sms"?: TString;
    "alert_url"?: TString;
    "user"?: TUser;
    "alert_head"?: TString;
    "alert_body"?: TString;
    "notification_text"?: TString;
    "topic_of_the_letter"?: TString;
    "note_file"?: TFile[];
    "employee"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$business_trips$signing_process$notification = 'email'|'sms'|'email_and_sms'|'without_notifications';

interface Process$business_trips$signing_process$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "notification"?: TEnum<Enum$business_trips$signing_process$notification>;
    "notification_text_for_sms"?: TString;
    "alert_url"?: TString;
    "user"?: TUser;
    "alert_head"?: TString;
    "alert_body"?: TString;
    "notification_text"?: TString;
    "topic_of_the_letter"?: TString;
    "note_file"?: TFile[];
    "employee"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$system$opoveshenie_o_zavershenii_poiska_dublei<ProcessContext$system$opoveshenie_o_zavershenii_poiska_dublei extends ProcessContext> extends Process<ProcessContext$system$opoveshenie_o_zavershenii_poiska_dublei> {
    "context": ProcessContext$system$opoveshenie_o_zavershenii_poiska_dublei;
    run(context: Process$system$opoveshenie_o_zavershenii_poiska_dublei$Context$$Data): Promise<TString>;
}

interface ProcessContext$system$opoveshenie_o_zavershenii_poiska_dublei extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "poluchatel"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$system$opoveshenie_o_zavershenii_poiska_dublei$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "poluchatel"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$system$opoveshenie_o_razryve_svyazi_s_messendzherom<ProcessContext$system$opoveshenie_o_razryve_svyazi_s_messendzherom extends ProcessContext> extends Process<ProcessContext$system$opoveshenie_o_razryve_svyazi_s_messendzherom> {
    "context": ProcessContext$system$opoveshenie_o_razryve_svyazi_s_messendzherom;
    run(context: Process$system$opoveshenie_o_razryve_svyazi_s_messendzherom$Context$$Data): Promise<TString>;
}

interface ProcessContext$system$opoveshenie_o_razryve_svyazi_s_messendzherom extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "nazvanie_integracii"?: TString;
    "tip_integracii"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$system$opoveshenie_o_razryve_svyazi_s_messendzherom$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "nazvanie_integracii"?: TString;
    "tip_integracii"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$system$task<ProcessContext$system$task extends ProcessContext> extends Process<ProcessContext$system$task> {
    "context": ProcessContext$system$task;
    run(context: Process$system$task$Context$$Data): Promise<TString>;
}

interface ProcessContext$system$task extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "start_date"?: TDatetime;
    "files"?: TFile[];
    "kontrol"?: TEnum<Enum$system$task$kontrol>;
    "rejected"?: TBoolean;
    "approverComment"?: TString;
    "participants"?: TUser[];
    "task_created"?: TBoolean;
    "end_date"?: TDatetime;
    "description"?: TString;
    "approver"?: TUser;
    "executor"?: TUser;
    "executorComment"?: TString;
    "impossible"?: TBoolean;
    "percent"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$system$task$kontrol = 'notify'|'task'|'none';

interface Process$system$task$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "start_date"?: TDatetime;
    "files"?: TFile[];
    "kontrol"?: TEnum<Enum$system$task$kontrol>;
    "rejected"?: TBoolean;
    "approverComment"?: TString;
    "participants"?: TUser[];
    "task_created"?: TBoolean;
    "end_date"?: TDatetime;
    "description"?: TString;
    "approver"?: TUser;
    "executor"?: TUser;
    "executorComment"?: TString;
    "impossible"?: TBoolean;
    "percent"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$system$inform<ProcessContext$system$inform extends ProcessContext> extends Process<ProcessContext$system$inform> {
    "context": ProcessContext$system$inform;
    run(context: Process$system$inform$Context$$Data): Promise<TString>;
}

interface ProcessContext$system$inform extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "receivers"?: TUser[];
    "inform_object"?: TRefItem;
    "isInform"?: TBoolean;
    "comment"?: TString;
    "informBefore"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$system$inform$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "receivers"?: TUser[];
    "inform_object"?: TRefItem;
    "isInform"?: TBoolean;
    "comment"?: TString;
    "informBefore"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$cbrf_dev$dev_tasks$podgotovka_i_soglasovanie_ft<ProcessContext$cbrf_dev$dev_tasks$podgotovka_i_soglasovanie_ft extends ProcessContext> extends Process<ProcessContext$cbrf_dev$dev_tasks$podgotovka_i_soglasovanie_ft> {
    "context": ProcessContext$cbrf_dev$dev_tasks$podgotovka_i_soglasovanie_ft;
    run(context: Process$cbrf_dev$dev_tasks$podgotovka_i_soglasovanie_ft$Context$$Data): Promise<TString>;
}

interface ProcessContext$cbrf_dev$dev_tasks$podgotovka_i_soglasovanie_ft extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "kommentarii_soglasuyushego"?: TString;
    "ft"?: TApplication<Application$cb_requirements$dokumenty$Data, Application$cb_requirements$dokumenty$Params, Application$cb_requirements$dokumenty$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$cbrf_dev$dev_tasks$podgotovka_i_soglasovanie_ft$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "kommentarii_soglasuyushego"?: TString;
    "ft"?: TApplication<Application$cb_requirements$dokumenty$Data, Application$cb_requirements$dokumenty$Params, Application$cb_requirements$dokumenty$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$trebovaniya$soglasovat<ProcessContext$requirements_management$trebovaniya$soglasovat extends ProcessContext> extends Process<ProcessContext$requirements_management$trebovaniya$soglasovat> {
    "context": ProcessContext$requirements_management$trebovaniya$soglasovat;
    run(context: Process$requirements_management$trebovaniya$soglasovat$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$trebovaniya$soglasovat extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$trebovaniya$soglasovat$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$service_department$it_incident$it_incident_processing<ProcessContext$service_department$it_incident$it_incident_processing extends ProcessContext> extends Process<ProcessContext$service_department$it_incident$it_incident_processing> {
    "context": ProcessContext$service_department$it_incident$it_incident_processing;
    run(context: Process$service_department$it_incident$it_incident_processing$Context$$Data): Promise<TString>;
}

interface ProcessContext$service_department$it_incident$it_incident_processing extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "work_done"?: TString;
    "initiator_feedback"?: TString;
    "executor"?: TUser;
    "target_completion_date"?: TDate;
    "responsible_comment"?: TString;
    "delay_reason"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$service_department$it_incident$it_incident_processing$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "work_done"?: TString;
    "initiator_feedback"?: TString;
    "executor"?: TUser;
    "target_completion_date"?: TDate;
    "responsible_comment"?: TString;
    "delay_reason"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$trebovaniya$massovo_soglasovat<ProcessContext$requirements_management$trebovaniya$massovo_soglasovat extends ProcessContext> extends Process<ProcessContext$requirements_management$trebovaniya$massovo_soglasovat> {
    "context": ProcessContext$requirements_management$trebovaniya$massovo_soglasovat;
    run(context: Process$requirements_management$trebovaniya$massovo_soglasovat$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$trebovaniya$massovo_soglasovat extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$trebovaniya$massovo_soglasovat$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_clients$_leads$_call<ProcessContext$_clients$_leads$_call extends ProcessContext> extends Process<ProcessContext$_clients$_leads$_call> {
    "context": ProcessContext$_clients$_leads$_call;
    run(context: Process$_clients$_leads$_call$Context$$Data): Promise<TString>;
}

interface ProcessContext$_clients$_leads$_call extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "statusComment"?: TString;
    "app_code"?: TString;
    "due_date"?: TDatetime;
    "executor_comment"?: TString;
    "failed_call_reason"?: TEnum<Enum$_clients$_leads$_call$failed_call_reason>;
    "item_ref"?: TRefItem;
    "executor"?: TUser;
    "attempts_number"?: TFloat;
    "plan_start"?: TDatetime;
    "show_in_calendar"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$_clients$_leads$_call$failed_call_reason = 'busy'|'unavailable'|'dial'|'closed';

interface Process$_clients$_leads$_call$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "statusComment"?: TString;
    "app_code"?: TString;
    "due_date"?: TDatetime;
    "executor_comment"?: TString;
    "failed_call_reason"?: TEnum<Enum$_clients$_leads$_call$failed_call_reason>;
    "item_ref"?: TRefItem;
    "executor"?: TUser;
    "attempts_number"?: TFloat;
    "plan_start"?: TDatetime;
    "show_in_calendar"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_clients$_opportunities$on_status_set_3<ProcessContext$_clients$_opportunities$on_status_set_3 extends ProcessContext> extends Process<ProcessContext$_clients$_opportunities$on_status_set_3> {
    "context": ProcessContext$_clients$_opportunities$on_status_set_3;
    run(context: Process$_clients$_opportunities$on_status_set_3$Context$$Data): Promise<TString>;
}

interface ProcessContext$_clients$_opportunities$on_status_set_3 extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "item"?: TApplication<Application$_clients$_opportunities$Data, Application$_clients$_opportunities$Params, Application$_clients$_opportunities$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_clients$_opportunities$on_status_set_3$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "item"?: TApplication<Application$_clients$_opportunities$Data, Application$_clients$_opportunities$Params, Application$_clients$_opportunities$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_clients$_qualification<ProcessContext$_clients$_qualification extends ProcessContext> extends Process<ProcessContext$_clients$_qualification> {
    "context": ProcessContext$_clients$_qualification;
    run(context: Process$_clients$_qualification$Context$$Data): Promise<TString>;
}

interface ProcessContext$_clients$_qualification extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "lead"?: TApplication<Application$_clients$_leads$Data, Application$_clients$_leads$Params, Application$_clients$_leads$Processes>;
    "company"?: TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "qualification_type"?: TEnum<Enum$_clients$_qualification$qualification_type>;
    "lead_funnel"?: TEnum<Enum$_clients$_qualification$lead_funnel>;
    "opportunity"?: TApplication<Application$_clients$_opportunities$Data, Application$_clients$_opportunities$Params, Application$_clients$_opportunities$Processes>;
    "industries"?: TApplication<Application$_clients$_industries$Data, Application$_clients$_industries$Params, Application$_clients$_industries$Processes>[];
    "contacts"?: TApplication<Application$_clients$_contacts$Data, Application$_clients$_contacts$Params, Application$_clients$_contacts$Processes>[];
    "qualified"?: TBoolean;
    "segment"?: TApplication<Application$_clients$_segments$Data, Application$_clients$_segments$Params, Application$_clients$_segments$Processes>;
    "from_start_form"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$_clients$_qualification$qualification_type = '_create_lead_and_company'|'_create_company';

type Enum$_clients$_qualification$lead_funnel = never;

interface Process$_clients$_qualification$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "lead"?: TApplication<Application$_clients$_leads$Data, Application$_clients$_leads$Params, Application$_clients$_leads$Processes>;
    "company"?: TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "qualification_type"?: TEnum<Enum$_clients$_qualification$qualification_type>;
    "lead_funnel"?: TEnum<Enum$_clients$_qualification$lead_funnel>;
    "opportunity"?: TApplication<Application$_clients$_opportunities$Data, Application$_clients$_opportunities$Params, Application$_clients$_opportunities$Processes>;
    "industries"?: TApplication<Application$_clients$_industries$Data, Application$_clients$_industries$Params, Application$_clients$_industries$Processes>[];
    "contacts"?: TApplication<Application$_clients$_contacts$Data, Application$_clients$_contacts$Params, Application$_clients$_contacts$Processes>[];
    "qualified"?: TBoolean;
    "segment"?: TApplication<Application$_clients$_segments$Data, Application$_clients$_segments$Params, Application$_clients$_segments$Processes>;
    "from_start_form"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_clients$_leads$_meeting<ProcessContext$_clients$_leads$_meeting extends ProcessContext> extends Process<ProcessContext$_clients$_leads$_meeting> {
    "context": ProcessContext$_clients$_leads$_meeting;
    run(context: Process$_clients$_leads$_meeting$Context$$Data): Promise<TString>;
}

interface ProcessContext$_clients$_leads$_meeting extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "participants"?: TUser[];
    "due_date"?: TDatetime;
    "end_at"?: TDatetime;
    "executor"?: TUser;
    "statusComment"?: TString;
    "item_ref"?: TRefItem;
    "plan_start"?: TDatetime;
    "plan_end"?: TDatetime;
    "executor_comment"?: TString;
    "show_in_calendar"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_clients$_leads$_meeting$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "participants"?: TUser[];
    "due_date"?: TDatetime;
    "end_at"?: TDatetime;
    "executor"?: TUser;
    "statusComment"?: TString;
    "item_ref"?: TRefItem;
    "plan_start"?: TDatetime;
    "plan_end"?: TDatetime;
    "executor_comment"?: TString;
    "show_in_calendar"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$service_department$maintenance_requests$maintenance_request_processing<ProcessContext$service_department$maintenance_requests$maintenance_request_processing extends ProcessContext> extends Process<ProcessContext$service_department$maintenance_requests$maintenance_request_processing> {
    "context": ProcessContext$service_department$maintenance_requests$maintenance_request_processing;
    run(context: Process$service_department$maintenance_requests$maintenance_request_processing$Context$$Data): Promise<TString>;
}

interface ProcessContext$service_department$maintenance_requests$maintenance_request_processing extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "target_completion_date"?: TDate;
    "refusal_reason"?: TString;
    "work_result"?: TString;
    "initiator_feedback"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$service_department$maintenance_requests$maintenance_request_processing$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "target_completion_date"?: TDate;
    "refusal_reason"?: TString;
    "work_result"?: TString;
    "initiator_feedback"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$the_dismissal_process<ProcessContext$kedo$staff$the_dismissal_process extends ProcessContext> extends Process<ProcessContext$kedo$staff$the_dismissal_process> {
    "context": ProcessContext$kedo$staff$the_dismissal_process;
    run(context: Process$kedo$staff$the_dismissal_process$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$the_dismissal_process extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "alert_body"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "external_user"?: TApplication<Application$_system_catalogs$_user_profiles$Data, Application$_system_catalogs$_user_profiles$Params, Application$_system_catalogs$_user_profiles$Processes>;
    "alert_title"?: TString;
    "responsible"?: TUser;
    "head_position"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "staff_user"?: TUser;
    "resignation_letter"?: TApplication<Application$kedo$letter_of_resignation$Data, Application$kedo$letter_of_resignation$Params, Application$kedo$letter_of_resignation$Processes>;
    "create_date"?: TDate;
    "reason_for_leaving"?: TString;
    "dismissal_order"?: TApplication<Application$kedo$dismissal_order$Data, Application$kedo$dismissal_order$Params, Application$kedo$dismissal_order$Processes>;
    "scan_signed_application"?: TFile;
    "date_of_dismissal"?: TDate;
    "comment"?: TString;
    "alert_text"?: TString;
    "labor_contract"?: TApplication<Application$kedo$labor_contract$Data, Application$kedo$labor_contract$Params, Application$kedo$labor_contract$Processes>;
    "document_file"?: TFile;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staff$the_dismissal_process$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "alert_body"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "external_user"?: TApplication<Application$_system_catalogs$_user_profiles$Data, Application$_system_catalogs$_user_profiles$Params, Application$_system_catalogs$_user_profiles$Processes>;
    "alert_title"?: TString;
    "responsible"?: TUser;
    "head_position"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "staff_user"?: TUser;
    "resignation_letter"?: TApplication<Application$kedo$letter_of_resignation$Data, Application$kedo$letter_of_resignation$Params, Application$kedo$letter_of_resignation$Processes>;
    "create_date"?: TDate;
    "reason_for_leaving"?: TString;
    "dismissal_order"?: TApplication<Application$kedo$dismissal_order$Data, Application$kedo$dismissal_order$Params, Application$kedo$dismissal_order$Processes>;
    "scan_signed_application"?: TFile;
    "date_of_dismissal"?: TDate;
    "comment"?: TString;
    "alert_text"?: TString;
    "labor_contract"?: TApplication<Application$kedo$labor_contract$Data, Application$kedo$labor_contract$Params, Application$kedo$labor_contract$Processes>;
    "document_file"?: TFile;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$trebovaniya$dobavit_pervuyu_versiyu<ProcessContext$requirements_management$trebovaniya$dobavit_pervuyu_versiyu extends ProcessContext> extends Process<ProcessContext$requirements_management$trebovaniya$dobavit_pervuyu_versiyu> {
    "context": ProcessContext$requirements_management$trebovaniya$dobavit_pervuyu_versiyu;
    run(context: Process$requirements_management$trebovaniya$dobavit_pervuyu_versiyu$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$trebovaniya$dobavit_pervuyu_versiyu extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$trebovaniya$dobavit_pervuyu_versiyu$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$service_department$equipment_request$equipment_request_execution<ProcessContext$service_department$equipment_request$equipment_request_execution extends ProcessContext> extends Process<ProcessContext$service_department$equipment_request$equipment_request_execution> {
    "context": ProcessContext$service_department$equipment_request$equipment_request_execution;
    run(context: Process$service_department$equipment_request$equipment_request_execution$Context$$Data): Promise<TString>;
}

interface ProcessContext$service_department$equipment_request$equipment_request_execution extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "it_comment"?: TString;
    "invoice_amount"?: TMoney<'RUB'>;
    "initiator_chief"?: TUser;
    "accountant_comment"?: TString;
    "invoice"?: TFile;
    "payment_date"?: TDate;
    "budget_owner_comment"?: TString;
    "chief_comment"?: TString;
    "it_responsible"?: TUser[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$service_department$equipment_request$equipment_request_execution$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "it_comment"?: TString;
    "invoice_amount"?: TMoney<'RUB'>;
    "initiator_chief"?: TUser;
    "accountant_comment"?: TString;
    "invoice"?: TFile;
    "payment_date"?: TDate;
    "budget_owner_comment"?: TString;
    "chief_comment"?: TString;
    "it_responsible"?: TUser[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$oco$application_registrarion_employee$application_registrarion_employee<ProcessContext$oco$application_registrarion_employee$application_registrarion_employee extends ProcessContext> extends Process<ProcessContext$oco$application_registrarion_employee$application_registrarion_employee> {
    "context": ProcessContext$oco$application_registrarion_employee$application_registrarion_employee;
    run(context: Process$oco$application_registrarion_employee$application_registrarion_employee$Context$$Data): Promise<TString>;
}

interface ProcessContext$oco$application_registrarion_employee$application_registrarion_employee extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "application_registrarion_employee"?: TApplication<Application$oco$application_registrarion_employee$Data, Application$oco$application_registrarion_employee$Params, Application$oco$application_registrarion_employee$Processes>;
    "coordinator_service"?: TUser;
    "responsible_employee"?: TUser;
    "appeal"?: TApplication<Application$oco$appeals$Data, Application$oco$appeals$Params, Application$oco$appeals$Processes>;
    "service"?: TApplication<Application$oco$service$Data, Application$oco$service$Params, Application$oco$service$Processes>;
    "trudozatraty"?: TApplication<Application$oco$records_cost$Data, Application$oco$records_cost$Params, Application$oco$records_cost$Processes>;
    "fakticheskie_trudozatraty"?: TFloat;
    "description"?: TString;
    "task_oco"?: TApplication<Application$oco$tasks_oco$Data, Application$oco$tasks_oco$Params, Application$oco$tasks_oco$Processes>;
    "setting_task"?: TApplication<Application$oco$sla$Data, Application$oco$sla$Params, Application$oco$sla$Processes>;
    "guid_process"?: TString;
    "sla_service"?: TFloat;
    "date_end_application"?: TDatetime;
    "current_data_and_time"?: TDatetime;
    "date_and_time_meeting"?: TDatetime;
    "comment_meeting"?: TString;
    "document_employee"?: TFile[];
    "number_new_employee"?: TString;
    "guid_employee_in_1C"?: TString;
    "data_priema"?: TDate;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$oco$application_registrarion_employee$application_registrarion_employee$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "application_registrarion_employee"?: TApplication<Application$oco$application_registrarion_employee$Data, Application$oco$application_registrarion_employee$Params, Application$oco$application_registrarion_employee$Processes>;
    "coordinator_service"?: TUser;
    "responsible_employee"?: TUser;
    "appeal"?: TApplication<Application$oco$appeals$Data, Application$oco$appeals$Params, Application$oco$appeals$Processes>;
    "service"?: TApplication<Application$oco$service$Data, Application$oco$service$Params, Application$oco$service$Processes>;
    "trudozatraty"?: TApplication<Application$oco$records_cost$Data, Application$oco$records_cost$Params, Application$oco$records_cost$Processes>;
    "fakticheskie_trudozatraty"?: TFloat;
    "description"?: TString;
    "task_oco"?: TApplication<Application$oco$tasks_oco$Data, Application$oco$tasks_oco$Params, Application$oco$tasks_oco$Processes>;
    "setting_task"?: TApplication<Application$oco$sla$Data, Application$oco$sla$Params, Application$oco$sla$Processes>;
    "guid_process"?: TString;
    "sla_service"?: TFloat;
    "date_end_application"?: TDatetime;
    "current_data_and_time"?: TDatetime;
    "date_and_time_meeting"?: TDatetime;
    "comment_meeting"?: TString;
    "document_employee"?: TFile[];
    "number_new_employee"?: TString;
    "guid_employee_in_1C"?: TString;
    "data_priema"?: TDate;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kp$kp_forma_1$soglasovanie_kp_test1<ProcessContext$kp$kp_forma_1$soglasovanie_kp_test1 extends ProcessContext> extends Process<ProcessContext$kp$kp_forma_1$soglasovanie_kp_test1> {
    "context": ProcessContext$kp$kp_forma_1$soglasovanie_kp_test1;
    run(context: Process$kp$kp_forma_1$soglasovanie_kp_test1$Context$$Data): Promise<TString>;
}

interface ProcessContext$kp$kp_forma_1$soglasovanie_kp_test1 extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "kp_forma_1"?: TApplication<Application$kp$kp_forma_1$Data, Application$kp$kp_forma_1$Params, Application$kp$kp_forma_1$Processes>;
    "bukhgalterysoglasuyushie"?: TUser[];
    "viza_direktora"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kp$kp_forma_1$soglasovanie_kp_test1$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "kp_forma_1"?: TApplication<Application$kp$kp_forma_1$Data, Application$kp$kp_forma_1$Params, Application$kp$kp_forma_1$Processes>;
    "bukhgalterysoglasuyushie"?: TUser[];
    "viza_direktora"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_cashflow$add_income_item<ProcessContext$_cashflow$add_income_item extends ProcessContext> extends Process<ProcessContext$_cashflow$add_income_item> {
    "context": ProcessContext$_cashflow$add_income_item;
    run(context: Process$_cashflow$add_income_item$Context$$Data): Promise<TString>;
}

interface ProcessContext$_cashflow$add_income_item extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "received"?: TBoolean;
    "app"?: TRefItem;
    "createFact"?: TBoolean;
    "income"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "total"?: TFloat;
    "responsibilityCenter"?: TApplication<Application$_cashflow$_responsibilityCenter$Data, Application$_cashflow$_responsibilityCenter$Params, Application$_cashflow$_responsibilityCenter$Processes>;
    "planIncomeName"?: TString;
    "company"?: TRefItem;
    "responsible"?: TUser;
    "factName"?: TString;
    "cashFlowItem"?: TApplication<Application$_cashflow$_cash_flow_items$Data, Application$_cashflow$_cash_flow_items$Params, Application$_cashflow$_cash_flow_items$Processes>;
    "factPaymentDate"?: TDatetime;
    "description"?: TString;
    "paymentDate"?: TDatetime;
    "latePaymentRisk"?: TBoolean;
    "attachments"?: TFile[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_cashflow$add_income_item$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "received"?: TBoolean;
    "app"?: TRefItem;
    "createFact"?: TBoolean;
    "income"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "total"?: TFloat;
    "responsibilityCenter"?: TApplication<Application$_cashflow$_responsibilityCenter$Data, Application$_cashflow$_responsibilityCenter$Params, Application$_cashflow$_responsibilityCenter$Processes>;
    "planIncomeName"?: TString;
    "company"?: TRefItem;
    "responsible"?: TUser;
    "factName"?: TString;
    "cashFlowItem"?: TApplication<Application$_cashflow$_cash_flow_items$Data, Application$_cashflow$_cash_flow_items$Params, Application$_cashflow$_cash_flow_items$Processes>;
    "factPaymentDate"?: TDatetime;
    "description"?: TString;
    "paymentDate"?: TDatetime;
    "latePaymentRisk"?: TBoolean;
    "attachments"?: TFile[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$cmdb$changing_productivity_status<ProcessContext$ServiceDesk$cmdb$changing_productivity_status extends ProcessContext> extends Process<ProcessContext$ServiceDesk$cmdb$changing_productivity_status> {
    "context": ProcessContext$ServiceDesk$cmdb$changing_productivity_status;
    run(context: Process$ServiceDesk$cmdb$changing_productivity_status$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$cmdb$changing_productivity_status extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "changeChildProductivityStatus"?: TBoolean;
    "childsTable"?: TTable<Table$ServiceDesk$cmdb$changing_productivity_status$childsTable$Row, Table$ServiceDesk$cmdb$changing_productivity_status$childsTable$Result>;
    "cmdb"?: TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "productivityStatus"?: TEnum<Enum$ServiceDesk$cmdb$changing_productivity_status$productivityStatus>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$ServiceDesk$cmdb$changing_productivity_status$childsTable$Row {
     "__count": TFloat;
     "__index": TFloat;
     "cmdb": TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
     "id": TString;
     "materialResponsible": TUser;
     "status": TString;
     "childs": TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>[];
}

interface Table$ServiceDesk$cmdb$changing_productivity_status$childsTable$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "cmdb": Readonly<TString>;
    readonly "id": Readonly<TString>;
    readonly "materialResponsible": Readonly<TString>;
    readonly "status": Readonly<TString>;
    readonly "childs": Readonly<TString>;
}


type Enum$ServiceDesk$cmdb$changing_productivity_status$productivityStatus = 'work'|'unavailable'|'not_work';

interface Process$ServiceDesk$cmdb$changing_productivity_status$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "changeChildProductivityStatus"?: TBoolean;
    "childsTable"?: TTable<Table$ServiceDesk$cmdb$changing_productivity_status$childsTable$Row, Table$ServiceDesk$cmdb$changing_productivity_status$childsTable$Result>;
    "cmdb"?: TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "productivityStatus"?: TEnum<Enum$ServiceDesk$cmdb$changing_productivity_status$productivityStatus>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$personnel_documents$certificate$certificate_issuance<ProcessContext$personnel_documents$certificate$certificate_issuance extends ProcessContext> extends Process<ProcessContext$personnel_documents$certificate$certificate_issuance> {
    "context": ProcessContext$personnel_documents$certificate$certificate_issuance;
    run(context: Process$personnel_documents$certificate$certificate_issuance$Context$$Data): Promise<TString>;
}

interface ProcessContext$personnel_documents$certificate$certificate_issuance extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "certificate"?: TApplication<Application$personnel_documents$certificate$Data, Application$personnel_documents$certificate$Params, Application$personnel_documents$certificate$Processes>;
    "responsible"?: TUser[];
    "certificate_file"?: TFile;
    "alert_body"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "requested_issuance_date"?: TDate;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$personnel_documents$certificate$certificate_issuance$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "certificate"?: TApplication<Application$personnel_documents$certificate$Data, Application$personnel_documents$certificate$Params, Application$personnel_documents$certificate$Processes>;
    "responsible"?: TUser[];
    "certificate_file"?: TFile;
    "alert_body"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "requested_issuance_date"?: TDate;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$personnel_documents$notification<ProcessContext$personnel_documents$notification extends ProcessContext> extends Process<ProcessContext$personnel_documents$notification> {
    "context": ProcessContext$personnel_documents$notification;
    run(context: Process$personnel_documents$notification$Context$$Data): Promise<TString>;
}

interface ProcessContext$personnel_documents$notification extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "notification"?: TEnum<Enum$personnel_documents$notification$notification>;
    "portal_link"?: TString;
    "user"?: TUser;
    "button_name"?: TString;
    "alert_head"?: TString;
    "alert_body"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "notification_text"?: TString;
    "notification_text_for_sms"?: TString;
    "alert_url"?: TString;
    "topic_of_the_letter"?: TString;
    "note_file"?: TFile[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$personnel_documents$notification$notification = 'email'|'sms'|'email_and_sms'|'without_notifications';

interface Process$personnel_documents$notification$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "notification"?: TEnum<Enum$personnel_documents$notification$notification>;
    "portal_link"?: TString;
    "user"?: TUser;
    "button_name"?: TString;
    "alert_head"?: TString;
    "alert_body"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "notification_text"?: TString;
    "notification_text_for_sms"?: TString;
    "alert_url"?: TString;
    "topic_of_the_letter"?: TString;
    "note_file"?: TFile[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$personnel_documents$typical_business_process<ProcessContext$personnel_documents$typical_business_process extends ProcessContext> extends Process<ProcessContext$personnel_documents$typical_business_process> {
    "context": ProcessContext$personnel_documents$typical_business_process;
    run(context: Process$personnel_documents$typical_business_process$Context$$Data): Promise<TString>;
}

interface ProcessContext$personnel_documents$typical_business_process extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "document_file"?: TFile;
    "test123"?: TString;
    "user"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "signatory_position"?: TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "decree"?: TRefItem;
    "business_trip"?: TApplication<Application$personnel_documents$memo_business_trip$Data, Application$personnel_documents$memo_business_trip$Params, Application$personnel_documents$memo_business_trip$Processes>;
    "application_for_transfer_to_account"?: TApplication<Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Data, Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Params, Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Processes>;
    "position"?: TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "order_for_business_trip"?: TApplication<Application$personnel_documents$order_for_business_trip$Data, Application$personnel_documents$order_for_business_trip$Params, Application$personnel_documents$order_for_business_trip$Processes>;
    "paid_leave_order"?: TApplication<Application$personnel_documents$paid_leave_order$Data, Application$personnel_documents$paid_leave_order$Params, Application$personnel_documents$paid_leave_order$Processes>;
    "employee_user"?: TUser;
    "order_leave_without_pay"?: TApplication<Application$personnel_documents$leave_without_pay$Data, Application$personnel_documents$leave_without_pay$Params, Application$personnel_documents$leave_without_pay$Processes>;
    "entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "order_financial_assistance"?: TApplication<Application$personnel_documents$order_financial_assistance$Data, Application$personnel_documents$order_financial_assistance$Params, Application$personnel_documents$order_financial_assistance$Processes>;
    "current_date"?: TDate;
    "template_file"?: TFile;
    "is_registration_possible"?: TBoolean;
    "app"?: TRefItem;
    "leavle_application"?: TApplication<Application$personnel_documents$paid_leave$Data, Application$personnel_documents$paid_leave$Params, Application$personnel_documents$paid_leave$Processes>;
    "directory_of_types_of_material_assistance"?: TApplication<Application$personnel_documents$directory_of_types_of_material_assistance$Data, Application$personnel_documents$directory_of_types_of_material_assistance$Params, Application$personnel_documents$directory_of_types_of_material_assistance$Processes>;
    "signatories"?: TUser;
    "responsible"?: TUser;
    "alert_body"?: TString;
    "leave_application_withoutpay"?: TApplication<Application$personnel_documents$application_for_leave_without_pay$Data, Application$personnel_documents$application_for_leave_without_pay$Params, Application$personnel_documents$application_for_leave_without_pay$Processes>;
    "responsible_full_name"?: TString;
    "comment"?: TString;
    "benefit_application"?: TApplication<Application$personnel_documents$benefit_application$Data, Application$personnel_documents$benefit_application$Params, Application$personnel_documents$benefit_application$Processes>;
    "director"?: TUser;
    "head_user"?: TUser;
    "financial_assistance_application"?: TApplication<Application$personnel_documents$application_for_financial_assistance$Data, Application$personnel_documents$application_for_financial_assistance$Params, Application$personnel_documents$application_for_financial_assistance$Processes>;
    "settlement_sheet"?: TApplication<Application$personnel_documents$setlement_sheet$Data, Application$personnel_documents$setlement_sheet$Params, Application$personnel_documents$setlement_sheet$Processes>;
    "personnel_documents"?: TApplication<Application$personnel_documents$personnel_documents$Data, Application$personnel_documents$personnel_documents$Params, Application$personnel_documents$personnel_documents$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$personnel_documents$typical_business_process$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "document_file"?: TFile;
    "test123"?: TString;
    "user"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "signatory_position"?: TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "decree"?: TRefItem;
    "business_trip"?: TApplication<Application$personnel_documents$memo_business_trip$Data, Application$personnel_documents$memo_business_trip$Params, Application$personnel_documents$memo_business_trip$Processes>;
    "application_for_transfer_to_account"?: TApplication<Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Data, Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Params, Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Processes>;
    "position"?: TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "order_for_business_trip"?: TApplication<Application$personnel_documents$order_for_business_trip$Data, Application$personnel_documents$order_for_business_trip$Params, Application$personnel_documents$order_for_business_trip$Processes>;
    "paid_leave_order"?: TApplication<Application$personnel_documents$paid_leave_order$Data, Application$personnel_documents$paid_leave_order$Params, Application$personnel_documents$paid_leave_order$Processes>;
    "employee_user"?: TUser;
    "order_leave_without_pay"?: TApplication<Application$personnel_documents$leave_without_pay$Data, Application$personnel_documents$leave_without_pay$Params, Application$personnel_documents$leave_without_pay$Processes>;
    "entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "order_financial_assistance"?: TApplication<Application$personnel_documents$order_financial_assistance$Data, Application$personnel_documents$order_financial_assistance$Params, Application$personnel_documents$order_financial_assistance$Processes>;
    "current_date"?: TDate;
    "template_file"?: TFile;
    "is_registration_possible"?: TBoolean;
    "app"?: TRefItem;
    "leavle_application"?: TApplication<Application$personnel_documents$paid_leave$Data, Application$personnel_documents$paid_leave$Params, Application$personnel_documents$paid_leave$Processes>;
    "directory_of_types_of_material_assistance"?: TApplication<Application$personnel_documents$directory_of_types_of_material_assistance$Data, Application$personnel_documents$directory_of_types_of_material_assistance$Params, Application$personnel_documents$directory_of_types_of_material_assistance$Processes>;
    "signatories"?: TUser;
    "responsible"?: TUser;
    "alert_body"?: TString;
    "leave_application_withoutpay"?: TApplication<Application$personnel_documents$application_for_leave_without_pay$Data, Application$personnel_documents$application_for_leave_without_pay$Params, Application$personnel_documents$application_for_leave_without_pay$Processes>;
    "responsible_full_name"?: TString;
    "comment"?: TString;
    "benefit_application"?: TApplication<Application$personnel_documents$benefit_application$Data, Application$personnel_documents$benefit_application$Params, Application$personnel_documents$benefit_application$Processes>;
    "director"?: TUser;
    "head_user"?: TUser;
    "financial_assistance_application"?: TApplication<Application$personnel_documents$application_for_financial_assistance$Data, Application$personnel_documents$application_for_financial_assistance$Params, Application$personnel_documents$application_for_financial_assistance$Processes>;
    "settlement_sheet"?: TApplication<Application$personnel_documents$setlement_sheet$Data, Application$personnel_documents$setlement_sheet$Params, Application$personnel_documents$setlement_sheet$Processes>;
    "personnel_documents"?: TApplication<Application$personnel_documents$personnel_documents$Data, Application$personnel_documents$personnel_documents$Params, Application$personnel_documents$personnel_documents$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$n07020214_formirovanie_soglasovanie_i_utverzhdenie_tekhnicheskikh_trebovanii<ProcessContext$requirements_management$n07020214_formirovanie_soglasovanie_i_utverzhdenie_tekhnicheskikh_trebovanii extends ProcessContext> extends Process<ProcessContext$requirements_management$n07020214_formirovanie_soglasovanie_i_utverzhdenie_tekhnicheskikh_trebovanii> {
    "context": ProcessContext$requirements_management$n07020214_formirovanie_soglasovanie_i_utverzhdenie_tekhnicheskikh_trebovanii;
    run(context: Process$requirements_management$n07020214_formirovanie_soglasovanie_i_utverzhdenie_tekhnicheskikh_trebovanii$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$n07020214_formirovanie_soglasovanie_i_utverzhdenie_tekhnicheskikh_trebovanii extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$n07020214_formirovanie_soglasovanie_i_utverzhdenie_tekhnicheskikh_trebovanii$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$n07020211_formirovanie_soglasovanie_i_utverzhdenie_funkcionalnykh_trebovanii_koncepcii_tekhnicheskogo_resheniya<ProcessContext$requirements_management$n07020211_formirovanie_soglasovanie_i_utverzhdenie_funkcionalnykh_trebovanii_koncepcii_tekhnicheskogo_resheniya extends ProcessContext> extends Process<ProcessContext$requirements_management$n07020211_formirovanie_soglasovanie_i_utverzhdenie_funkcionalnykh_trebovanii_koncepcii_tekhnicheskogo_resheniya> {
    "context": ProcessContext$requirements_management$n07020211_formirovanie_soglasovanie_i_utverzhdenie_funkcionalnykh_trebovanii_koncepcii_tekhnicheskogo_resheniya;
    run(context: Process$requirements_management$n07020211_formirovanie_soglasovanie_i_utverzhdenie_funkcionalnykh_trebovanii_koncepcii_tekhnicheskogo_resheniya$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$n07020211_formirovanie_soglasovanie_i_utverzhdenie_funkcionalnykh_trebovanii_koncepcii_tekhnicheskogo_resheniya extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$n07020211_formirovanie_soglasovanie_i_utverzhdenie_funkcionalnykh_trebovanii_koncepcii_tekhnicheskogo_resheniya$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$n07020213_formirovanie_soglasovanie_i_utverzhdenie_arkhitekturnogo_resheniya<ProcessContext$requirements_management$n07020213_formirovanie_soglasovanie_i_utverzhdenie_arkhitekturnogo_resheniya extends ProcessContext> extends Process<ProcessContext$requirements_management$n07020213_formirovanie_soglasovanie_i_utverzhdenie_arkhitekturnogo_resheniya> {
    "context": ProcessContext$requirements_management$n07020213_formirovanie_soglasovanie_i_utverzhdenie_arkhitekturnogo_resheniya;
    run(context: Process$requirements_management$n07020213_formirovanie_soglasovanie_i_utverzhdenie_arkhitekturnogo_resheniya$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$n07020213_formirovanie_soglasovanie_i_utverzhdenie_arkhitekturnogo_resheniya extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$n07020213_formirovanie_soglasovanie_i_utverzhdenie_arkhitekturnogo_resheniya$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacation_docs$sign_document<ProcessContext$absences$vacation_docs$sign_document extends ProcessContext> extends Process<ProcessContext$absences$vacation_docs$sign_document> {
    "context": ProcessContext$absences$vacation_docs$sign_document;
    run(context: Process$absences$vacation_docs$sign_document$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacation_docs$sign_document extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "vacation_docs"?: TApplication<Application$absences$vacation_docs$Data, Application$absences$vacation_docs$Params, Application$absences$vacation_docs$Processes>;
    "supervisor"?: TUser;
    "vacation"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "correction"?: TBoolean;
    "cancelled"?: TBoolean;
    "comment"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacation_docs$sign_document$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "vacation_docs"?: TApplication<Application$absences$vacation_docs$Data, Application$absences$vacation_docs$Params, Application$absences$vacation_docs$Processes>;
    "supervisor"?: TUser;
    "vacation"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "correction"?: TBoolean;
    "cancelled"?: TBoolean;
    "comment"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$n07020212_opredelenie_podkhodov_k_realizacii_ft_a_takzhe_sostava_sozdavaemykh_razvivaemykh_komponentov_its<ProcessContext$requirements_management$n07020212_opredelenie_podkhodov_k_realizacii_ft_a_takzhe_sostava_sozdavaemykh_razvivaemykh_komponentov_its extends ProcessContext> extends Process<ProcessContext$requirements_management$n07020212_opredelenie_podkhodov_k_realizacii_ft_a_takzhe_sostava_sozdavaemykh_razvivaemykh_komponentov_its> {
    "context": ProcessContext$requirements_management$n07020212_opredelenie_podkhodov_k_realizacii_ft_a_takzhe_sostava_sozdavaemykh_razvivaemykh_komponentov_its;
    run(context: Process$requirements_management$n07020212_opredelenie_podkhodov_k_realizacii_ft_a_takzhe_sostava_sozdavaemykh_razvivaemykh_komponentov_its$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$n07020212_opredelenie_podkhodov_k_realizacii_ft_a_takzhe_sostava_sozdavaemykh_razvivaemykh_komponentov_its extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$n07020212_opredelenie_podkhodov_k_realizacii_ft_a_takzhe_sostava_sozdavaemykh_razvivaemykh_komponentov_its$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$it_dev_requirements<ProcessContext$requirements_management$it_dev_requirements extends ProcessContext> extends Process<ProcessContext$requirements_management$it_dev_requirements> {
    "context": ProcessContext$requirements_management$it_dev_requirements;
    run(context: Process$requirements_management$it_dev_requirements$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$it_dev_requirements extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$it_dev_requirements$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$n0702023_upravlenie_peredachei_i_priemkoi_izmenenii<ProcessContext$requirements_management$n0702023_upravlenie_peredachei_i_priemkoi_izmenenii extends ProcessContext> extends Process<ProcessContext$requirements_management$n0702023_upravlenie_peredachei_i_priemkoi_izmenenii> {
    "context": ProcessContext$requirements_management$n0702023_upravlenie_peredachei_i_priemkoi_izmenenii;
    run(context: Process$requirements_management$n0702023_upravlenie_peredachei_i_priemkoi_izmenenii$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$n0702023_upravlenie_peredachei_i_priemkoi_izmenenii extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$n0702023_upravlenie_peredachei_i_priemkoi_izmenenii$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$it_dev_development<ProcessContext$requirements_management$it_dev_development extends ProcessContext> extends Process<ProcessContext$requirements_management$it_dev_development> {
    "context": ProcessContext$requirements_management$it_dev_development;
    run(context: Process$requirements_management$it_dev_development$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$it_dev_development extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$it_dev_development$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_cashflow$edit_income<ProcessContext$_cashflow$edit_income extends ProcessContext> extends Process<ProcessContext$_cashflow$edit_income> {
    "context": ProcessContext$_cashflow$edit_income;
    run(context: Process$_cashflow$edit_income$Context$$Data): Promise<TString>;
}

interface ProcessContext$_cashflow$edit_income extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "actualReceiptsAmount"?: TString;
    "paid"?: TBoolean;
    "description"?: TString;
    "name"?: TString;
    "attachments"?: TFile[];
    "cashFlowItem"?: TApplication<Application$_cashflow$_cash_flow_items$Data, Application$_cashflow$_cash_flow_items$Params, Application$_cashflow$_cash_flow_items$Processes>;
    "income"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "company"?: TRefItem;
    "app"?: TRefItem;
    "latePaymentRisk"?: TBoolean;
    "responsible"?: TUser;
    "amount"?: TFloat;
    "responsibilityCenter"?: TApplication<Application$_cashflow$_responsibilityCenter$Data, Application$_cashflow$_responsibilityCenter$Params, Application$_cashflow$_responsibilityCenter$Processes>;
    "paymentDate"?: TDatetime;
    "actualReceipts"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_cashflow$edit_income$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "actualReceiptsAmount"?: TString;
    "paid"?: TBoolean;
    "description"?: TString;
    "name"?: TString;
    "attachments"?: TFile[];
    "cashFlowItem"?: TApplication<Application$_cashflow$_cash_flow_items$Data, Application$_cashflow$_cash_flow_items$Params, Application$_cashflow$_cash_flow_items$Processes>;
    "income"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "company"?: TRefItem;
    "app"?: TRefItem;
    "latePaymentRisk"?: TBoolean;
    "responsible"?: TUser;
    "amount"?: TFloat;
    "responsibilityCenter"?: TApplication<Application$_cashflow$_responsibilityCenter$Data, Application$_cashflow$_responsibilityCenter$Params, Application$_cashflow$_responsibilityCenter$Processes>;
    "paymentDate"?: TDatetime;
    "actualReceipts"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_cashflow$create_income_fact<ProcessContext$_cashflow$create_income_fact extends ProcessContext> extends Process<ProcessContext$_cashflow$create_income_fact> {
    "context": ProcessContext$_cashflow$create_income_fact;
    run(context: Process$_cashflow$create_income_fact$Context$$Data): Promise<TString>;
}

interface ProcessContext$_cashflow$create_income_fact extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "fullAmount"?: TBoolean;
    "undistribAmount"?: TFloat;
    "name"?: TString;
    "planIncome"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "responsible"?: TUser;
    "description"?: TString;
    "paymentDate"?: TDatetime;
    "attachments"?: TFile[];
    "factIncome"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "cashFlowItem"?: TApplication<Application$_cashflow$_cash_flow_items$Data, Application$_cashflow$_cash_flow_items$Params, Application$_cashflow$_cash_flow_items$Processes>;
    "amount"?: TFloat;
    "company"?: TRefItem;
    "planUndistribAmount"?: TString;
    "responsibilityCenter"?: TApplication<Application$_cashflow$_responsibilityCenter$Data, Application$_cashflow$_responsibilityCenter$Params, Application$_cashflow$_responsibilityCenter$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_cashflow$create_income_fact$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "fullAmount"?: TBoolean;
    "undistribAmount"?: TFloat;
    "name"?: TString;
    "planIncome"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "responsible"?: TUser;
    "description"?: TString;
    "paymentDate"?: TDatetime;
    "attachments"?: TFile[];
    "factIncome"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "cashFlowItem"?: TApplication<Application$_cashflow$_cash_flow_items$Data, Application$_cashflow$_cash_flow_items$Params, Application$_cashflow$_cash_flow_items$Processes>;
    "amount"?: TFloat;
    "company"?: TRefItem;
    "planUndistribAmount"?: TString;
    "responsibilityCenter"?: TApplication<Application$_cashflow$_responsibilityCenter$Data, Application$_cashflow$_responsibilityCenter$Params, Application$_cashflow$_responsibilityCenter$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_cashflow$fact_distribution<ProcessContext$_cashflow$fact_distribution extends ProcessContext> extends Process<ProcessContext$_cashflow$fact_distribution> {
    "context": ProcessContext$_cashflow$fact_distribution;
    run(context: Process$_cashflow$fact_distribution$Context$$Data): Promise<TString>;
}

interface ProcessContext$_cashflow$fact_distribution extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "purpose"?: TString;
    "planIncome"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "cashFlowItem"?: TApplication<Application$_cashflow$_cash_flow_items$Data, Application$_cashflow$_cash_flow_items$Params, Application$_cashflow$_cash_flow_items$Processes>;
    "undistribAmount"?: TFloat;
    "company"?: TRefItem;
    "companyData"?: TString;
    "factTotalAmount"?: TFloat;
    "name"?: TString;
    "factReceipt"?: TApplication<Application$_cashflow$_transactions$Data, Application$_cashflow$_transactions$Params, Application$_cashflow$_transactions$Processes>;
    "app"?: TRefItem;
    "planUndistribAmount"?: TString;
    "attachments"?: TFile[];
    "fullReceiptAmount"?: TBoolean;
    "fullAmount"?: TBoolean;
    "responsible"?: TUser;
    "factUndistribAmount"?: TFloat;
    "transactionUndistribAmount"?: TString;
    "responsibilityCenter"?: TApplication<Application$_cashflow$_responsibilityCenter$Data, Application$_cashflow$_responsibilityCenter$Params, Application$_cashflow$_responsibilityCenter$Processes>;
    "paymentDate"?: TDatetime;
    "amount"?: TFloat;
    "factIncome"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_cashflow$fact_distribution$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "purpose"?: TString;
    "planIncome"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "cashFlowItem"?: TApplication<Application$_cashflow$_cash_flow_items$Data, Application$_cashflow$_cash_flow_items$Params, Application$_cashflow$_cash_flow_items$Processes>;
    "undistribAmount"?: TFloat;
    "company"?: TRefItem;
    "companyData"?: TString;
    "factTotalAmount"?: TFloat;
    "name"?: TString;
    "factReceipt"?: TApplication<Application$_cashflow$_transactions$Data, Application$_cashflow$_transactions$Params, Application$_cashflow$_transactions$Processes>;
    "app"?: TRefItem;
    "planUndistribAmount"?: TString;
    "attachments"?: TFile[];
    "fullReceiptAmount"?: TBoolean;
    "fullAmount"?: TBoolean;
    "responsible"?: TUser;
    "factUndistribAmount"?: TFloat;
    "transactionUndistribAmount"?: TString;
    "responsibilityCenter"?: TApplication<Application$_cashflow$_responsibilityCenter$Data, Application$_cashflow$_responsibilityCenter$Params, Application$_cashflow$_responsibilityCenter$Processes>;
    "paymentDate"?: TDatetime;
    "amount"?: TFloat;
    "factIncome"?: TApplication<Application$_cashflow$_income$Data, Application$_cashflow$_income$Params, Application$_cashflow$_income$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$requirements_management$it_development<ProcessContext$requirements_management$it_development extends ProcessContext> extends Process<ProcessContext$requirements_management$it_development> {
    "context": ProcessContext$requirements_management$it_development;
    run(context: Process$requirements_management$it_development$Context$$Data): Promise<TString>;
}

interface ProcessContext$requirements_management$it_development extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$requirements_management$it_development$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_cashflow$new_fact_notification<ProcessContext$_cashflow$new_fact_notification extends ProcessContext> extends Process<ProcessContext$_cashflow$new_fact_notification> {
    "context": ProcessContext$_cashflow$new_fact_notification;
    run(context: Process$_cashflow$new_fact_notification$Context$$Data): Promise<TString>;
}

interface ProcessContext$_cashflow$new_fact_notification extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "factReceipt"?: TApplication<Application$_cashflow$_transactions$Data, Application$_cashflow$_transactions$Params, Application$_cashflow$_transactions$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_cashflow$new_fact_notification$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "factReceipt"?: TApplication<Application$_cashflow$_transactions$Data, Application$_cashflow$_transactions$Params, Application$_cashflow$_transactions$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$business_trips$businesstrip_requests$business_trip_registration<ProcessContext$business_trips$businesstrip_requests$business_trip_registration extends ProcessContext> extends Process<ProcessContext$business_trips$businesstrip_requests$business_trip_registration> {
    "context": ProcessContext$business_trips$businesstrip_requests$business_trip_registration;
    run(context: Process$business_trips$businesstrip_requests$business_trip_registration$Context$$Data): Promise<TString>;
}

interface ProcessContext$business_trips$businesstrip_requests$business_trip_registration extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>[];
    "is_money_request"?: TBoolean;
    "end_date_trip"?: TDatetime;
    "other_approval_users"?: TUser[];
    "office_manager"?: TUser;
    "mandatory_approval_users"?: TUser[];
    "date_money_recieving"?: TDatetime;
    "order_for_a_business_trip"?: TApplication<Application$business_trips$order_for_a_business_trip$Data, Application$business_trips$order_for_a_business_trip$Params, Application$business_trips$order_for_a_business_trip$Processes>;
    "report_file"?: TFile;
    "type_of_funds"?: TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
    "need_a_ticket"?: TBoolean;
    "comment_approvals"?: TString;
    "mission_trip"?: TString;
    "Accountant"?: TUser;
    "application_file"?: TFile;
    "end_date"?: TDatetime;
    "tasks_trip"?: TString;
    "finance_report_table"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$finance_report_table$Row, Table$business_trips$businesstrip_requests$business_trip_registration$finance_report_table$Result>;
    "order_file"?: TFile;
    "comment_with_documents"?: TString;
    "head_user"?: TUser;
    "transport_tickets"?: TFile[];
    "alert_body"?: TString;
    "destination_city"?: TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
    "need_a_hotel"?: TBoolean;
    "employee_table"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$employee_table$Row, Table$business_trips$businesstrip_requests$business_trip_registration$employee_table$Result>;
    "need_cash"?: TBoolean;
    "director"?: TUser;
    "comanded"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>[];
    "trip_requests"?: TApplication<Application$business_trips$trip_requests$Data, Application$business_trips$trip_requests$Params, Application$business_trips$trip_requests$Processes>;
    "is_money_required"?: TBoolean;
    "travel_allowance"?: TMoney<'RUB'>;
    "trip_start_date"?: TDatetime;
    "fullname"?: TString;
    "new_money_request"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$new_money_request$Row, Table$business_trips$businesstrip_requests$business_trip_registration$new_money_request$Result>;
    "seconded"?: TUser[];
    "requested_expenses"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$requested_expenses$Row, Table$business_trips$businesstrip_requests$business_trip_registration$requested_expenses$Result>;
    "businesstrip_requests"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "debug"?: TString;
    "finance_report_file"?: TFile;
    "reason_prolongation"?: TString;
    "reporting_table_office"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$reporting_table_office$Row, Table$business_trips$businesstrip_requests$business_trip_registration$reporting_table_office$Result>;
    "days_report"?: TFloat;
    "hotels"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$hotels$Row, Table$business_trips$businesstrip_requests$business_trip_registration$hotels$Result>;
    "service_job_generation"?: TBoolean;
    "finance_report"?: TApplication<Application$business_trips$avansovyi_otchet$Data, Application$business_trips$avansovyi_otchet$Params, Application$business_trips$avansovyi_otchet$Processes>;
    "date_report"?: TDatetime;
    "route"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$route$Row, Table$business_trips$businesstrip_requests$business_trip_registration$route$Result>;
    "auto_report"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$business_trips$businesstrip_requests$business_trip_registration$finance_report_table$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum_money": TMoney<'RUB'>;
     "report_file": TFile[];
     "additional_documents": TFile[];
}

interface Table$business_trips$businesstrip_requests$business_trip_registration$finance_report_table$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum_money": Readonly<TString>;
    readonly "report_file": Readonly<TString>;
    readonly "additional_documents": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$business_trip_registration$employee_table$Row {
     "__count": TFloat;
     "__index": TFloat;
     "subdivision": TString;
     "position": TString;
     "destination_city": TString;
     "organization": TString;
     "start": TDate;
     "end": TDate;
     "duration": TFloat;
     "payer_organization": TString;
     "reason": TString;
}

interface Table$business_trips$businesstrip_requests$business_trip_registration$employee_table$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "subdivision": Readonly<TString>;
    readonly "position": Readonly<TString>;
    readonly "destination_city": Readonly<TString>;
    readonly "organization": Readonly<TString>;
    readonly "start": Readonly<TString>;
    readonly "end": Readonly<TString>;
    readonly "duration": Readonly<TString>;
    readonly "payer_organization": Readonly<TString>;
    readonly "reason": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$business_trip_registration$new_money_request$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum_money": TMoney<'RUB'>;
     "requester": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
     "traveler_s_comment": TString;
}

interface Table$business_trips$businesstrip_requests$business_trip_registration$new_money_request$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum_money": Readonly<TString>;
    readonly "requester": Readonly<TString>;
    readonly "traveler_s_comment": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$business_trip_registration$requested_expenses$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum_money": TMoney<'RUB'>;
     "money_requester": TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
     "traveler_s_comment": TString;
}

interface Table$business_trips$businesstrip_requests$business_trip_registration$requested_expenses$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum_money": Readonly<TString>;
    readonly "money_requester": Readonly<TString>;
    readonly "traveler_s_comment": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$business_trip_registration$reporting_table_office$Row {
     "__count": TFloat;
     "__index": TFloat;
     "type_of_funds": TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
     "sum_money": TMoney<'RUB'>;
     "accounting_documents": TFile[];
     "additional_files": TFile[];
}

interface Table$business_trips$businesstrip_requests$business_trip_registration$reporting_table_office$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "type_of_funds": Readonly<TString>;
    readonly "sum_money": Readonly<TString>;
    readonly "accounting_documents": Readonly<TString>;
    readonly "additional_files": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$business_trip_registration$hotels$Row {
     "__count": TFloat;
     "__index": TFloat;
     "city": TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
     "start_date_of_stay": TDate;
     "end_date_of_residence": TDate;
     "comment": TString;
}

interface Table$business_trips$businesstrip_requests$business_trip_registration$hotels$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "city": Readonly<TString>;
    readonly "start_date_of_stay": Readonly<TString>;
    readonly "end_date_of_residence": Readonly<TString>;
    readonly "comment": Readonly<TString>;
}




interface Table$business_trips$businesstrip_requests$business_trip_registration$route$Row {
     "__count": TFloat;
     "__index": TFloat;
     "departure_city": TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
     "departure_date": TDatetime;
     "arrival_city": TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
     "tip_transporta": TApplication<Application$business_trips$transport_type$Data, Application$business_trips$transport_type$Params, Application$business_trips$transport_type$Processes>;
}

interface Table$business_trips$businesstrip_requests$business_trip_registration$route$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "departure_city": Readonly<TString>;
    readonly "departure_date": Readonly<TString>;
    readonly "arrival_city": Readonly<TString>;
    readonly "tip_transporta": Readonly<TString>;
}


interface Process$business_trips$businesstrip_requests$business_trip_registration$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>[];
    "is_money_request"?: TBoolean;
    "end_date_trip"?: TDatetime;
    "other_approval_users"?: TUser[];
    "office_manager"?: TUser;
    "mandatory_approval_users"?: TUser[];
    "date_money_recieving"?: TDatetime;
    "order_for_a_business_trip"?: TApplication<Application$business_trips$order_for_a_business_trip$Data, Application$business_trips$order_for_a_business_trip$Params, Application$business_trips$order_for_a_business_trip$Processes>;
    "report_file"?: TFile;
    "type_of_funds"?: TApplication<Application$business_trips$types_of_funds$Data, Application$business_trips$types_of_funds$Params, Application$business_trips$types_of_funds$Processes>;
    "need_a_ticket"?: TBoolean;
    "comment_approvals"?: TString;
    "mission_trip"?: TString;
    "Accountant"?: TUser;
    "application_file"?: TFile;
    "end_date"?: TDatetime;
    "tasks_trip"?: TString;
    "finance_report_table"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$finance_report_table$Row, Table$business_trips$businesstrip_requests$business_trip_registration$finance_report_table$Result>;
    "order_file"?: TFile;
    "comment_with_documents"?: TString;
    "head_user"?: TUser;
    "transport_tickets"?: TFile[];
    "alert_body"?: TString;
    "destination_city"?: TApplication<Application$business_trips$goroda$Data, Application$business_trips$goroda$Params, Application$business_trips$goroda$Processes>;
    "need_a_hotel"?: TBoolean;
    "employee_table"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$employee_table$Row, Table$business_trips$businesstrip_requests$business_trip_registration$employee_table$Result>;
    "need_cash"?: TBoolean;
    "director"?: TUser;
    "comanded"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>[];
    "trip_requests"?: TApplication<Application$business_trips$trip_requests$Data, Application$business_trips$trip_requests$Params, Application$business_trips$trip_requests$Processes>;
    "is_money_required"?: TBoolean;
    "travel_allowance"?: TMoney<'RUB'>;
    "trip_start_date"?: TDatetime;
    "fullname"?: TString;
    "new_money_request"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$new_money_request$Row, Table$business_trips$businesstrip_requests$business_trip_registration$new_money_request$Result>;
    "seconded"?: TUser[];
    "requested_expenses"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$requested_expenses$Row, Table$business_trips$businesstrip_requests$business_trip_registration$requested_expenses$Result>;
    "businesstrip_requests"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "debug"?: TString;
    "finance_report_file"?: TFile;
    "reason_prolongation"?: TString;
    "reporting_table_office"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$reporting_table_office$Row, Table$business_trips$businesstrip_requests$business_trip_registration$reporting_table_office$Result>;
    "days_report"?: TFloat;
    "hotels"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$hotels$Row, Table$business_trips$businesstrip_requests$business_trip_registration$hotels$Result>;
    "service_job_generation"?: TBoolean;
    "finance_report"?: TApplication<Application$business_trips$avansovyi_otchet$Data, Application$business_trips$avansovyi_otchet$Params, Application$business_trips$avansovyi_otchet$Processes>;
    "date_report"?: TDatetime;
    "route"?: TTable<Table$business_trips$businesstrip_requests$business_trip_registration$route$Row, Table$business_trips$businesstrip_requests$business_trip_registration$route$Result>;
    "auto_report"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$trebovaniya$dokumenty$generaciya<ProcessContext$trebovaniya$dokumenty$generaciya extends ProcessContext> extends Process<ProcessContext$trebovaniya$dokumenty$generaciya> {
    "context": ProcessContext$trebovaniya$dokumenty$generaciya;
    run(context: Process$trebovaniya$dokumenty$generaciya$Context$$Data): Promise<TString>;
}

interface ProcessContext$trebovaniya$dokumenty$generaciya extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "tekst"?: TString;
    "file"?: TFile;
    "scope"?: TTable<Table$trebovaniya$dokumenty$generaciya$scope$Row, Table$trebovaniya$dokumenty$generaciya$scope$Result>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$trebovaniya$dokumenty$generaciya$scope$Row {
     "__count": TFloat;
     "__index": TFloat;
     "nazvanie_razdela": TString;
     "trebovanie": TString;
}

interface Table$trebovaniya$dokumenty$generaciya$scope$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "nazvanie_razdela": Readonly<TString>;
    readonly "trebovanie": Readonly<TString>;
}


interface Process$trebovaniya$dokumenty$generaciya$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "tekst"?: TString;
    "file"?: TFile;
    "scope"?: TTable<Table$trebovaniya$dokumenty$generaciya$scope$Row, Table$trebovaniya$dokumenty$generaciya$scope$Result>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$business_trips$businesstrip_requests$create_service_order<ProcessContext$business_trips$businesstrip_requests$create_service_order extends ProcessContext> extends Process<ProcessContext$business_trips$businesstrip_requests$create_service_order> {
    "context": ProcessContext$business_trips$businesstrip_requests$create_service_order;
    run(context: Process$business_trips$businesstrip_requests$create_service_order$Context$$Data): Promise<TString>;
}

interface ProcessContext$business_trips$businesstrip_requests$create_service_order extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "order_number"?: TString;
    "position"?: TString;
    "service_assignment"?: TApplication<Application$business_trips$service_assignments$Data, Application$business_trips$service_assignments$Params, Application$business_trips$service_assignments$Processes>;
    "head_user"?: TUser;
    "commanded"?: TUser;
    "current_date"?: TDate;
    "first_generation"?: TBoolean;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "service_order_file"?: TFile;
    "businesstrip_requests"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "subdivision"?: TString;
    "trip_requests"?: TApplication<Application$business_trips$trip_requests$Data, Application$business_trips$trip_requests$Params, Application$business_trips$trip_requests$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$business_trips$businesstrip_requests$create_service_order$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "order_number"?: TString;
    "position"?: TString;
    "service_assignment"?: TApplication<Application$business_trips$service_assignments$Data, Application$business_trips$service_assignments$Params, Application$business_trips$service_assignments$Processes>;
    "head_user"?: TUser;
    "commanded"?: TUser;
    "current_date"?: TDate;
    "first_generation"?: TBoolean;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "service_order_file"?: TFile;
    "businesstrip_requests"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "subdivision"?: TString;
    "trip_requests"?: TApplication<Application$business_trips$trip_requests$Data, Application$business_trips$trip_requests$Params, Application$business_trips$trip_requests$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$business_trips$order_for_a_business_trip$signing_the_order<ProcessContext$business_trips$order_for_a_business_trip$signing_the_order extends ProcessContext> extends Process<ProcessContext$business_trips$order_for_a_business_trip$signing_the_order> {
    "context": ProcessContext$business_trips$order_for_a_business_trip$signing_the_order;
    run(context: Process$business_trips$order_for_a_business_trip$signing_the_order$Context$$Data): Promise<TString>;
}

interface ProcessContext$business_trips$order_for_a_business_trip$signing_the_order extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "signatories"?: TUser;
    "head_user"?: TUser;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "commanded"?: TUser;
    "number_order"?: TString;
    "trip_requests"?: TApplication<Application$business_trips$trip_requests$Data, Application$business_trips$trip_requests$Params, Application$business_trips$trip_requests$Processes>;
    "travel_request"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "order_for_a_business_trip"?: TApplication<Application$business_trips$order_for_a_business_trip$Data, Application$business_trips$order_for_a_business_trip$Params, Application$business_trips$order_for_a_business_trip$Processes>;
    "structural_subdivision"?: TString;
    "current_date"?: TDate;
    "signatory_position"?: TString;
    "order_number"?: TFloat;
    "order_file"?: TFile;
    "position"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$business_trips$order_for_a_business_trip$signing_the_order$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "signatories"?: TUser;
    "head_user"?: TUser;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "commanded"?: TUser;
    "number_order"?: TString;
    "trip_requests"?: TApplication<Application$business_trips$trip_requests$Data, Application$business_trips$trip_requests$Params, Application$business_trips$trip_requests$Processes>;
    "travel_request"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "order_for_a_business_trip"?: TApplication<Application$business_trips$order_for_a_business_trip$Data, Application$business_trips$order_for_a_business_trip$Params, Application$business_trips$order_for_a_business_trip$Processes>;
    "structural_subdivision"?: TString;
    "current_date"?: TDate;
    "signatory_position"?: TString;
    "order_number"?: TFloat;
    "order_file"?: TFile;
    "position"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$trebovaniya$trebovaniya$soglasovat<ProcessContext$trebovaniya$trebovaniya$soglasovat extends ProcessContext> extends Process<ProcessContext$trebovaniya$trebovaniya$soglasovat> {
    "context": ProcessContext$trebovaniya$trebovaniya$soglasovat;
    run(context: Process$trebovaniya$trebovaniya$soglasovat$Context$$Data): Promise<TString>;
}

interface ProcessContext$trebovaniya$trebovaniya$soglasovat extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$trebovaniya$trebovaniya$soglasovat$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_project_management$_project$generate_by_template<ProcessContext$_project_management$_project$generate_by_template extends ProcessContext> extends Process<ProcessContext$_project_management$_project$generate_by_template> {
    "context": ProcessContext$_project_management$_project$generate_by_template;
    run(context: Process$_project_management$_project$generate_by_template$Context$$Data): Promise<TString>;
}

interface ProcessContext$_project_management$_project$generate_by_template extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_project"?: TApplication<Application$_project_management$_project$Data, Application$_project_management$_project$Params, Application$_project_management$_project$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_project_management$_project$generate_by_template$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_project"?: TApplication<Application$_project_management$_project$Data, Application$_project_management$_project$Params, Application$_project_management$_project$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_clients$_leads$_webinar<ProcessContext$_clients$_leads$_webinar extends ProcessContext> extends Process<ProcessContext$_clients$_leads$_webinar> {
    "context": ProcessContext$_clients$_leads$_webinar;
    run(context: Process$_clients$_leads$_webinar$Context$$Data): Promise<TString>;
}

interface ProcessContext$_clients$_leads$_webinar extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "executor"?: TUser;
    "statusComment"?: TString;
    "participants"?: TUser[];
    "plan_start"?: TDatetime;
    "due_date"?: TDatetime;
    "end_at"?: TDatetime;
    "executor_comment"?: TString;
    "item_ref"?: TRefItem;
    "plan_end"?: TDatetime;
    "show_in_calendar"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_clients$_leads$_webinar$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "executor"?: TUser;
    "statusComment"?: TString;
    "participants"?: TUser[];
    "plan_start"?: TDatetime;
    "due_date"?: TDatetime;
    "end_at"?: TDatetime;
    "executor_comment"?: TString;
    "item_ref"?: TRefItem;
    "plan_end"?: TDatetime;
    "show_in_calendar"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$business_trips$order_for_a_business_trip$order_signing<ProcessContext$business_trips$order_for_a_business_trip$order_signing extends ProcessContext> extends Process<ProcessContext$business_trips$order_for_a_business_trip$order_signing> {
    "context": ProcessContext$business_trips$order_for_a_business_trip$order_signing;
    run(context: Process$business_trips$order_for_a_business_trip$order_signing$Context$$Data): Promise<TString>;
}

interface ProcessContext$business_trips$order_for_a_business_trip$order_signing extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "travel_request"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "order_for_a_business_trip"?: TApplication<Application$business_trips$order_for_a_business_trip$Data, Application$business_trips$order_for_a_business_trip$Params, Application$business_trips$order_for_a_business_trip$Processes>;
    "signatories"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$business_trips$order_for_a_business_trip$order_signing$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "travel_request"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "order_for_a_business_trip"?: TApplication<Application$business_trips$order_for_a_business_trip$Data, Application$business_trips$order_for_a_business_trip$Params, Application$business_trips$order_for_a_business_trip$Processes>;
    "signatories"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$trebovaniya$trebovaniya$massovo_soglasovat<ProcessContext$trebovaniya$trebovaniya$massovo_soglasovat extends ProcessContext> extends Process<ProcessContext$trebovaniya$trebovaniya$massovo_soglasovat> {
    "context": ProcessContext$trebovaniya$trebovaniya$massovo_soglasovat;
    run(context: Process$trebovaniya$trebovaniya$massovo_soglasovat$Context$$Data): Promise<TString>;
}

interface ProcessContext$trebovaniya$trebovaniya$massovo_soglasovat extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$trebovaniya$trebovaniya$massovo_soglasovat$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$escalation_by_sla<ProcessContext$ServiceDesk$appeals$escalation_by_sla extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$escalation_by_sla> {
    "context": ProcessContext$ServiceDesk$appeals$escalation_by_sla;
    run(context: Process$ServiceDesk$appeals$escalation_by_sla$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$escalation_by_sla extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "leader"?: TUser;
    "index"?: TFloat;
    "appealsList"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>[];
    "manager"?: TUser;
    "currentAppeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "responsibleForAppeal"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$escalation_by_sla$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "leader"?: TUser;
    "index"?: TFloat;
    "appealsList"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>[];
    "manager"?: TUser;
    "currentAppeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "responsibleForAppeal"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$take_appeal_to_work<ProcessContext$ServiceDesk$appeals$take_appeal_to_work extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$take_appeal_to_work> {
    "context": ProcessContext$ServiceDesk$appeals$take_appeal_to_work;
    run(context: Process$ServiceDesk$appeals$take_appeal_to_work$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$take_appeal_to_work extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "currentTime"?: TDatetime;
    "comment"?: TString;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "reactionTime"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$take_appeal_to_work$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "currentTime"?: TDatetime;
    "comment"?: TString;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "reactionTime"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$business_trips$trip_requests$signing_the_application<ProcessContext$business_trips$trip_requests$signing_the_application extends ProcessContext> extends Process<ProcessContext$business_trips$trip_requests$signing_the_application> {
    "context": ProcessContext$business_trips$trip_requests$signing_the_application;
    run(context: Process$business_trips$trip_requests$signing_the_application$Context$$Data): Promise<TString>;
}

interface ProcessContext$business_trips$trip_requests$signing_the_application extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "current_date"?: TDate;
    "position"?: TString;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "seconded"?: TUser[];
    "trip_requests"?: TApplication<Application$business_trips$trip_requests$Data, Application$business_trips$trip_requests$Params, Application$business_trips$trip_requests$Processes>;
    "application_file"?: TFile;
    "travel_request"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$business_trips$trip_requests$signing_the_application$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "current_date"?: TDate;
    "position"?: TString;
    "staff"?: TApplication<Application$business_trips$staff$Data, Application$business_trips$staff$Params, Application$business_trips$staff$Processes>;
    "seconded"?: TUser[];
    "trip_requests"?: TApplication<Application$business_trips$trip_requests$Data, Application$business_trips$trip_requests$Params, Application$business_trips$trip_requests$Processes>;
    "application_file"?: TFile;
    "travel_request"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$trebovaniya$trebovaniya$dobavit_novuyu_versiyu<ProcessContext$trebovaniya$trebovaniya$dobavit_novuyu_versiyu extends ProcessContext> extends Process<ProcessContext$trebovaniya$trebovaniya$dobavit_novuyu_versiyu> {
    "context": ProcessContext$trebovaniya$trebovaniya$dobavit_novuyu_versiyu;
    run(context: Process$trebovaniya$trebovaniya$dobavit_novuyu_versiyu$Context$$Data): Promise<TString>;
}

interface ProcessContext$trebovaniya$trebovaniya$dobavit_novuyu_versiyu extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$trebovaniya$trebovaniya$dobavit_novuyu_versiyu$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$appoint_responsible<ProcessContext$ServiceDesk$appeals$appoint_responsible extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$appoint_responsible> {
    "context": ProcessContext$ServiceDesk$appeals$appoint_responsible;
    run(context: Process$ServiceDesk$appeals$appoint_responsible$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$appoint_responsible extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "responsible"?: TUser;
    "supportLevel"?: TApplication<Application$ServiceDesk$support_level$Data, Application$ServiceDesk$support_level$Params, Application$ServiceDesk$support_level$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$appoint_responsible$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "responsible"?: TUser;
    "supportLevel"?: TApplication<Application$ServiceDesk$support_level$Data, Application$ServiceDesk$support_level$Params, Application$ServiceDesk$support_level$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$transfer_to_level<ProcessContext$ServiceDesk$appeals$transfer_to_level extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$transfer_to_level> {
    "context": ProcessContext$ServiceDesk$appeals$transfer_to_level;
    run(context: Process$ServiceDesk$appeals$transfer_to_level$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$transfer_to_level extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "newSupervisor"?: TUser[];
    "groupId"?: TString;
    "level"?: TApplication<Application$ServiceDesk$support_level$Data, Application$ServiceDesk$support_level$Params, Application$ServiceDesk$support_level$Processes>;
    "comment"?: TString;
    "oldGroup"?: TUser[];
    "newGroup"?: TUser[];
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "oldSupervisor"?: TUser[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$transfer_to_level$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "newSupervisor"?: TUser[];
    "groupId"?: TString;
    "level"?: TApplication<Application$ServiceDesk$support_level$Data, Application$ServiceDesk$support_level$Params, Application$ServiceDesk$support_level$Processes>;
    "comment"?: TString;
    "oldGroup"?: TUser[];
    "newGroup"?: TUser[];
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "oldSupervisor"?: TUser[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$add_solution<ProcessContext$ServiceDesk$appeals$add_solution extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$add_solution> {
    "context": ProcessContext$ServiceDesk$appeals$add_solution;
    run(context: Process$ServiceDesk$appeals$add_solution$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$add_solution extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "author"?: TUser;
    "appealDecision"?: TApplication<Application$ServiceDesk$decisions$Data, Application$ServiceDesk$decisions$Params, Application$ServiceDesk$decisions$Processes>;
    "estimation"?: TEnum<Enum$ServiceDesk$appeals$add_solution$estimation>;
    "estimationNumber"?: TFloat;
    "clientComment"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$ServiceDesk$appeals$add_solution$estimation = '1'|'2'|'3'|'4'|'5';

interface Process$ServiceDesk$appeals$add_solution$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "author"?: TUser;
    "appealDecision"?: TApplication<Application$ServiceDesk$decisions$Data, Application$ServiceDesk$decisions$Params, Application$ServiceDesk$decisions$Processes>;
    "estimation"?: TEnum<Enum$ServiceDesk$appeals$add_solution$estimation>;
    "estimationNumber"?: TFloat;
    "clientComment"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$trebovaniya$trebovaniya$dobavit_pervuyu_versiyu<ProcessContext$trebovaniya$trebovaniya$dobavit_pervuyu_versiyu extends ProcessContext> extends Process<ProcessContext$trebovaniya$trebovaniya$dobavit_pervuyu_versiyu> {
    "context": ProcessContext$trebovaniya$trebovaniya$dobavit_pervuyu_versiyu;
    run(context: Process$trebovaniya$trebovaniya$dobavit_pervuyu_versiyu$Context$$Data): Promise<TString>;
}

interface ProcessContext$trebovaniya$trebovaniya$dobavit_pervuyu_versiyu extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$trebovaniya$trebovaniya$dobavit_pervuyu_versiyu$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$problems$problem_registering<ProcessContext$ServiceDesk$problems$problem_registering extends ProcessContext> extends Process<ProcessContext$ServiceDesk$problems$problem_registering> {
    "context": ProcessContext$ServiceDesk$problems$problem_registering;
    run(context: Process$ServiceDesk$problems$problem_registering$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$problems$problem_registering extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "problems"?: TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>;
    "responsible"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$problems$problem_registering$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "problems"?: TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>;
    "responsible"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$put_appeal_on_hold<ProcessContext$ServiceDesk$appeals$put_appeal_on_hold extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$put_appeal_on_hold> {
    "context": ProcessContext$ServiceDesk$appeals$put_appeal_on_hold;
    run(context: Process$ServiceDesk$appeals$put_appeal_on_hold$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$put_appeal_on_hold extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "remainingTime"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$put_appeal_on_hold$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "remainingTime"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$remove_from_holding<ProcessContext$ServiceDesk$appeals$remove_from_holding extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$remove_from_holding> {
    "context": ProcessContext$ServiceDesk$appeals$remove_from_holding;
    run(context: Process$ServiceDesk$appeals$remove_from_holding$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$remove_from_holding extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$remove_from_holding$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$problems$decided_problem<ProcessContext$ServiceDesk$problems$decided_problem extends ProcessContext> extends Process<ProcessContext$ServiceDesk$problems$decided_problem> {
    "context": ProcessContext$ServiceDesk$problems$decided_problem;
    run(context: Process$ServiceDesk$problems$decided_problem$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$problems$decided_problem extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "problems"?: TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>;
    "solutionDescription"?: TString;
    "addSolution"?: TBoolean;
    "decision"?: TApplication<Application$ServiceDesk$decisions$Data, Application$ServiceDesk$decisions$Params, Application$ServiceDesk$decisions$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$problems$decided_problem$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "problems"?: TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>;
    "solutionDescription"?: TString;
    "addSolution"?: TBoolean;
    "decision"?: TApplication<Application$ServiceDesk$decisions$Data, Application$ServiceDesk$decisions$Params, Application$ServiceDesk$decisions$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$services$create_new_service<ProcessContext$ServiceDesk$services$create_new_service extends ProcessContext> extends Process<ProcessContext$ServiceDesk$services$create_new_service> {
    "context": ProcessContext$ServiceDesk$services$create_new_service;
    run(context: Process$ServiceDesk$services$create_new_service$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$services$create_new_service extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "slaLevel"?: TApplication<Application$ServiceDesk$sla_level$Data, Application$ServiceDesk$sla_level$Params, Application$ServiceDesk$sla_level$Processes>;
    "normativeTime"?: TFloat;
    "clientLevel"?: TApplication<Application$ServiceDesk$client_level$Data, Application$ServiceDesk$client_level$Params, Application$ServiceDesk$client_level$Processes>;
    "keyMetrics"?: TTable<Table$ServiceDesk$services$create_new_service$keyMetrics$Row, Table$ServiceDesk$services$create_new_service$keyMetrics$Result>;
    "services"?: TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "reactionTime"?: TFloat;
    "addMore"?: TBoolean;
    "acceptableDowntime"?: TFloat;
    "addOne"?: TString;
    "name"?: TString;
    "actionInViolation"?: TEnum<Enum$ServiceDesk$services$create_new_service$actionInViolation>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$ServiceDesk$services$create_new_service$keyMetrics$Row {
     "__count": TFloat;
     "__index": TFloat;
     "keyIndicator": TString;
     "acceptableValues": TString;
}

interface Table$ServiceDesk$services$create_new_service$keyMetrics$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "keyIndicator": Readonly<TString>;
    readonly "acceptableValues": Readonly<TString>;
}


type Enum$ServiceDesk$services$create_new_service$actionInViolation = 'notification_to_manager';

interface Process$ServiceDesk$services$create_new_service$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "slaLevel"?: TApplication<Application$ServiceDesk$sla_level$Data, Application$ServiceDesk$sla_level$Params, Application$ServiceDesk$sla_level$Processes>;
    "normativeTime"?: TFloat;
    "clientLevel"?: TApplication<Application$ServiceDesk$client_level$Data, Application$ServiceDesk$client_level$Params, Application$ServiceDesk$client_level$Processes>;
    "keyMetrics"?: TTable<Table$ServiceDesk$services$create_new_service$keyMetrics$Row, Table$ServiceDesk$services$create_new_service$keyMetrics$Result>;
    "services"?: TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "reactionTime"?: TFloat;
    "addMore"?: TBoolean;
    "acceptableDowntime"?: TFloat;
    "addOne"?: TString;
    "name"?: TString;
    "actionInViolation"?: TEnum<Enum$ServiceDesk$services$create_new_service$actionInViolation>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$rfc$register_rfc<ProcessContext$ServiceDesk$rfc$register_rfc extends ProcessContext> extends Process<ProcessContext$ServiceDesk$rfc$register_rfc> {
    "context": ProcessContext$ServiceDesk$rfc$register_rfc;
    run(context: Process$ServiceDesk$rfc$register_rfc$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$rfc$register_rfc extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "rfc"?: TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>;
    "approveResult"?: TString;
    "needApprove"?: TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$rfc$register_rfc$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "rfc"?: TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>;
    "approveResult"?: TString;
    "needApprove"?: TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$rfc$estimate<ProcessContext$ServiceDesk$rfc$estimate extends ProcessContext> extends Process<ProcessContext$ServiceDesk$rfc$estimate> {
    "context": ProcessContext$ServiceDesk$rfc$estimate;
    run(context: Process$ServiceDesk$rfc$estimate$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$rfc$estimate extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "rfc"?: TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>;
    "impactLevel"?: TEnum<Enum$ServiceDesk$rfc$estimate$impactLevel>;
    "laboriousness"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$ServiceDesk$rfc$estimate$impactLevel = 'low'|'high'|'highest';

interface Process$ServiceDesk$rfc$estimate$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "rfc"?: TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>;
    "impactLevel"?: TEnum<Enum$ServiceDesk$rfc$estimate$impactLevel>;
    "laboriousness"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$sla_level$create_more_sla_level<ProcessContext$ServiceDesk$sla_level$create_more_sla_level extends ProcessContext> extends Process<ProcessContext$ServiceDesk$sla_level$create_more_sla_level> {
    "context": ProcessContext$ServiceDesk$sla_level$create_more_sla_level;
    run(context: Process$ServiceDesk$sla_level$create_more_sla_level$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$sla_level$create_more_sla_level extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "sla_level"?: TApplication<Application$ServiceDesk$sla_level$Data, Application$ServiceDesk$sla_level$Params, Application$ServiceDesk$sla_level$Processes>;
    "createMore"?: TBoolean;
    "newSlaLevel"?: TApplication<Application$ServiceDesk$sla_level$Data, Application$ServiceDesk$sla_level$Params, Application$ServiceDesk$sla_level$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$sla_level$create_more_sla_level$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "sla_level"?: TApplication<Application$ServiceDesk$sla_level$Data, Application$ServiceDesk$sla_level$Params, Application$ServiceDesk$sla_level$Processes>;
    "createMore"?: TBoolean;
    "newSlaLevel"?: TApplication<Application$ServiceDesk$sla_level$Data, Application$ServiceDesk$sla_level$Params, Application$ServiceDesk$sla_level$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$rfc$complete<ProcessContext$ServiceDesk$rfc$complete extends ProcessContext> extends Process<ProcessContext$ServiceDesk$rfc$complete> {
    "context": ProcessContext$ServiceDesk$rfc$complete;
    run(context: Process$ServiceDesk$rfc$complete$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$rfc$complete extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "rfc"?: TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>;
    "successfulCompletion"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$rfc$complete$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "rfc"?: TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>;
    "successfulCompletion"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$subscribe_to_appeal<ProcessContext$ServiceDesk$appeals$subscribe_to_appeal extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$subscribe_to_appeal> {
    "context": ProcessContext$ServiceDesk$appeals$subscribe_to_appeal;
    run(context: Process$ServiceDesk$appeals$subscribe_to_appeal$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$subscribe_to_appeal extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$subscribe_to_appeal$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$cmdb$add_child_parent_element<ProcessContext$ServiceDesk$cmdb$add_child_parent_element extends ProcessContext> extends Process<ProcessContext$ServiceDesk$cmdb$add_child_parent_element> {
    "context": ProcessContext$ServiceDesk$cmdb$add_child_parent_element;
    run(context: Process$ServiceDesk$cmdb$add_child_parent_element$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$cmdb$add_child_parent_element extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "cmdb"?: TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$cmdb$add_child_parent_element$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "cmdb"?: TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$cmdb$register_problem<ProcessContext$ServiceDesk$cmdb$register_problem extends ProcessContext> extends Process<ProcessContext$ServiceDesk$cmdb$register_problem> {
    "context": ProcessContext$ServiceDesk$cmdb$register_problem;
    run(context: Process$ServiceDesk$cmdb$register_problem$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$cmdb$register_problem extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "cmdb"?: TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "problem"?: TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$cmdb$register_problem$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "cmdb"?: TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "problem"?: TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$business_trips$businesstrip_requests$signing_service_order<ProcessContext$business_trips$businesstrip_requests$signing_service_order extends ProcessContext> extends Process<ProcessContext$business_trips$businesstrip_requests$signing_service_order> {
    "context": ProcessContext$business_trips$businesstrip_requests$signing_service_order;
    run(context: Process$business_trips$businesstrip_requests$signing_service_order$Context$$Data): Promise<TString>;
}

interface ProcessContext$business_trips$businesstrip_requests$signing_service_order extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "service_order"?: TApplication<Application$business_trips$service_assignments$Data, Application$business_trips$service_assignments$Params, Application$business_trips$service_assignments$Processes>;
    "businesstrip_requests"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "rukovoditel"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$business_trips$businesstrip_requests$signing_service_order$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "service_order"?: TApplication<Application$business_trips$service_assignments$Data, Application$business_trips$service_assignments$Params, Application$business_trips$service_assignments$Processes>;
    "businesstrip_requests"?: TApplication<Application$business_trips$businesstrip_requests$Data, Application$business_trips$businesstrip_requests$Params, Application$business_trips$businesstrip_requests$Processes>;
    "rukovoditel"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$cmdb$editing_cmdb<ProcessContext$ServiceDesk$cmdb$editing_cmdb extends ProcessContext> extends Process<ProcessContext$ServiceDesk$cmdb$editing_cmdb> {
    "context": ProcessContext$ServiceDesk$cmdb$editing_cmdb;
    run(context: Process$ServiceDesk$cmdb$editing_cmdb$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$cmdb$editing_cmdb extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "cmdb"?: TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "index_cmdb"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$cmdb$editing_cmdb$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "cmdb"?: TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "index_cmdb"?: TFloat;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$mass_status_to_waiting<ProcessContext$ServiceDesk$appeals$mass_status_to_waiting extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$mass_status_to_waiting> {
    "context": ProcessContext$ServiceDesk$appeals$mass_status_to_waiting;
    run(context: Process$ServiceDesk$appeals$mass_status_to_waiting$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$mass_status_to_waiting extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>[];
    "appeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$mass_status_to_waiting$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>[];
    "appeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$cb_requirements$trebovaniya$soglasovat<ProcessContext$cb_requirements$trebovaniya$soglasovat extends ProcessContext> extends Process<ProcessContext$cb_requirements$trebovaniya$soglasovat> {
    "context": ProcessContext$cb_requirements$trebovaniya$soglasovat;
    run(context: Process$cb_requirements$trebovaniya$soglasovat$Context$$Data): Promise<TString>;
}

interface ProcessContext$cb_requirements$trebovaniya$soglasovat extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "trebovaniya"?: TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$cb_requirements$trebovaniya$soglasovat$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "trebovaniya"?: TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$create_appeal_from_external_user<ProcessContext$ServiceDesk$appeals$create_appeal_from_external_user extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$create_appeal_from_external_user> {
    "context": ProcessContext$ServiceDesk$appeals$create_appeal_from_external_user;
    run(context: Process$ServiceDesk$appeals$create_appeal_from_external_user$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$create_appeal_from_external_user extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "service"?: TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "appealType"?: TApplication<Application$ServiceDesk$appeal_type$Data, Application$ServiceDesk$appeal_type$Params, Application$ServiceDesk$appeal_type$Processes>;
    "prioritity"?: TEnum<Enum$ServiceDesk$appeals$create_appeal_from_external_user$prioritity>;
    "attachments"?: TFile[];
    "administrator"?: TUser;
    "user"?: TUser;
    "company"?: TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "theme"?: TString;
    "appealDescription"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$ServiceDesk$appeals$create_appeal_from_external_user$prioritity = 'high'|'middle'|'low';

interface Process$ServiceDesk$appeals$create_appeal_from_external_user$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "service"?: TApplication<Application$ServiceDesk$services$Data, Application$ServiceDesk$services$Params, Application$ServiceDesk$services$Processes>;
    "appealType"?: TApplication<Application$ServiceDesk$appeal_type$Data, Application$ServiceDesk$appeal_type$Params, Application$ServiceDesk$appeal_type$Processes>;
    "prioritity"?: TEnum<Enum$ServiceDesk$appeals$create_appeal_from_external_user$prioritity>;
    "attachments"?: TFile[];
    "administrator"?: TUser;
    "user"?: TUser;
    "company"?: TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "theme"?: TString;
    "appealDescription"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$cmdb$change_financially_response<ProcessContext$ServiceDesk$cmdb$change_financially_response extends ProcessContext> extends Process<ProcessContext$ServiceDesk$cmdb$change_financially_response> {
    "context": ProcessContext$ServiceDesk$cmdb$change_financially_response;
    run(context: Process$ServiceDesk$cmdb$change_financially_response$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$cmdb$change_financially_response extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "earlyMaterialResponsible"?: TUser;
    "newMaterialResponsible"?: TUser;
    "transfeDate"?: TDatetime;
    "cmdb"?: TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$cmdb$change_financially_response$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "earlyMaterialResponsible"?: TUser;
    "newMaterialResponsible"?: TUser;
    "transfeDate"?: TDatetime;
    "cmdb"?: TApplication<Application$ServiceDesk$cmdb$Data, Application$ServiceDesk$cmdb$Params, Application$ServiceDesk$cmdb$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$cb_requirements$dokumenty$generaciya<ProcessContext$cb_requirements$dokumenty$generaciya extends ProcessContext> extends Process<ProcessContext$cb_requirements$dokumenty$generaciya> {
    "context": ProcessContext$cb_requirements$dokumenty$generaciya;
    run(context: Process$cb_requirements$dokumenty$generaciya$Context$$Data): Promise<TString>;
}

interface ProcessContext$cb_requirements$dokumenty$generaciya extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "dokumenty"?: TApplication<Application$cb_requirements$dokumenty$Data, Application$cb_requirements$dokumenty$Params, Application$cb_requirements$dokumenty$Processes>;
    "tekst"?: TString;
    "file"?: TFile;
    "scope"?: TTable<Table$cb_requirements$dokumenty$generaciya$scope$Row, Table$cb_requirements$dokumenty$generaciya$scope$Result>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$cb_requirements$dokumenty$generaciya$scope$Row {
     "__count": TFloat;
     "__index": TFloat;
     "nazvanie_razdela": TString;
     "trebovanie": TString;
}

interface Table$cb_requirements$dokumenty$generaciya$scope$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "nazvanie_razdela": Readonly<TString>;
    readonly "trebovanie": Readonly<TString>;
}


interface Process$cb_requirements$dokumenty$generaciya$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "dokumenty"?: TApplication<Application$cb_requirements$dokumenty$Data, Application$cb_requirements$dokumenty$Params, Application$cb_requirements$dokumenty$Processes>;
    "tekst"?: TString;
    "file"?: TFile;
    "scope"?: TTable<Table$cb_requirements$dokumenty$generaciya$scope$Row, Table$cb_requirements$dokumenty$generaciya$scope$Result>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$consideration_request_by_manager<ProcessContext$ServiceDesk$appeals$consideration_request_by_manager extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$consideration_request_by_manager> {
    "context": ProcessContext$ServiceDesk$appeals$consideration_request_by_manager;
    run(context: Process$ServiceDesk$appeals$consideration_request_by_manager$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$consideration_request_by_manager extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "currentAppeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$consideration_request_by_manager$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "currentAppeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$mass_change_responsible<ProcessContext$ServiceDesk$appeals$mass_change_responsible extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$mass_change_responsible> {
    "context": ProcessContext$ServiceDesk$appeals$mass_change_responsible;
    run(context: Process$ServiceDesk$appeals$mass_change_responsible$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$mass_change_responsible extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>[];
    "uroven_podderzhki"?: TApplication<Application$ServiceDesk$support_level$Data, Application$ServiceDesk$support_level$Params, Application$ServiceDesk$support_level$Processes>;
    "otvetstvennyi"?: TUser;
    "appeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$mass_change_responsible$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>[];
    "uroven_podderzhki"?: TApplication<Application$ServiceDesk$support_level$Data, Application$ServiceDesk$support_level$Params, Application$ServiceDesk$support_level$Processes>;
    "otvetstvennyi"?: TUser;
    "appeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$consideration_appeal_by_supervisor<ProcessContext$ServiceDesk$appeals$consideration_appeal_by_supervisor extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$consideration_appeal_by_supervisor> {
    "context": ProcessContext$ServiceDesk$appeals$consideration_appeal_by_supervisor;
    run(context: Process$ServiceDesk$appeals$consideration_appeal_by_supervisor$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$consideration_appeal_by_supervisor extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "currentAppeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$consideration_appeal_by_supervisor$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "currentAppeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$appeals$mass_add_solution<ProcessContext$ServiceDesk$appeals$mass_add_solution extends ProcessContext> extends Process<ProcessContext$ServiceDesk$appeals$mass_add_solution> {
    "context": ProcessContext$ServiceDesk$appeals$mass_add_solution;
    run(context: Process$ServiceDesk$appeals$mass_add_solution$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$appeals$mass_add_solution extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "problema"?: TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>[];
    "comment"?: TString;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>[];
    "appeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "solution"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$appeals$mass_add_solution$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "problema"?: TApplication<Application$ServiceDesk$problems$Data, Application$ServiceDesk$problems$Params, Application$ServiceDesk$problems$Processes>[];
    "comment"?: TString;
    "appeals"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>[];
    "appeal"?: TApplication<Application$ServiceDesk$appeals$Data, Application$ServiceDesk$appeals$Params, Application$ServiceDesk$appeals$Processes>;
    "solution"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$cb_requirements$trebovaniya$massovo_soglasovat<ProcessContext$cb_requirements$trebovaniya$massovo_soglasovat extends ProcessContext> extends Process<ProcessContext$cb_requirements$trebovaniya$massovo_soglasovat> {
    "context": ProcessContext$cb_requirements$trebovaniya$massovo_soglasovat;
    run(context: Process$cb_requirements$trebovaniya$massovo_soglasovat$Context$$Data): Promise<TString>;
}

interface ProcessContext$cb_requirements$trebovaniya$massovo_soglasovat extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "trebovaniya"?: TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$cb_requirements$trebovaniya$massovo_soglasovat$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "trebovaniya"?: TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$ServiceDesk$rfc$add_cal_RFC<ProcessContext$ServiceDesk$rfc$add_cal_RFC extends ProcessContext> extends Process<ProcessContext$ServiceDesk$rfc$add_cal_RFC> {
    "context": ProcessContext$ServiceDesk$rfc$add_cal_RFC;
    run(context: Process$ServiceDesk$rfc$add_cal_RFC$Context$$Data): Promise<TString>;
}

interface ProcessContext$ServiceDesk$rfc$add_cal_RFC extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "additional_members"?: TUser[];
    "sobytie_rfc"?: TApplication<Application$ServiceDesk$kalendar_rfc$Data, Application$ServiceDesk$kalendar_rfc$Params, Application$ServiceDesk$kalendar_rfc$Processes>;
    "rfc"?: TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>;
    "date_start"?: TDatetime;
    "date_end"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$ServiceDesk$rfc$add_cal_RFC$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "additional_members"?: TUser[];
    "sobytie_rfc"?: TApplication<Application$ServiceDesk$kalendar_rfc$Data, Application$ServiceDesk$kalendar_rfc$Params, Application$ServiceDesk$kalendar_rfc$Processes>;
    "rfc"?: TApplication<Application$ServiceDesk$rfc$Data, Application$ServiceDesk$rfc$Params, Application$ServiceDesk$rfc$Processes>;
    "date_start"?: TDatetime;
    "date_end"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacation_orders$creation_and_signing_order<ProcessContext$absences$vacation_orders$creation_and_signing_order extends ProcessContext> extends Process<ProcessContext$absences$vacation_orders$creation_and_signing_order> {
    "context": ProcessContext$absences$vacation_orders$creation_and_signing_order;
    run(context: Process$absences$vacation_orders$creation_and_signing_order$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacation_orders$creation_and_signing_order extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "director"?: TUser;
    "order_signed"?: TBoolean;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "period_start"?: TDate;
    "period_end"?: TDate;
    "debug"?: TString;
    "director_position"?: TString;
    "order_type"?: TEnum<Enum$absences$vacation_orders$creation_and_signing_order$order_type>;
    "staff_user"?: TUser;
    "order_file"?: TFile;
    "structural_subdivision"?: TString;
    "vacation"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "city"?: TString;
    "end_date_new"?: TDate;
    "order_date"?: TDate;
    "the_current_date"?: TDate;
    "start_date_new"?: TDate;
    "order_number"?: TString;
    "recall_order"?: TBoolean;
    "vacation_orders"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "position"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$absences$vacation_orders$creation_and_signing_order$order_type = 'transfer'|'recall';

interface Process$absences$vacation_orders$creation_and_signing_order$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "director"?: TUser;
    "order_signed"?: TBoolean;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "period_start"?: TDate;
    "period_end"?: TDate;
    "debug"?: TString;
    "director_position"?: TString;
    "order_type"?: TEnum<Enum$absences$vacation_orders$creation_and_signing_order$order_type>;
    "staff_user"?: TUser;
    "order_file"?: TFile;
    "structural_subdivision"?: TString;
    "vacation"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "city"?: TString;
    "end_date_new"?: TDate;
    "order_date"?: TDate;
    "the_current_date"?: TDate;
    "start_date_new"?: TDate;
    "order_number"?: TString;
    "recall_order"?: TBoolean;
    "vacation_orders"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "position"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$cb_requirements$trebovaniya$dobavit_novuyu_versiyu<ProcessContext$cb_requirements$trebovaniya$dobavit_novuyu_versiyu extends ProcessContext> extends Process<ProcessContext$cb_requirements$trebovaniya$dobavit_novuyu_versiyu> {
    "context": ProcessContext$cb_requirements$trebovaniya$dobavit_novuyu_versiyu;
    run(context: Process$cb_requirements$trebovaniya$dobavit_novuyu_versiyu$Context$$Data): Promise<TString>;
}

interface ProcessContext$cb_requirements$trebovaniya$dobavit_novuyu_versiyu extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "trebovaniya"?: TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$cb_requirements$trebovaniya$dobavit_novuyu_versiyu$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "trebovaniya"?: TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$cb_requirements$trebovaniya$dobavit_pervuyu_versiyu<ProcessContext$cb_requirements$trebovaniya$dobavit_pervuyu_versiyu extends ProcessContext> extends Process<ProcessContext$cb_requirements$trebovaniya$dobavit_pervuyu_versiyu> {
    "context": ProcessContext$cb_requirements$trebovaniya$dobavit_pervuyu_versiyu;
    run(context: Process$cb_requirements$trebovaniya$dobavit_pervuyu_versiyu$Context$$Data): Promise<TString>;
}

interface ProcessContext$cb_requirements$trebovaniya$dobavit_pervuyu_versiyu extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "trebovaniya"?: TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$cb_requirements$trebovaniya$dobavit_pervuyu_versiyu$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "trebovaniya"?: TApplication<Application$cb_requirements$trebovaniya$Data, Application$cb_requirements$trebovaniya$Params, Application$cb_requirements$trebovaniya$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacations$creation_and_approval_vacation<ProcessContext$absences$vacations$creation_and_approval_vacation extends ProcessContext> extends Process<ProcessContext$absences$vacations$creation_and_approval_vacation> {
    "context": ProcessContext$absences$vacations$creation_and_approval_vacation;
    run(context: Process$absences$vacations$creation_and_approval_vacation$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacations$creation_and_approval_vacation extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "start"?: TDatetime;
    "vacation_order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "chief"?: TUser;
    "is_there_a_replacement"?: TBoolean;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "debug"?: TString;
    "successfully_signed"?: TBoolean;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "order_signed"?: TBoolean;
    "type_vacation"?: TEnum<Enum$absences$vacations$creation_and_approval_vacation$type_vacation>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$absences$vacations$creation_and_approval_vacation$type_vacation = 'unpaid'|'sick_leave'|'basic'|'additional'|'pregnancy'|'child_care'|'study';

interface Process$absences$vacations$creation_and_approval_vacation$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "start"?: TDatetime;
    "vacation_order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "chief"?: TUser;
    "is_there_a_replacement"?: TBoolean;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "debug"?: TString;
    "successfully_signed"?: TBoolean;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "order_signed"?: TBoolean;
    "type_vacation"?: TEnum<Enum$absences$vacations$creation_and_approval_vacation$type_vacation>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacations$create_a_replacement<ProcessContext$absences$vacations$create_a_replacement extends ProcessContext> extends Process<ProcessContext$absences$vacations$create_a_replacement> {
    "context": ProcessContext$absences$vacations$create_a_replacement;
    run(context: Process$absences$vacations$create_a_replacement$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacations$create_a_replacement extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "replacement_staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "text_replaced"?: TString;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "chief"?: TUser;
    "end"?: TDate;
    "text_replacement"?: TString;
    "start"?: TDate;
    "debug"?: TString;
    "replaced"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacations$create_a_replacement$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "replacement_staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "text_replaced"?: TString;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "chief"?: TUser;
    "end"?: TDate;
    "text_replacement"?: TString;
    "start"?: TDate;
    "debug"?: TString;
    "replaced"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacations$reschedule_vacation<ProcessContext$absences$vacations$reschedule_vacation extends ProcessContext> extends Process<ProcessContext$absences$vacations$reschedule_vacation> {
    "context": ProcessContext$absences$vacations$reschedule_vacation;
    run(context: Process$absences$vacations$reschedule_vacation$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacations$reschedule_vacation extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "signed_successfully"?: TBoolean;
    "order_file"?: TFile;
    "vacation_docs"?: TApplication<Application$absences$vacation_docs$Data, Application$absences$vacation_docs$Params, Application$absences$vacation_docs$Processes>;
    "sick_leave_number"?: TString;
    "staff_user"?: TUser;
    "start_new"?: TDate;
    "number_order"?: TString;
    "order_date"?: TDate;
    "vacation_order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "sick_leave_start"?: TDate;
    "staff_comment"?: TString;
    "sick_leave_end"?: TDate;
    "old_duration"?: TFloat;
    "chief"?: TUser;
    "end_new"?: TDate;
    "doc_file"?: TFile;
    "reason"?: TEnum<Enum$absences$vacations$reschedule_vacation$reason>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$absences$vacations$reschedule_vacation$reason = 'sick_leave'|'work'|'summons'|'other';

interface Process$absences$vacations$reschedule_vacation$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "signed_successfully"?: TBoolean;
    "order_file"?: TFile;
    "vacation_docs"?: TApplication<Application$absences$vacation_docs$Data, Application$absences$vacation_docs$Params, Application$absences$vacation_docs$Processes>;
    "sick_leave_number"?: TString;
    "staff_user"?: TUser;
    "start_new"?: TDate;
    "number_order"?: TString;
    "order_date"?: TDate;
    "vacation_order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "sick_leave_start"?: TDate;
    "staff_comment"?: TString;
    "sick_leave_end"?: TDate;
    "old_duration"?: TFloat;
    "chief"?: TUser;
    "end_new"?: TDate;
    "doc_file"?: TFile;
    "reason"?: TEnum<Enum$absences$vacations$reschedule_vacation$reason>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$create_or_update_1c_employee<ProcessContext$kedo$staff$create_or_update_1c_employee extends ProcessContext> extends Process<ProcessContext$kedo$staff$create_or_update_1c_employee> {
    "context": ProcessContext$kedo$staff$create_or_update_1c_employee;
    run(context: Process$kedo$staff$create_or_update_1c_employee$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$create_or_update_1c_employee extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "telo_zaprosa_dokumenty"?: TString;
    "employee_id"?: TString;
    "documents_response"?: TString;
    "individual_request_body"?: TString;
    "url_individuals"?: TString;
    "debug"?: TString;
    "url_documents"?: TString;
    "error"?: TString;
    "renew_passport"?: TBoolean;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "document_types"?: TString;
    "employee_exists"?: TBoolean;
    "request_type_documents"?: TString;
    "employees_response"?: TString;
    "url_employee"?: TString;
    "request_type"?: TString;
    "request_body_employees"?: TString;
    "documents_types_url"?: TString;
    "employee_data"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "individuals_result"?: TString;
    "individual_id"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staff$create_or_update_1c_employee$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "telo_zaprosa_dokumenty"?: TString;
    "employee_id"?: TString;
    "documents_response"?: TString;
    "individual_request_body"?: TString;
    "url_individuals"?: TString;
    "debug"?: TString;
    "url_documents"?: TString;
    "error"?: TString;
    "renew_passport"?: TBoolean;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "document_types"?: TString;
    "employee_exists"?: TBoolean;
    "request_type_documents"?: TString;
    "employees_response"?: TString;
    "url_employee"?: TString;
    "request_type"?: TString;
    "request_body_employees"?: TString;
    "documents_types_url"?: TString;
    "employee_data"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "individuals_result"?: TString;
    "individual_id"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$order_generation<ProcessContext$kedo$staff$order_generation extends ProcessContext> extends Process<ProcessContext$kedo$staff$order_generation> {
    "context": ProcessContext$kedo$staff$order_generation;
    run(context: Process$kedo$staff$order_generation$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$order_generation extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "timer"?: TDate;
    "documents"?: TApplication<Application$kedo$documents_for_employment$Data, Application$kedo$documents_for_employment$Params, Application$kedo$documents_for_employment$Processes>;
    "order_for_transfer"?: TApplication<Application$kedo$order_for_transfer$Data, Application$kedo$order_for_transfer$Params, Application$kedo$order_for_transfer$Processes>;
    "signatories"?: TUser[];
    "staff_user"?: TUser;
    "document_file"?: TFile;
    "responsible"?: TUser;
    "transfer_application"?: TApplication<Application$kedo$transfer_application$Data, Application$kedo$transfer_application$Params, Application$kedo$transfer_application$Processes>;
    "app"?: TRefItem;
    "decree_for_portal"?: TApplication<Application$kedo$documents_for_employment$Data, Application$kedo$documents_for_employment$Params, Application$kedo$documents_for_employment$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staff$order_generation$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "timer"?: TDate;
    "documents"?: TApplication<Application$kedo$documents_for_employment$Data, Application$kedo$documents_for_employment$Params, Application$kedo$documents_for_employment$Processes>;
    "order_for_transfer"?: TApplication<Application$kedo$order_for_transfer$Data, Application$kedo$order_for_transfer$Params, Application$kedo$order_for_transfer$Processes>;
    "signatories"?: TUser[];
    "staff_user"?: TUser;
    "document_file"?: TFile;
    "responsible"?: TUser;
    "transfer_application"?: TApplication<Application$kedo$transfer_application$Data, Application$kedo$transfer_application$Params, Application$kedo$transfer_application$Processes>;
    "app"?: TRefItem;
    "decree_for_portal"?: TApplication<Application$kedo$documents_for_employment$Data, Application$kedo$documents_for_employment$Params, Application$kedo$documents_for_employment$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$transfer_process<ProcessContext$kedo$staff$transfer_process extends ProcessContext> extends Process<ProcessContext$kedo$staff$transfer_process> {
    "context": ProcessContext$kedo$staff$transfer_process;
    run(context: Process$kedo$staff$transfer_process$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$transfer_process extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff_user"?: TUser;
    "date_of_transfer"?: TDate;
    "alert_body"?: TString;
    "head_position"?: TUser;
    "subdivision"?: TApplication<Application$kedo$structural_subdivision$Data, Application$kedo$structural_subdivision$Params, Application$kedo$structural_subdivision$Processes>;
    "organization"?: TApplication<Application$kedo$organization$Data, Application$kedo$organization$Params, Application$kedo$organization$Processes>;
    "alert_title"?: TString;
    "current_date"?: TDate;
    "position"?: TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "position_new"?: TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "documents"?: TApplication<Application$kedo$documents_for_employment$Data, Application$kedo$documents_for_employment$Params, Application$kedo$documents_for_employment$Processes>;
    "new_supervisor"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "new_head_position"?: TUser;
    "comment"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "order_for_transfer"?: TApplication<Application$kedo$order_for_transfer$Data, Application$kedo$order_for_transfer$Params, Application$kedo$order_for_transfer$Processes>;
    "create_date"?: TDate;
    "supervisor"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "signatories"?: TUser[];
    "document_file"?: TFile;
    "transfer_application"?: TApplication<Application$kedo$transfer_application$Data, Application$kedo$transfer_application$Params, Application$kedo$transfer_application$Processes>;
    "responsible"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staff$transfer_process$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff_user"?: TUser;
    "date_of_transfer"?: TDate;
    "alert_body"?: TString;
    "head_position"?: TUser;
    "subdivision"?: TApplication<Application$kedo$structural_subdivision$Data, Application$kedo$structural_subdivision$Params, Application$kedo$structural_subdivision$Processes>;
    "organization"?: TApplication<Application$kedo$organization$Data, Application$kedo$organization$Params, Application$kedo$organization$Processes>;
    "alert_title"?: TString;
    "current_date"?: TDate;
    "position"?: TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "position_new"?: TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "documents"?: TApplication<Application$kedo$documents_for_employment$Data, Application$kedo$documents_for_employment$Params, Application$kedo$documents_for_employment$Processes>;
    "new_supervisor"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "new_head_position"?: TUser;
    "comment"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "order_for_transfer"?: TApplication<Application$kedo$order_for_transfer$Data, Application$kedo$order_for_transfer$Params, Application$kedo$order_for_transfer$Processes>;
    "create_date"?: TDate;
    "supervisor"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "signatories"?: TUser[];
    "document_file"?: TFile;
    "transfer_application"?: TApplication<Application$kedo$transfer_application$Data, Application$kedo$transfer_application$Params, Application$kedo$transfer_application$Processes>;
    "responsible"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$Employment<ProcessContext$kedo$staff$Employment extends ProcessContext> extends Process<ProcessContext$kedo$staff$Employment> {
    "context": ProcessContext$kedo$staff$Employment;
    run(context: Process$kedo$staff$Employment$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$Employment extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "signed_soev"?: TFile;
    "city"?: TString;
    "snils"?: TString;
    "photo_with_unfolded_passport"?: TFile;
    "number"?: TString;
    "additional_agreement_to_the_contract"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "regeneration_soev"?: TBoolean;
    "line_OGRN"?: TString;
    "entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "line_region"?: TString;
    "agreement_between_participants_of_electronic_interaction"?: TApplication<Application$kedo$electronic_interaction_agreement$Data, Application$kedo$electronic_interaction_agreement$Params, Application$kedo$electronic_interaction_agreement$Processes>;
    "admission_order"?: TApplication<Application$kedo$admission_order$Data, Application$kedo$admission_order$Params, Application$kedo$admission_order$Processes>;
    "staff_member"?: TUser;
    "passport_page_with_current_registration"?: TFile;
    "staff_comment"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "sex"?: TBoolean;
    "alert_body"?: TString;
    "comment"?: TString;
    "already_employed"?: TBoolean;
    "full_name"?: TFullName;
    "additional_agreement_2"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "line_name"?: TString;
    "the_address"?: TString;
    "document_file"?: TFile;
    "department_code"?: TString;
    "notification_text"?: TString;
    "phone"?: TPhone<PhoneType.Work>;
    "date_of_issue"?: TDate;
    "position"?: TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "external_user"?: TUser;
    "line_country"?: TString;
    "inn_file"?: TFile;
    "application_for_the_provision_of_information_about_labor_activity"?: TApplication<Application$kedo$information_about_labor_activity$Data, Application$kedo$information_about_labor_activity$Params, Application$kedo$information_about_labor_activity$Processes>;
    "signatories"?: TUser[];
    "frame"?: TString;
    "the_outside"?: TString;
    "invalid_fields"?: TEnum<Enum$kedo$staff$Employment$invalid_fields>[];
    "line_surname"?: TString;
    "documents_for_employment"?: TApplication<Application$kedo$documents_for_employment$Data, Application$kedo$documents_for_employment$Params, Application$kedo$documents_for_employment$Processes>;
    "marriage"?: TBoolean;
    "house"?: TString;
    "series"?: TString;
    "the_department"?: TApplication<Application$kedo$structural_subdivision$Data, Application$kedo$structural_subdivision$Params, Application$kedo$structural_subdivision$Processes>;
    "passport_page_with_photo_and_data"?: TFile;
    "unep_issue_required"?: TBoolean;
    "labor_contract"?: TApplication<Application$kedo$labor_contract$Data, Application$kedo$labor_contract$Params, Application$kedo$labor_contract$Processes>;
    "additional_agreement_1"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "snils_file"?: TFile;
    "line_for_issuing_UNEP"?: TString;
    "the_current_date"?: TString;
    "issued_by"?: TString;
    "flat"?: TString;
    "additional_agreement_3"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "job_application"?: TApplication<Application$kedo$job_application$Data, Application$kedo$job_application$Params, Application$kedo$job_application$Processes>;
    "tin"?: TString;
    "elektronnaya_pochta"?: TEmail<EmailType.Work>;
    "need_a_regeneration"?: TBoolean;
    "line_middle_name"?: TString;
    "date_of_birth"?: TDate;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$kedo$staff$Employment$invalid_fields = 'main'|'location'|'documents'|'document_scans'|'photo';

interface Process$kedo$staff$Employment$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "signed_soev"?: TFile;
    "city"?: TString;
    "snils"?: TString;
    "photo_with_unfolded_passport"?: TFile;
    "number"?: TString;
    "additional_agreement_to_the_contract"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "regeneration_soev"?: TBoolean;
    "line_OGRN"?: TString;
    "entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "line_region"?: TString;
    "agreement_between_participants_of_electronic_interaction"?: TApplication<Application$kedo$electronic_interaction_agreement$Data, Application$kedo$electronic_interaction_agreement$Params, Application$kedo$electronic_interaction_agreement$Processes>;
    "admission_order"?: TApplication<Application$kedo$admission_order$Data, Application$kedo$admission_order$Params, Application$kedo$admission_order$Processes>;
    "staff_member"?: TUser;
    "passport_page_with_current_registration"?: TFile;
    "staff_comment"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "sex"?: TBoolean;
    "alert_body"?: TString;
    "comment"?: TString;
    "already_employed"?: TBoolean;
    "full_name"?: TFullName;
    "additional_agreement_2"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "line_name"?: TString;
    "the_address"?: TString;
    "document_file"?: TFile;
    "department_code"?: TString;
    "notification_text"?: TString;
    "phone"?: TPhone<PhoneType.Work>;
    "date_of_issue"?: TDate;
    "position"?: TApplication<Application$kedo$position$Data, Application$kedo$position$Params, Application$kedo$position$Processes>;
    "external_user"?: TUser;
    "line_country"?: TString;
    "inn_file"?: TFile;
    "application_for_the_provision_of_information_about_labor_activity"?: TApplication<Application$kedo$information_about_labor_activity$Data, Application$kedo$information_about_labor_activity$Params, Application$kedo$information_about_labor_activity$Processes>;
    "signatories"?: TUser[];
    "frame"?: TString;
    "the_outside"?: TString;
    "invalid_fields"?: TEnum<Enum$kedo$staff$Employment$invalid_fields>[];
    "line_surname"?: TString;
    "documents_for_employment"?: TApplication<Application$kedo$documents_for_employment$Data, Application$kedo$documents_for_employment$Params, Application$kedo$documents_for_employment$Processes>;
    "marriage"?: TBoolean;
    "house"?: TString;
    "series"?: TString;
    "the_department"?: TApplication<Application$kedo$structural_subdivision$Data, Application$kedo$structural_subdivision$Params, Application$kedo$structural_subdivision$Processes>;
    "passport_page_with_photo_and_data"?: TFile;
    "unep_issue_required"?: TBoolean;
    "labor_contract"?: TApplication<Application$kedo$labor_contract$Data, Application$kedo$labor_contract$Params, Application$kedo$labor_contract$Processes>;
    "additional_agreement_1"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "snils_file"?: TFile;
    "line_for_issuing_UNEP"?: TString;
    "the_current_date"?: TString;
    "issued_by"?: TString;
    "flat"?: TString;
    "additional_agreement_3"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "job_application"?: TApplication<Application$kedo$job_application$Data, Application$kedo$job_application$Params, Application$kedo$job_application$Processes>;
    "tin"?: TString;
    "elektronnaya_pochta"?: TEmail<EmailType.Work>;
    "need_a_regeneration"?: TBoolean;
    "line_middle_name"?: TString;
    "date_of_birth"?: TDate;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$toolbar_button<ProcessContext$kedo$staff$toolbar_button extends ProcessContext> extends Process<ProcessContext$kedo$staff$toolbar_button> {
    "context": ProcessContext$kedo$staff$toolbar_button;
    run(context: Process$kedo$staff$toolbar_button$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$toolbar_button extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "document_file"?: TFile;
    "job_application"?: TApplication<Application$kedo$job_application$Data, Application$kedo$job_application$Params, Application$kedo$job_application$Processes>;
    "notification_text"?: TString;
    "admission_order"?: TApplication<Application$kedo$admission_order$Data, Application$kedo$admission_order$Params, Application$kedo$admission_order$Processes>;
    "application_for_the_provision_of_information_about_labor_activity"?: TApplication<Application$kedo$information_about_labor_activity$Data, Application$kedo$information_about_labor_activity$Params, Application$kedo$information_about_labor_activity$Processes>;
    "current_date"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "ds_1"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "ds_2"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "staff_member"?: TUser;
    "link"?: TString;
    "employ_access"?: TBoolean;
    "trebuetsya_peregenraciya"?: TBoolean;
    "ds_3"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "labor_contract"?: TApplication<Application$kedo$labor_contract$Data, Application$kedo$labor_contract$Params, Application$kedo$labor_contract$Processes>;
    "signatories"?: TUser[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staff$toolbar_button$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "document_file"?: TFile;
    "job_application"?: TApplication<Application$kedo$job_application$Data, Application$kedo$job_application$Params, Application$kedo$job_application$Processes>;
    "notification_text"?: TString;
    "admission_order"?: TApplication<Application$kedo$admission_order$Data, Application$kedo$admission_order$Params, Application$kedo$admission_order$Processes>;
    "application_for_the_provision_of_information_about_labor_activity"?: TApplication<Application$kedo$information_about_labor_activity$Data, Application$kedo$information_about_labor_activity$Params, Application$kedo$information_about_labor_activity$Processes>;
    "current_date"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "ds_1"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "ds_2"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "staff_member"?: TUser;
    "link"?: TString;
    "employ_access"?: TBoolean;
    "trebuetsya_peregenraciya"?: TBoolean;
    "ds_3"?: TApplication<Application$kedo$additional_agreement_to_the_contract$Data, Application$kedo$additional_agreement_to_the_contract$Params, Application$kedo$additional_agreement_to_the_contract$Processes>;
    "labor_contract"?: TApplication<Application$kedo$labor_contract$Data, Application$kedo$labor_contract$Params, Application$kedo$labor_contract$Processes>;
    "signatories"?: TUser[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$signme_release<ProcessContext$kedo$staff$signme_release extends ProcessContext> extends Process<ProcessContext$kedo$staff$signme_release> {
    "context": ProcessContext$kedo$staff$signme_release;
    run(context: Process$kedo$staff$signme_release$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$signme_release extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "date_of_birth"?: TDate;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "line_for_issuing_UNEP"?: TString;
    "tin"?: TString;
    "snils"?: TString;
    "date_of_issue"?: TDate;
    "elektronnaya_pochta"?: TEmail<EmailType.Work>;
    "line_OGRN"?: TString;
    "department_code"?: TString;
    "number"?: TString;
    "line_surname"?: TString;
    "line_name"?: TString;
    "issued_by"?: TString;
    "series"?: TString;
    "user"?: TUser;
    "phone"?: TPhone<PhoneType.Work>;
    "line_region"?: TString;
    "the_passport"?: TFile;
    "line_middle_name"?: TString;
    "line_country"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staff$signme_release$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "date_of_birth"?: TDate;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "line_for_issuing_UNEP"?: TString;
    "tin"?: TString;
    "snils"?: TString;
    "date_of_issue"?: TDate;
    "elektronnaya_pochta"?: TEmail<EmailType.Work>;
    "line_OGRN"?: TString;
    "department_code"?: TString;
    "number"?: TString;
    "line_surname"?: TString;
    "line_name"?: TString;
    "issued_by"?: TString;
    "series"?: TString;
    "user"?: TUser;
    "phone"?: TPhone<PhoneType.Work>;
    "line_region"?: TString;
    "the_passport"?: TFile;
    "line_middle_name"?: TString;
    "line_country"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staffing_data$staffing_integration_with_1s<ProcessContext$kedo$staffing_data$staffing_integration_with_1s extends ProcessContext> extends Process<ProcessContext$kedo$staffing_data$staffing_integration_with_1s> {
    "context": ProcessContext$kedo$staffing_data$staffing_integration_with_1s;
    run(context: Process$kedo$staffing_data$staffing_integration_with_1s$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staffing_data$staffing_integration_with_1s extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "organization_array_length"?: TFloat;
    "remote_applications"?: TString;
    "request_parameters_1c"?: TString;
    "organization_ref_key_array_json"?: TString;
    "staffing_data"?: TApplication<Application$kedo$staffing_data$Data, Application$kedo$staffing_data$Params, Application$kedo$staffing_data$Processes>;
    "error"?: TString;
    "response_1c_json"?: TString;
    "staffing_data_json"?: TString;
    "app_legal_entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staffing_data$staffing_integration_with_1s$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "organization_array_length"?: TFloat;
    "remote_applications"?: TString;
    "request_parameters_1c"?: TString;
    "organization_ref_key_array_json"?: TString;
    "staffing_data"?: TApplication<Application$kedo$staffing_data$Data, Application$kedo$staffing_data$Params, Application$kedo$staffing_data$Processes>;
    "error"?: TString;
    "response_1c_json"?: TString;
    "staffing_data_json"?: TString;
    "app_legal_entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$agreement_generation<ProcessContext$kedo$staff$agreement_generation extends ProcessContext> extends Process<ProcessContext$kedo$staff$agreement_generation> {
    "context": ProcessContext$kedo$staff$agreement_generation;
    run(context: Process$kedo$staff$agreement_generation$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$agreement_generation extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "agreement_between_participants_of_electronic_interaction"?: TApplication<Application$kedo$electronic_interaction_agreement$Data, Application$kedo$electronic_interaction_agreement$Params, Application$kedo$electronic_interaction_agreement$Processes>;
    "employee"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible_user"?: TUser;
    "notification_text"?: TString;
    "need_a_regeneration"?: TBoolean;
    "document_file"?: TFile;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staff$agreement_generation$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "agreement_between_participants_of_electronic_interaction"?: TApplication<Application$kedo$electronic_interaction_agreement$Data, Application$kedo$electronic_interaction_agreement$Params, Application$kedo$electronic_interaction_agreement$Processes>;
    "employee"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "responsible_user"?: TUser;
    "notification_text"?: TString;
    "need_a_regeneration"?: TBoolean;
    "document_file"?: TFile;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$user_prompt<ProcessContext$kedo$staff$user_prompt extends ProcessContext> extends Process<ProcessContext$kedo$staff$user_prompt> {
    "context": ProcessContext$kedo$staff$user_prompt;
    run(context: Process$kedo$staff$user_prompt$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$user_prompt extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "ext_user"?: TUser;
    "invitation_text_SMS"?: TString;
    "staff_access"?: TBoolean;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "link"?: TString;
    "alert_body"?: TString;
    "linked_staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "invitation_text_email"?: TString;
    "stroka_oshibki"?: TString;
    "invitation_link_for_new_user"?: TString;
    "external_staff"?: TApplication<Application$_system_catalogs$_user_profiles$Data, Application$_system_catalogs$_user_profiles$Params, Application$_system_catalogs$_user_profiles$Processes>;
    "user"?: TUser;
    "email"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staff$user_prompt$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "ext_user"?: TUser;
    "invitation_text_SMS"?: TString;
    "staff_access"?: TBoolean;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "link"?: TString;
    "alert_body"?: TString;
    "linked_staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "invitation_text_email"?: TString;
    "stroka_oshibki"?: TString;
    "invitation_link_for_new_user"?: TString;
    "external_staff"?: TApplication<Application$_system_catalogs$_user_profiles$Data, Application$_system_catalogs$_user_profiles$Params, Application$_system_catalogs$_user_profiles$Processes>;
    "user"?: TUser;
    "email"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$get_link<ProcessContext$kedo$staff$get_link extends ProcessContext> extends Process<ProcessContext$kedo$staff$get_link> {
    "context": ProcessContext$kedo$staff$get_link;
    run(context: Process$kedo$staff$get_link$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$get_link extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "note_file"?: TFile[];
    "notification"?: TEnum<Enum$kedo$staff$get_link$notification>;
    "alert_head"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "alert_url"?: TString;
    "notification_text_for_sms"?: TString;
    "topic_of_the_letter"?: TString;
    "portal_link"?: TString;
    "notification_text"?: TString;
    "alert_body"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$kedo$staff$get_link$notification = 'email'|'sms'|'email_and_sms'|'without_notifications';

interface Process$kedo$staff$get_link$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "note_file"?: TFile[];
    "notification"?: TEnum<Enum$kedo$staff$get_link$notification>;
    "alert_head"?: TString;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "alert_url"?: TString;
    "notification_text_for_sms"?: TString;
    "topic_of_the_letter"?: TString;
    "portal_link"?: TString;
    "notification_text"?: TString;
    "alert_body"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacations$vacation_pay<ProcessContext$absences$vacations$vacation_pay extends ProcessContext> extends Process<ProcessContext$absences$vacations$vacation_pay> {
    "context": ProcessContext$absences$vacations$vacation_pay;
    run(context: Process$absences$vacations$vacation_pay$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacations$vacation_pay extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "start"?: TDate;
    "notification_body"?: TString;
    "type"?: TEnum<Enum$absences$vacations$vacation_pay$type>;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "staff"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$absences$vacations$vacation_pay$type = 'vacation'|'sick_leave';

interface Process$absences$vacations$vacation_pay$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "start"?: TDate;
    "notification_body"?: TString;
    "type"?: TEnum<Enum$absences$vacations$vacation_pay$type>;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "staff"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacations$create_medical_leave<ProcessContext$absences$vacations$create_medical_leave extends ProcessContext> extends Process<ProcessContext$absences$vacations$create_medical_leave> {
    "context": ProcessContext$absences$vacations$create_medical_leave;
    run(context: Process$absences$vacations$create_medical_leave$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacations$create_medical_leave extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "new_end_date"?: TDatetime;
    "notification_body"?: TString;
    "pregnancy"?: TBoolean;
    "signed"?: TBoolean;
    "staff_user"?: TUser;
    "early_pregnancy"?: TBoolean;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "end_date"?: TDatetime;
    "accountant"?: TUser;
    "vacation_order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacations$create_medical_leave$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "new_end_date"?: TDatetime;
    "notification_body"?: TString;
    "pregnancy"?: TBoolean;
    "signed"?: TBoolean;
    "staff_user"?: TUser;
    "early_pregnancy"?: TBoolean;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "end_date"?: TDatetime;
    "accountant"?: TUser;
    "vacation_order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$sign_me_certificate_reissuance<ProcessContext$kedo$staff$sign_me_certificate_reissuance extends ProcessContext> extends Process<ProcessContext$kedo$staff$sign_me_certificate_reissuance> {
    "context": ProcessContext$kedo$staff$sign_me_certificate_reissuance;
    run(context: Process$kedo$staff$sign_me_certificate_reissuance$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$sign_me_certificate_reissuance extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>[];
    "users"?: TUser[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staff$sign_me_certificate_reissuance$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>[];
    "users"?: TUser[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacations$vacation_correction<ProcessContext$absences$vacations$vacation_correction extends ProcessContext> extends Process<ProcessContext$absences$vacations$vacation_correction> {
    "context": ProcessContext$absences$vacations$vacation_correction;
    run(context: Process$absences$vacations$vacation_correction$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacations$vacation_correction extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff_user"?: TUser;
    "vacations_after"?: TString;
    "vacations_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "debug"?: TString;
    "schedule"?: TTable<Table$absences$vacations$vacation_correction$schedule$Row, Table$absences$vacations$vacation_correction$schedule$Result>;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "year"?: TFloat;
    "vacations_before"?: TString;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$absences$vacations$vacation_correction$schedule$Row {
     "__count": TFloat;
     "__index": TFloat;
     "vacation": TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
     "start": TDate;
     "end": TDate;
     "duration": TFloat;
     "chief_comment": TString;
     "staff_comment": TString;
     "rewrite": TBoolean;
     "has_holidays": TBoolean;
}

interface Table$absences$vacations$vacation_correction$schedule$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "vacation": Readonly<TString>;
    readonly "start": Readonly<TString>;
    readonly "end": Readonly<TString>;
    readonly "duration": Readonly<TString>;
    readonly "chief_comment": Readonly<TString>;
    readonly "staff_comment": Readonly<TString>;
    readonly "rewrite": Readonly<TString>;
    readonly "has_holidays": Readonly<TString>;
}


interface Process$absences$vacations$vacation_correction$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff_user"?: TUser;
    "vacations_after"?: TString;
    "vacations_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "debug"?: TString;
    "schedule"?: TTable<Table$absences$vacations$vacation_correction$schedule$Row, Table$absences$vacations$vacation_correction$schedule$Result>;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "year"?: TFloat;
    "vacations_before"?: TString;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacations$notification<ProcessContext$absences$vacations$notification extends ProcessContext> extends Process<ProcessContext$absences$vacations$notification> {
    "context": ProcessContext$absences$vacations$notification;
    run(context: Process$absences$vacations$notification$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacations$notification extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "initial_date"?: TDate;
    "staff_user"?: TUser;
    "staff_and_chief"?: TUser[];
    "alert_body"?: TString;
    "chief"?: TUser;
    "alert_head"?: TString;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "notification_body"?: TString;
    "signed"?: TBoolean;
    "vacation_order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacations$notification$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "initial_date"?: TDate;
    "staff_user"?: TUser;
    "staff_and_chief"?: TUser[];
    "alert_body"?: TString;
    "chief"?: TUser;
    "alert_head"?: TString;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "notification_body"?: TString;
    "signed"?: TBoolean;
    "vacation_order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacation_schedule$create_a_vacation_schedule_copy<ProcessContext$absences$vacation_schedule$create_a_vacation_schedule_copy extends ProcessContext> extends Process<ProcessContext$absences$vacation_schedule$create_a_vacation_schedule_copy> {
    "context": ProcessContext$absences$vacation_schedule$create_a_vacation_schedule_copy;
    run(context: Process$absences$vacation_schedule$create_a_vacation_schedule_copy$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacation_schedule$create_a_vacation_schedule_copy extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "order_file"?: TFile;
    "vacation_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "director"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacation_schedule$create_a_vacation_schedule_copy$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "order_file"?: TFile;
    "vacation_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "director"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacation_orders$sign_order<ProcessContext$absences$vacation_orders$sign_order extends ProcessContext> extends Process<ProcessContext$absences$vacation_orders$sign_order> {
    "context": ProcessContext$absences$vacation_orders$sign_order;
    run(context: Process$absences$vacation_orders$sign_order$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacation_orders$sign_order extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "signed"?: TBoolean;
    "vacation_orders"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "vacation"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "director"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacation_orders$sign_order$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "signed"?: TBoolean;
    "vacation_orders"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "vacation"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "director"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$error_found_button<ProcessContext$kedo$error_found_button extends ProcessContext> extends Process<ProcessContext$kedo$error_found_button> {
    "context": ProcessContext$kedo$error_found_button;
    run(context: Process$kedo$error_found_button$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$error_found_button extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "a_comment"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$error_found_button$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "a_comment"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacation_schedule$create_planned_vacation_copy<ProcessContext$absences$vacation_schedule$create_planned_vacation_copy extends ProcessContext> extends Process<ProcessContext$absences$vacation_schedule$create_planned_vacation_copy> {
    "context": ProcessContext$absences$vacation_schedule$create_planned_vacation_copy;
    run(context: Process$absences$vacation_schedule$create_planned_vacation_copy$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacation_schedule$create_planned_vacation_copy extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "chief_user"?: TUser;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "year"?: TFloat;
    "staff_user"?: TUser;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "table_planned"?: TTable<Table$absences$vacation_schedule$create_planned_vacation_copy$table_planned$Row, Table$absences$vacation_schedule$create_planned_vacation_copy$table_planned$Result>;
    "debug"?: TString;
    "vacation_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$absences$vacation_schedule$create_planned_vacation_copy$table_planned$Row {
     "__count": TFloat;
     "__index": TFloat;
     "start": TDate;
     "end": TDate;
     "duration": TFloat;
     "comment": TString;
     "rewrite": TBoolean;
     "has_holidays": TBoolean;
}

interface Table$absences$vacation_schedule$create_planned_vacation_copy$table_planned$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "start": Readonly<TString>;
    readonly "end": Readonly<TString>;
    readonly "duration": Readonly<TString>;
    readonly "comment": Readonly<TString>;
    readonly "rewrite": Readonly<TString>;
    readonly "has_holidays": Readonly<TString>;
}


interface Process$absences$vacation_schedule$create_planned_vacation_copy$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "chief_user"?: TUser;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "year"?: TFloat;
    "staff_user"?: TUser;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "table_planned"?: TTable<Table$absences$vacation_schedule$create_planned_vacation_copy$table_planned$Row, Table$absences$vacation_schedule$create_planned_vacation_copy$table_planned$Result>;
    "debug"?: TString;
    "vacation_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staff$load_employee_list<ProcessContext$kedo$staff$load_employee_list extends ProcessContext> extends Process<ProcessContext$kedo$staff$load_employee_list> {
    "context": ProcessContext$kedo$staff$load_employee_list;
    run(context: Process$kedo$staff$load_employee_list$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staff$load_employee_list extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "docsParams"?: TString;
    "personalInfoParams"?: TString;
    "staff_table"?: TTable<Table$kedo$staff$load_employee_list$staff_table$Row, Table$kedo$staff$load_employee_list$staff_table$Result>;
    "positionParams"?: TString;
    "personalInfo"?: TString;
    "unep_issue_required"?: TBoolean;
    "employeesParams"?: TString;
    "positions"?: TString;
    "docs"?: TString;
    "is_employed"?: TBoolean;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>[];
    "debug"?: TString;
    "employees"?: TString;
    "error"?: TString;
    "staff_member"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$kedo$staff$load_employee_list$staff_table$Row {
     "__count": TFloat;
     "__index": TFloat;
     "staff": TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
     "email": TEmail<EmailType.Work>;
     "phone": TPhone<PhoneType.Work>;
}

interface Table$kedo$staff$load_employee_list$staff_table$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "staff": Readonly<TString>;
    readonly "email": Readonly<TString>;
    readonly "phone": Readonly<TString>;
}


interface Process$kedo$staff$load_employee_list$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "docsParams"?: TString;
    "personalInfoParams"?: TString;
    "staff_table"?: TTable<Table$kedo$staff$load_employee_list$staff_table$Row, Table$kedo$staff$load_employee_list$staff_table$Result>;
    "positionParams"?: TString;
    "personalInfo"?: TString;
    "unep_issue_required"?: TBoolean;
    "employeesParams"?: TString;
    "positions"?: TString;
    "docs"?: TString;
    "is_employed"?: TBoolean;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>[];
    "debug"?: TString;
    "employees"?: TString;
    "error"?: TString;
    "staff_member"?: TUser;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacation_docs$create_and_sign_an_application<ProcessContext$absences$vacation_docs$create_and_sign_an_application extends ProcessContext> extends Process<ProcessContext$absences$vacation_docs$create_and_sign_an_application> {
    "context": ProcessContext$absences$vacation_docs$create_and_sign_an_application;
    run(context: Process$absences$vacation_docs$create_and_sign_an_application$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacation_docs$create_and_sign_an_application extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "vacation_extension"?: TBoolean;
    "end"?: TDatetime;
    "child_name"?: TString;
    "place_of_study"?: TString;
    "application_file"?: TFile;
    "current_date"?: TDate;
    "director_position"?: TString;
    "reason_for_unpaid"?: TString;
    "supervisor"?: TUser;
    "correction"?: TBoolean;
    "base"?: TFile;
    "debug"?: TString;
    "position"?: TString;
    "vacation"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "birth_certificate"?: TFile;
    "early_pregnancy"?: TBoolean;
    "successfully_signed"?: TBoolean;
    "reason"?: TEnum<Enum$absences$vacation_docs$create_and_sign_an_application$reason>;
    "vacation_docs"?: TApplication<Application$absences$vacation_docs$Data, Application$absences$vacation_docs$Params, Application$absences$vacation_docs$Processes>;
    "comment"?: TString;
    "start"?: TDatetime;
    "sick_leave_number"?: TString;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "new_end_date"?: TDate;
    "start_date_new"?: TDate;
    "type_vacation"?: TEnum<Enum$absences$vacation_docs$create_and_sign_an_application$type_vacation>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$absences$vacation_docs$create_and_sign_an_application$reason = never;

type Enum$absences$vacation_docs$create_and_sign_an_application$type_vacation = 'unpaid'|'sick_leave'|'basic'|'additional'|'pregnancy'|'child_care'|'study'|'scheduled';

interface Process$absences$vacation_docs$create_and_sign_an_application$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "vacation_extension"?: TBoolean;
    "end"?: TDatetime;
    "child_name"?: TString;
    "place_of_study"?: TString;
    "application_file"?: TFile;
    "current_date"?: TDate;
    "director_position"?: TString;
    "reason_for_unpaid"?: TString;
    "supervisor"?: TUser;
    "correction"?: TBoolean;
    "base"?: TFile;
    "debug"?: TString;
    "position"?: TString;
    "vacation"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "birth_certificate"?: TFile;
    "early_pregnancy"?: TBoolean;
    "successfully_signed"?: TBoolean;
    "reason"?: TEnum<Enum$absences$vacation_docs$create_and_sign_an_application$reason>;
    "vacation_docs"?: TApplication<Application$absences$vacation_docs$Data, Application$absences$vacation_docs$Params, Application$absences$vacation_docs$Processes>;
    "comment"?: TString;
    "start"?: TDatetime;
    "sick_leave_number"?: TString;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "new_end_date"?: TDate;
    "start_date_new"?: TDate;
    "type_vacation"?: TEnum<Enum$absences$vacation_docs$create_and_sign_an_application$type_vacation>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$kedo$staffing_data$update_json_object<ProcessContext$kedo$staffing_data$update_json_object extends ProcessContext> extends Process<ProcessContext$kedo$staffing_data$update_json_object> {
    "context": ProcessContext$kedo$staffing_data$update_json_object;
    run(context: Process$kedo$staffing_data$update_json_object$Context$$Data): Promise<TString>;
}

interface ProcessContext$kedo$staffing_data$update_json_object extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staffing_data"?: TApplication<Application$kedo$staffing_data$Data, Application$kedo$staffing_data$Params, Application$kedo$staffing_data$Processes>;
    "json_data"?: TString;
    "maximum_nesting_in_staffing"?: TFloat;
    "error"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$kedo$staffing_data$update_json_object$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staffing_data"?: TApplication<Application$kedo$staffing_data$Data, Application$kedo$staffing_data$Params, Application$kedo$staffing_data$Processes>;
    "json_data"?: TString;
    "maximum_nesting_in_staffing"?: TFloat;
    "error"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$personnel_documents$typical_business_process_orders<ProcessContext$personnel_documents$typical_business_process_orders extends ProcessContext> extends Process<ProcessContext$personnel_documents$typical_business_process_orders> {
    "context": ProcessContext$personnel_documents$typical_business_process_orders;
    run(context: Process$personnel_documents$typical_business_process_orders$Context$$Data): Promise<TString>;
}

interface ProcessContext$personnel_documents$typical_business_process_orders extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "full_name_responsible"?: TString;
    "app"?: TRefItem;
    "signatories"?: TUser;
    "alert_body"?: TString;
    "template_file"?: TFile;
    "decree_for_portal"?: TApplication<Application$personnel_documents$personnel_documents$Data, Application$personnel_documents$personnel_documents$Params, Application$personnel_documents$personnel_documents$Processes>;
    "decree"?: TRefItem;
    "document_file"?: TFile;
    "responsible"?: TUser;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "personnel_documents"?: TApplication<Application$personnel_documents$personnel_documents$Data, Application$personnel_documents$personnel_documents$Params, Application$personnel_documents$personnel_documents$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$personnel_documents$typical_business_process_orders$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "full_name_responsible"?: TString;
    "app"?: TRefItem;
    "signatories"?: TUser;
    "alert_body"?: TString;
    "template_file"?: TFile;
    "decree_for_portal"?: TApplication<Application$personnel_documents$personnel_documents$Data, Application$personnel_documents$personnel_documents$Params, Application$personnel_documents$personnel_documents$Processes>;
    "decree"?: TRefItem;
    "document_file"?: TFile;
    "responsible"?: TUser;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "personnel_documents"?: TApplication<Application$personnel_documents$personnel_documents$Data, Application$personnel_documents$personnel_documents$Params, Application$personnel_documents$personnel_documents$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacations$send_to_correction<ProcessContext$absences$vacations$send_to_correction extends ProcessContext> extends Process<ProcessContext$absences$vacations$send_to_correction> {
    "context": ProcessContext$absences$vacations$send_to_correction;
    run(context: Process$absences$vacations$send_to_correction$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacations$send_to_correction extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "chief_comment"?: TString;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacations$send_to_correction$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "chief_comment"?: TString;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$notification<ProcessContext$absences$notification extends ProcessContext> extends Process<ProcessContext$absences$notification> {
    "context": ProcessContext$absences$notification;
    run(context: Process$absences$notification$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$notification extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "sms_text"?: TString;
    "attachments"?: TFile[];
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "title"?: TString;
    "body"?: TString;
    "notification_type"?: TEnum<Enum$absences$notification$notification_type>;
    "notification_url"?: TString;
    "notification_body"?: TString;
    "user"?: TUser;
    "notification_title"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$absences$notification$notification_type = 'email'|'sms'|'email_and_sms'|'without_notification';

interface Process$absences$notification$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "sms_text"?: TString;
    "attachments"?: TFile[];
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "title"?: TString;
    "body"?: TString;
    "notification_type"?: TEnum<Enum$absences$notification$notification_type>;
    "notification_url"?: TString;
    "notification_body"?: TString;
    "user"?: TUser;
    "notification_title"?: TString;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacation_schedule$annual_vacation_planning_copy<ProcessContext$absences$vacation_schedule$annual_vacation_planning_copy extends ProcessContext> extends Process<ProcessContext$absences$vacation_schedule$annual_vacation_planning_copy> {
    "context": ProcessContext$absences$vacation_schedule$annual_vacation_planning_copy;
    run(context: Process$absences$vacation_schedule$annual_vacation_planning_copy$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacation_schedule$annual_vacation_planning_copy extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "year"?: TFloat;
    "staff_users"?: TUser[];
    "vacation_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "chiefs_kedo"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>[];
    "order_number"?: TString;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "comment"?: TString;
    "vacations_before"?: TString;
    "vacations_after"?: TString;
    "order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "order_file"?: TFile;
    "position"?: TString;
    "chiefs"?: TUser[];
    "director"?: TUser;
    "table"?: TTable<Table$absences$vacation_schedule$annual_vacation_planning_copy$table$Row, Table$absences$vacation_schedule$annual_vacation_planning_copy$table$Result>;
    "current_date"?: TDate;
    "debug"?: TString;
    "staff_ids"?: TString;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}


interface Table$absences$vacation_schedule$annual_vacation_planning_copy$table$Row {
     "__count": TFloat;
     "__index": TFloat;
     "vacation": TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
     "staff_app": TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
     "structal": TString;
     "position": TString;
     "full_name": TFullName;
     "number1C": TString;
     "start": TDate;
     "actual_start": TDate;
     "transfer_base": TString;
     "transfer_start": TDate;
     "end": TDate;
     "duration": TFloat;
     "staff_comment": TString;
     "rewrite": TBoolean;
     "has_holidays": TBoolean;
     "employee_full_name": TFullName;
}

interface Table$absences$vacation_schedule$annual_vacation_planning_copy$table$Result {
    readonly "__count": Readonly<TString>;
    readonly "__index": Readonly<TString>;
    readonly "vacation": Readonly<TString>;
    readonly "staff_app": Readonly<TString>;
    readonly "structal": Readonly<TString>;
    readonly "position": Readonly<TString>;
    readonly "full_name": Readonly<TString>;
    readonly "number1C": Readonly<TString>;
    readonly "start": Readonly<TString>;
    readonly "actual_start": Readonly<TString>;
    readonly "transfer_base": Readonly<TString>;
    readonly "transfer_start": Readonly<TString>;
    readonly "end": Readonly<TString>;
    readonly "duration": Readonly<TString>;
    readonly "staff_comment": Readonly<TString>;
    readonly "rewrite": Readonly<TString>;
    readonly "has_holidays": Readonly<TString>;
    readonly "employee_full_name": Readonly<TString>;
}


interface Process$absences$vacation_schedule$annual_vacation_planning_copy$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "year"?: TFloat;
    "staff_users"?: TUser[];
    "vacation_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "chiefs_kedo"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>[];
    "order_number"?: TString;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "comment"?: TString;
    "vacations_before"?: TString;
    "vacations_after"?: TString;
    "order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "order_file"?: TFile;
    "position"?: TString;
    "chiefs"?: TUser[];
    "director"?: TUser;
    "table"?: TTable<Table$absences$vacation_schedule$annual_vacation_planning_copy$table$Row, Table$absences$vacation_schedule$annual_vacation_planning_copy$table$Result>;
    "current_date"?: TDate;
    "debug"?: TString;
    "staff_ids"?: TString;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$personnel_documents$setlement_sheet$introduction_to_payroll<ProcessContext$personnel_documents$setlement_sheet$introduction_to_payroll extends ProcessContext> extends Process<ProcessContext$personnel_documents$setlement_sheet$introduction_to_payroll> {
    "context": ProcessContext$personnel_documents$setlement_sheet$introduction_to_payroll;
    run(context: Process$personnel_documents$setlement_sheet$introduction_to_payroll$Context$$Data): Promise<TString>;
}

interface ProcessContext$personnel_documents$setlement_sheet$introduction_to_payroll extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "user"?: TUser;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "setlement_sheet"?: TApplication<Application$personnel_documents$setlement_sheet$Data, Application$personnel_documents$setlement_sheet$Params, Application$personnel_documents$setlement_sheet$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$personnel_documents$setlement_sheet$introduction_to_payroll$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "user"?: TUser;
    "staff"?: TApplication<Application$kedo$staff$Data, Application$kedo$staff$Params, Application$kedo$staff$Processes>;
    "setlement_sheet"?: TApplication<Application$personnel_documents$setlement_sheet$Data, Application$personnel_documents$setlement_sheet$Params, Application$personnel_documents$setlement_sheet$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacation_schedule$approve_vacation_schedule_copy<ProcessContext$absences$vacation_schedule$approve_vacation_schedule_copy extends ProcessContext> extends Process<ProcessContext$absences$vacation_schedule$approve_vacation_schedule_copy> {
    "context": ProcessContext$absences$vacation_schedule$approve_vacation_schedule_copy;
    run(context: Process$absences$vacation_schedule$approve_vacation_schedule_copy$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacation_schedule$approve_vacation_schedule_copy extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff_ids"?: TString;
    "staff_correction"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>[];
    "vacation_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "vacations_correction"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "chief"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "chief_user"?: TUser;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacation_schedule$approve_vacation_schedule_copy$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "staff_ids"?: TString;
    "staff_correction"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>[];
    "vacation_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "vacations_correction"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "chief"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>;
    "chief_user"?: TUser;
    "staff"?: TApplication<Application$absences$staff$Data, Application$absences$staff$Params, Application$absences$staff$Processes>[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$change_current_account_for_salary<ProcessContext$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$change_current_account_for_salary extends ProcessContext> extends Process<ProcessContext$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$change_current_account_for_salary> {
    "context": ProcessContext$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$change_current_account_for_salary;
    run(context: Process$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$change_current_account_for_salary$Context$$Data): Promise<TString>;
}

interface ProcessContext$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$change_current_account_for_salary extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "template_file"?: TFile;
    "document_file"?: TFile;
    "application_for_the_transfer_of_salary_to_the_current_account"?: TApplication<Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Data, Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Params, Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$change_current_account_for_salary$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "template_file"?: TFile;
    "document_file"?: TFile;
    "application_for_the_transfer_of_salary_to_the_current_account"?: TApplication<Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Data, Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Params, Application$personnel_documents$application_for_the_transfer_of_salary_to_the_current_account$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$personnel_documents$benefit_application$benefit_processing<ProcessContext$personnel_documents$benefit_application$benefit_processing extends ProcessContext> extends Process<ProcessContext$personnel_documents$benefit_application$benefit_processing> {
    "context": ProcessContext$personnel_documents$benefit_application$benefit_processing;
    run(context: Process$personnel_documents$benefit_application$benefit_processing$Context$$Data): Promise<TString>;
}

interface ProcessContext$personnel_documents$benefit_application$benefit_processing extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "responsible_user"?: TUser;
    "benefit_application"?: TApplication<Application$personnel_documents$benefit_application$Data, Application$personnel_documents$benefit_application$Params, Application$personnel_documents$benefit_application$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$personnel_documents$benefit_application$benefit_processing$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "responsible_user"?: TUser;
    "benefit_application"?: TApplication<Application$personnel_documents$benefit_application$Data, Application$personnel_documents$benefit_application$Params, Application$personnel_documents$benefit_application$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacation_schedule$launch_of_annual_planning_copy<ProcessContext$absences$vacation_schedule$launch_of_annual_planning_copy extends ProcessContext> extends Process<ProcessContext$absences$vacation_schedule$launch_of_annual_planning_copy> {
    "context": ProcessContext$absences$vacation_schedule$launch_of_annual_planning_copy;
    run(context: Process$absences$vacation_schedule$launch_of_annual_planning_copy$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacation_schedule$launch_of_annual_planning_copy extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>[];
    "vacation_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacation_schedule$launch_of_annual_planning_copy$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "entity"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>[];
    "vacation_schedule"?: TApplication<Application$absences$vacation_schedule$Data, Application$absences$vacation_schedule$Params, Application$absences$vacation_schedule$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacations$recall_from_vacation<ProcessContext$absences$vacations$recall_from_vacation extends ProcessContext> extends Process<ProcessContext$absences$vacations$recall_from_vacation> {
    "context": ProcessContext$absences$vacations$recall_from_vacation;
    run(context: Process$absences$vacations$recall_from_vacation$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacations$recall_from_vacation extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "chief"?: TUser;
    "staff_user"?: TUser;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "recall_order"?: TFile;
    "vacation_order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "reschedule_vacation"?: TBoolean;
    "signed"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacations$recall_from_vacation$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "chief"?: TUser;
    "staff_user"?: TUser;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "recall_order"?: TFile;
    "vacation_order"?: TApplication<Application$absences$vacation_orders$Data, Application$absences$vacation_orders$Params, Application$absences$vacation_orders$Processes>;
    "reschedule_vacation"?: TBoolean;
    "signed"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$absences$vacations$vacation_notification<ProcessContext$absences$vacations$vacation_notification extends ProcessContext> extends Process<ProcessContext$absences$vacations$vacation_notification> {
    "context": ProcessContext$absences$vacations$vacation_notification;
    run(context: Process$absences$vacations$vacation_notification$Context$$Data): Promise<TString>;
}

interface ProcessContext$absences$vacations$vacation_notification extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "vacations_to_notify"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$absences$vacations$vacation_notification$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "vacations"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>;
    "vacations_to_notify"?: TApplication<Application$absences$vacations$Data, Application$absences$vacations$Params, Application$absences$vacations$Processes>[];
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_system_catalogs$_user_profiles$_block_user_profile<ProcessContext$_system_catalogs$_user_profiles$_block_user_profile extends ProcessContext> extends Process<ProcessContext$_system_catalogs$_user_profiles$_block_user_profile> {
    "context": ProcessContext$_system_catalogs$_user_profiles$_block_user_profile;
    run(context: Process$_system_catalogs$_user_profiles$_block_user_profile$Context$$Data): Promise<TString>;
}

interface ProcessContext$_system_catalogs$_user_profiles$_block_user_profile extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_user_profiles"?: TApplication<Application$_system_catalogs$_user_profiles$Data, Application$_system_catalogs$_user_profiles$Params, Application$_system_catalogs$_user_profiles$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_system_catalogs$_user_profiles$_block_user_profile$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_user_profiles"?: TApplication<Application$_system_catalogs$_user_profiles$Data, Application$_system_catalogs$_user_profiles$Params, Application$_system_catalogs$_user_profiles$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_system_catalogs$_user_profiles$_unblock_user_profile<ProcessContext$_system_catalogs$_user_profiles$_unblock_user_profile extends ProcessContext> extends Process<ProcessContext$_system_catalogs$_user_profiles$_unblock_user_profile> {
    "context": ProcessContext$_system_catalogs$_user_profiles$_unblock_user_profile;
    run(context: Process$_system_catalogs$_user_profiles$_unblock_user_profile$Context$$Data): Promise<TString>;
}

interface ProcessContext$_system_catalogs$_user_profiles$_unblock_user_profile extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_user_profiles"?: TApplication<Application$_system_catalogs$_user_profiles$Data, Application$_system_catalogs$_user_profiles$Params, Application$_system_catalogs$_user_profiles$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_system_catalogs$_user_profiles$_unblock_user_profile$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_user_profiles"?: TApplication<Application$_system_catalogs$_user_profiles$Data, Application$_system_catalogs$_user_profiles$Params, Application$_system_catalogs$_user_profiles$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$system$approval<ProcessContext$system$approval extends ProcessContext> extends Process<ProcessContext$system$approval> {
    "context": ProcessContext$system$approval;
    run(context: Process$system$approval$Context$$Data): Promise<TString>;
}

interface ProcessContext$system$approval extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "respondents"?: TUser[];
    "parallel"?: TBoolean;
    "approval_object"?: TRefItem;
    "interruptOnFirstReject"?: TBoolean;
    "rejected_percent"?: TFloat;
    "last_respondent"?: TUser;
    "approveBefore"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$system$approval$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "respondents"?: TUser[];
    "parallel"?: TBoolean;
    "approval_object"?: TRefItem;
    "interruptOnFirstReject"?: TBoolean;
    "rejected_percent"?: TFloat;
    "last_respondent"?: TUser;
    "approveBefore"?: TDatetime;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_transactions$_outgoing_invoices$_addFile<ProcessContext$_transactions$_outgoing_invoices$_addFile extends ProcessContext> extends Process<ProcessContext$_transactions$_outgoing_invoices$_addFile> {
    "context": ProcessContext$_transactions$_outgoing_invoices$_addFile;
    run(context: Process$_transactions$_outgoing_invoices$_addFile$Context$$Data): Promise<TString>;
}

interface ProcessContext$_transactions$_outgoing_invoices$_addFile extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "file"?: TFile;
    "_outgoing_invoices"?: TApplication<Application$_transactions$_outgoing_invoices$Data, Application$_transactions$_outgoing_invoices$Params, Application$_transactions$_outgoing_invoices$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_transactions$_outgoing_invoices$_addFile$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "file"?: TFile;
    "_outgoing_invoices"?: TApplication<Application$_transactions$_outgoing_invoices$Data, Application$_transactions$_outgoing_invoices$Params, Application$_transactions$_outgoing_invoices$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_transactions$_income$_income_planning_and_receipt<ProcessContext$_transactions$_income$_income_planning_and_receipt extends ProcessContext> extends Process<ProcessContext$_transactions$_income$_income_planning_and_receipt> {
    "context": ProcessContext$_transactions$_income$_income_planning_and_receipt;
    run(context: Process$_transactions$_income$_income_planning_and_receipt$Context$$Data): Promise<TString>;
}

interface ProcessContext$_transactions$_income$_income_planning_and_receipt extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "createNewPlanIncome"?: TBoolean;
    "remainingPlanIncomeAmount"?: TFloat;
    "plannedIncomeAmount"?: TFloat;
    "_plannedIncome"?: TApplication<Application$_transactions$_income$Data, Application$_transactions$_income$Params, Application$_transactions$_income$Processes>;
    "_responsible"?: TUser;
    "_plannedPaymentDate"?: TDate;
    "partiallyPaid"?: TBoolean;
    "newPlanIncome"?: TApplication<Application$_transactions$_income$Data, Application$_transactions$_income$Params, Application$_transactions$_income$Processes>;
    "_outgoingInvoices"?: TApplication<Application$_transactions$_outgoing_invoices$Data, Application$_transactions$_outgoing_invoices$Params, Application$_transactions$_outgoing_invoices$Processes>[];
    "factIncomeAmount"?: TFloat;
    "_planFact"?: TEnum<Enum$_transactions$_income$_income_planning_and_receipt$_planFact>;
    "income"?: TApplication<Application$_transactions$_income$Data, Application$_transactions$_income$Params, Application$_transactions$_income$Processes>;
    "distributedInvoice"?: TApplication<Application$_transactions$_outgoing_invoices$Data, Application$_transactions$_outgoing_invoices$Params, Application$_transactions$_outgoing_invoices$Processes>;
    "actualIncomeExists"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
type Enum$_transactions$_income$_income_planning_and_receipt$_planFact = 'plan'|'fact';

interface Process$_transactions$_income$_income_planning_and_receipt$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "createNewPlanIncome"?: TBoolean;
    "remainingPlanIncomeAmount"?: TFloat;
    "plannedIncomeAmount"?: TFloat;
    "_plannedIncome"?: TApplication<Application$_transactions$_income$Data, Application$_transactions$_income$Params, Application$_transactions$_income$Processes>;
    "_responsible"?: TUser;
    "_plannedPaymentDate"?: TDate;
    "partiallyPaid"?: TBoolean;
    "newPlanIncome"?: TApplication<Application$_transactions$_income$Data, Application$_transactions$_income$Params, Application$_transactions$_income$Processes>;
    "_outgoingInvoices"?: TApplication<Application$_transactions$_outgoing_invoices$Data, Application$_transactions$_outgoing_invoices$Params, Application$_transactions$_outgoing_invoices$Processes>[];
    "factIncomeAmount"?: TFloat;
    "_planFact"?: TEnum<Enum$_transactions$_income$_income_planning_and_receipt$_planFact>;
    "income"?: TApplication<Application$_transactions$_income$Data, Application$_transactions$_income$Params, Application$_transactions$_income$Processes>;
    "distributedInvoice"?: TApplication<Application$_transactions$_outgoing_invoices$Data, Application$_transactions$_outgoing_invoices$Params, Application$_transactions$_outgoing_invoices$Processes>;
    "actualIncomeExists"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_transactions$_outgoing_invoices$_invoiceGeneration<ProcessContext$_transactions$_outgoing_invoices$_invoiceGeneration extends ProcessContext> extends Process<ProcessContext$_transactions$_outgoing_invoices$_invoiceGeneration> {
    "context": ProcessContext$_transactions$_outgoing_invoices$_invoiceGeneration;
    run(context: Process$_transactions$_outgoing_invoices$_invoiceGeneration$Context$$Data): Promise<TString>;
}

interface ProcessContext$_transactions$_outgoing_invoices$_invoiceGeneration extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_managerFullName"?: TFullName;
    "invoiceFile"?: TFile;
    "_ourCompany"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "_contractor"?: TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "_outgoing_invoices"?: TApplication<Application$_transactions$_outgoing_invoices$Data, Application$_transactions$_outgoing_invoices$Params, Application$_transactions$_outgoing_invoices$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_transactions$_outgoing_invoices$_invoiceGeneration$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_managerFullName"?: TFullName;
    "invoiceFile"?: TFile;
    "_ourCompany"?: TApplication<Application$_system_catalogs$_my_companies$Data, Application$_system_catalogs$_my_companies$Params, Application$_system_catalogs$_my_companies$Processes>;
    "_contractor"?: TApplication<Application$_clients$_companies$Data, Application$_clients$_companies$Params, Application$_clients$_companies$Processes>;
    "_outgoing_invoices"?: TApplication<Application$_transactions$_outgoing_invoices$Data, Application$_transactions$_outgoing_invoices$Params, Application$_transactions$_outgoing_invoices$Processes>;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_clients$_leads$_letter<ProcessContext$_clients$_leads$_letter extends ProcessContext> extends Process<ProcessContext$_clients$_leads$_letter> {
    "context": ProcessContext$_clients$_leads$_letter;
    run(context: Process$_clients$_leads$_letter$Context$$Data): Promise<TString>;
}

interface ProcessContext$_clients$_leads$_letter extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "executor"?: TUser;
    "due_date"?: TDatetime;
    "end_at"?: TDatetime;
    "item_ref"?: TRefItem;
    "executor_comment"?: TString;
    "plan_start"?: TDatetime;
    "show_in_calendar"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_clients$_leads$_letter$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "executor"?: TUser;
    "due_date"?: TDatetime;
    "end_at"?: TDatetime;
    "item_ref"?: TRefItem;
    "executor_comment"?: TString;
    "plan_start"?: TDatetime;
    "show_in_calendar"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

interface Process$_project_management$_project_plan$_approval_of_project_plan<ProcessContext$_project_management$_project_plan$_approval_of_project_plan extends ProcessContext> extends Process<ProcessContext$_project_management$_project_plan$_approval_of_project_plan> {
    "context": ProcessContext$_project_management$_project_plan$_approval_of_project_plan;
    run(context: Process$_project_management$_project_plan$_approval_of_project_plan$Context$$Data): Promise<TString>;
}

interface ProcessContext$_project_management$_project_plan$_approval_of_project_plan extends ProcessContext {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_user_in_approval"?: TUser;
    "_project_plan"?: TApplication<Application$_project_management$_project_plan$Data, Application$_project_management$_project_plan$Params, Application$_project_management$_project_plan$Processes>;
    "_approval_result"?: TString;
    "_project_manager"?: TUser;
    "_publish_after_approval"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}
interface Process$_project_management$_project_plan$_approval_of_project_plan$Context$$Data extends ItemData {
    "__id"?: TString;
    "__name"?: TString;
    "__createdAt"?: TDatetime;
    "__createdBy"?: TUser;
    "__updatedAt"?: TDatetime;
    "__updatedBy"?: TUser;
    "__deletedAt"?: TDatetime;
    "_user_in_approval"?: TUser;
    "_project_plan"?: TApplication<Application$_project_management$_project_plan$Data, Application$_project_management$_project_plan$Params, Application$_project_management$_project_plan$Processes>;
    "_approval_result"?: TString;
    "_project_manager"?: TUser;
    "_publish_after_approval"?: TBoolean;
    "__state"?: TString;
    "__target"?: TLink;
    "__targetData"?: TJSON;
    "__subscribers"?: TUser[];
    "__currentPerformers"?: TUser[];
    "__templateId"?: TString;
    "__logged"?: TBoolean;
    "__notifyOnStart"?: TBoolean;
    "__item"?: TRefItem;
    "__parentId"?: TString;
    "__parent"?: TJSON;
    "__branches"?: TJSON;
    "__template"?: TJSON;
    "__tasks"?: TJSON;
}

declare const Namespace: Namespace$ext_9e324a78U002Dc635U002D4f21U002D883cU002D05c34feea2c9;

declare const Server: ServerCollection;

interface Processes$system extends Processes {
    approval: Process$system$approval<ProcessContext$system$approval>;
    inform: Process$system$inform<ProcessContext$system$inform>;
    opoveshenie_o_razryve_svyazi_s_messendzherom: Process$system$opoveshenie_o_razryve_svyazi_s_messendzherom<ProcessContext$system$opoveshenie_o_razryve_svyazi_s_messendzherom>;
    opoveshenie_o_zavershenii_poiska_dublei: Process$system$opoveshenie_o_zavershenii_poiska_dublei<ProcessContext$system$opoveshenie_o_zavershenii_poiska_dublei>;
    task: Process$system$task<ProcessContext$system$task>;
}

declare const System: SystemCollections<Processes$system>;

declare const UI: BaseUI;

interface Context$$Data extends ItemData {
    "url": TString;
    "authorization": TString;
    "filter": TString;
    "fields": TString;
    "id": TString;
    "json": TJSON;
}

declare const Context: Item<Context$$Data>;

interface ContextOperands {
    "url": ContextOperand;
    "authorization": ContextOperand;
    "filter": ContextOperand;
    "fields": ContextOperand;
    "id": ContextOperand;
    "json": ContextOperand;
}
interface ViewContext$$Data extends ItemData {
    "url": TString;
    "authorization": TString;
    "filter": TString;
    "fields": TString;
    "id": TString;
    "json": TJSON;
}

declare const ViewContext: Item<ViewContext$$Data>;

interface ViewContextOperands {
    "url": ContextOperand;
    "authorization": ContextOperand;
    "filter": ContextOperand;
    "fields": ContextOperand;
    "id": ContextOperand;
    "json": ContextOperand;
}